import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_lodash
} from "./chunk-M3UN5UOR.js";
import {
  require_src
} from "./chunk-7IJ7C64B.js";
import {
  require_immutable
} from "./chunk-MWTTE2MT.js";
import {
  require_brorand,
  require_crypto_browserify,
  require_elliptic
} from "./chunk-GK5GMHRA.js";
import "./chunk-H4B3ZSJ5.js";
import "./chunk-NUR4LEB5.js";
import "./chunk-YAOGXNJ4.js";
import "./chunk-I4BR23GQ.js";
import "./chunk-4BEBNIKB.js";
import "./chunk-TCWSTB3Z.js";
import "./chunk-SVJFUM6P.js";
import {
  require_browser
} from "./chunk-OO5GWCLM.js";
import "./chunk-CQUL2S6K.js";
import {
  require_hash
} from "./chunk-A6A3TVJO.js";
import "./chunk-UIG5FSMX.js";
import "./chunk-2ZI3YODM.js";
import "./chunk-LZNBOUBI.js";
import {
  require_callBound,
  require_call_bind,
  require_call_bound,
  require_define_data_property,
  require_end_of_stream,
  require_events,
  require_get_intrinsic,
  require_has_property_descriptors,
  require_pipeline,
  require_shams,
  require_stream_duplex,
  require_stream_passthrough,
  require_stream_readable,
  require_stream_transform,
  require_stream_writable,
  require_type,
  require_util
} from "./chunk-VILP4OZO.js";
import "./chunk-FU55H4EU.js";
import {
  require_inherits_browser
} from "./chunk-PSMAFUOK.js";
import {
  require_bn
} from "./chunk-A4DENNXW.js";
import "./chunk-3PLQ733S.js";
import "./chunk-WKI7UJOK.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-W7YBHVXA.js";

// node_modules/ripple-lib/dist/npm/common/txflags.js
var require_txflags = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/txflags.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.txFlagIndices = exports.txFlags = void 0;
    var txFlags = {
      Universal: {
        FullyCanonicalSig: 2147483648
      },
      AccountSet: {
        RequireDestTag: 65536,
        OptionalDestTag: 131072,
        RequireAuth: 262144,
        OptionalAuth: 524288,
        DisallowXRP: 1048576,
        AllowXRP: 2097152
      },
      TrustSet: {
        SetAuth: 65536,
        NoRipple: 131072,
        SetNoRipple: 131072,
        ClearNoRipple: 262144,
        SetFreeze: 1048576,
        ClearFreeze: 2097152
      },
      OfferCreate: {
        Passive: 65536,
        ImmediateOrCancel: 131072,
        FillOrKill: 262144,
        Sell: 524288
      },
      Payment: {
        NoRippleDirect: 65536,
        PartialPayment: 131072,
        LimitQuality: 262144
      },
      PaymentChannelClaim: {
        Renew: 65536,
        Close: 131072
      }
    };
    exports.txFlags = txFlags;
    var txFlagIndices = {
      AccountSet: {
        asfRequireDest: 1,
        asfRequireAuth: 2,
        asfDisallowXRP: 3,
        asfDisableMaster: 4,
        asfAccountTxnID: 5,
        asfNoFreeze: 6,
        asfGlobalFreeze: 7,
        asfDefaultRipple: 8,
        asfDepositAuth: 9
      }
    };
    exports.txFlagIndices = txFlagIndices;
  }
});

// node_modules/ripple-lib/dist/npm/common/constants.js
var require_constants = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/constants.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountFlags = exports.AccountSetFlags = exports.AccountFields = void 0;
    var txflags_1 = require_txflags();
    var accountRootFlags = {
      DefaultRipple: 8388608,
      DepositAuth: 16777216,
      DisableMaster: 1048576,
      DisallowXRP: 524288,
      GlobalFreeze: 4194304,
      NoFreeze: 2097152,
      PasswordSpent: 65536,
      RequireAuth: 262144,
      RequireDestTag: 131072
    };
    var AccountFlags = {
      passwordSpent: accountRootFlags.PasswordSpent,
      requireDestinationTag: accountRootFlags.RequireDestTag,
      requireAuthorization: accountRootFlags.RequireAuth,
      depositAuth: accountRootFlags.DepositAuth,
      disallowIncomingXRP: accountRootFlags.DisallowXRP,
      disableMasterKey: accountRootFlags.DisableMaster,
      noFreeze: accountRootFlags.NoFreeze,
      globalFreeze: accountRootFlags.GlobalFreeze,
      defaultRipple: accountRootFlags.DefaultRipple
    };
    exports.AccountFlags = AccountFlags;
    var AccountSetFlags = {
      requireDestinationTag: txflags_1.txFlagIndices.AccountSet.asfRequireDest,
      requireAuthorization: txflags_1.txFlagIndices.AccountSet.asfRequireAuth,
      depositAuth: txflags_1.txFlagIndices.AccountSet.asfDepositAuth,
      disallowIncomingXRP: txflags_1.txFlagIndices.AccountSet.asfDisallowXRP,
      disableMasterKey: txflags_1.txFlagIndices.AccountSet.asfDisableMaster,
      enableTransactionIDTracking: txflags_1.txFlagIndices.AccountSet.asfAccountTxnID,
      noFreeze: txflags_1.txFlagIndices.AccountSet.asfNoFreeze,
      globalFreeze: txflags_1.txFlagIndices.AccountSet.asfGlobalFreeze,
      defaultRipple: txflags_1.txFlagIndices.AccountSet.asfDefaultRipple
    };
    exports.AccountSetFlags = AccountSetFlags;
    var AccountFields = {
      EmailHash: {
        name: "emailHash",
        encoding: "hex",
        length: 32,
        defaults: "00000000000000000000000000000000"
      },
      WalletLocator: { name: "walletLocator" },
      MessageKey: { name: "messageKey" },
      Domain: { name: "domain", encoding: "hex" },
      TransferRate: { name: "transferRate", defaults: 0, shift: 9 },
      TickSize: { name: "tickSize", defaults: 0 }
    };
    exports.AccountFields = AccountFields;
  }
});

// node_modules/ripple-lib/dist/npm/common/browser-hacks.js
var require_browser_hacks = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/browser-hacks.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setPrototypeOf = exports.getConstructorName = void 0;
    function setPrototypeOf(object, prototype) {
      Object.setPrototypeOf ? Object.setPrototypeOf(object, prototype) : object.__proto__ = prototype;
    }
    exports.setPrototypeOf = setPrototypeOf;
    function getConstructorName(object) {
      if (object.constructor.name) {
        return object.constructor.name;
      }
      const constructorString = object.constructor.toString();
      const functionConstructor = constructorString.match(/^function\s+([^(]*)/);
      const classConstructor = constructorString.match(/^class\s([^\s]*)/);
      return functionConstructor ? functionConstructor[1] : classConstructor[1];
    }
    exports.getConstructorName = getConstructorName;
  }
});

// node_modules/ripple-lib/dist/npm/common/errors.js
var require_errors = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/errors.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XRPLFaucetError = exports.LedgerVersionError = exports.MissingLedgerHistoryError = exports.PendingLedgerVersionError = exports.NotFoundError = exports.ValidationError = exports.ResponseFormatError = exports.TimeoutError = exports.RippledNotInitializedError = exports.DisconnectedError = exports.NotConnectedError = exports.RippledError = exports.ConnectionError = exports.UnexpectedError = exports.RippleError = void 0;
    var util_1 = require_util();
    var browserHacks = __importStar(require_browser_hacks());
    var RippleError = class extends Error {
      constructor(message = "", data) {
        super(message);
        this.name = browserHacks.getConstructorName(this);
        this.message = message;
        this.data = data;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
      toString() {
        let result = "[" + this.name + "(" + this.message;
        if (this.data) {
          result += ", " + util_1.inspect(this.data);
        }
        result += ")]";
        return result;
      }
      inspect() {
        return this.toString();
      }
    };
    exports.RippleError = RippleError;
    var RippledError = class extends RippleError {
    };
    exports.RippledError = RippledError;
    var UnexpectedError = class extends RippleError {
    };
    exports.UnexpectedError = UnexpectedError;
    var LedgerVersionError = class extends RippleError {
    };
    exports.LedgerVersionError = LedgerVersionError;
    var ConnectionError = class extends RippleError {
    };
    exports.ConnectionError = ConnectionError;
    var NotConnectedError = class extends ConnectionError {
    };
    exports.NotConnectedError = NotConnectedError;
    var DisconnectedError = class extends ConnectionError {
    };
    exports.DisconnectedError = DisconnectedError;
    var RippledNotInitializedError = class extends ConnectionError {
    };
    exports.RippledNotInitializedError = RippledNotInitializedError;
    var TimeoutError = class extends ConnectionError {
    };
    exports.TimeoutError = TimeoutError;
    var ResponseFormatError = class extends ConnectionError {
    };
    exports.ResponseFormatError = ResponseFormatError;
    var ValidationError = class extends RippleError {
    };
    exports.ValidationError = ValidationError;
    var XRPLFaucetError = class extends RippleError {
    };
    exports.XRPLFaucetError = XRPLFaucetError;
    var NotFoundError = class extends RippleError {
      constructor(message = "Not found") {
        super(message);
      }
    };
    exports.NotFoundError = NotFoundError;
    var MissingLedgerHistoryError = class extends RippleError {
      constructor(message) {
        super(message || "Server is missing ledger history in the specified range");
      }
    };
    exports.MissingLedgerHistoryError = MissingLedgerHistoryError;
    var PendingLedgerVersionError = class extends RippleError {
      constructor(message) {
        super(message || "maxLedgerVersion is greater than server's most recent validated ledger");
      }
    };
    exports.PendingLedgerVersionError = PendingLedgerVersionError;
  }
});

// node_modules/assert/build/internal/errors.js
var require_errors2 = __commonJS({
  "node_modules/assert/build/internal/errors.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var codes = {};
    var assert;
    var util;
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inherits(NodeError2, _Base);
        var _super = _createSuper(NodeError2);
        function NodeError2(arg1, arg2, arg3) {
          var _this;
          _classCallCheck(this, NodeError2);
          _this = _super.call(this, getMessage(arg1, arg2, arg3));
          _this.code = code;
          return _this;
        }
        return _createClass(NodeError2);
      }(Base);
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      if (assert === void 0) assert = require_assert();
      assert(typeof name === "string", "'name' must be a string");
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(_typeof(actual));
      return msg;
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
      var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
      if (util === void 0) util = require_util();
      var inspected = util.inspect(value);
      if (inspected.length > 128) {
        inspected = "".concat(inspected.slice(0, 128), "...");
      }
      return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
    }, TypeError, RangeError);
    createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
      var type;
      if (value && value.constructor && value.constructor.name) {
        type = "instance of ".concat(value.constructor.name);
      } else {
        type = "type ".concat(_typeof(value));
      }
      return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
    }, TypeError);
    createErrorType("ERR_MISSING_ARGS", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (assert === void 0) assert = require_assert();
      assert(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len = args.length;
      args = args.map(function(a) {
        return '"'.concat(a, '"');
      });
      switch (len) {
        case 1:
          msg += "".concat(args[0], " argument");
          break;
        case 2:
          msg += "".concat(args[0], " and ").concat(args[1], " arguments");
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += ", and ".concat(args[len - 1], " arguments");
          break;
      }
      return "".concat(msg, " must be specified");
    }, TypeError);
    module.exports.codes = codes;
  }
});

// node_modules/assert/build/internal/assert/assertion_error.js
var require_assertion_error = __commonJS({
  "node_modules/assert/build/internal/assert/assertion_error.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2) _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var _require = require_util();
    var inspect = _require.inspect;
    var _require2 = require_errors2();
    var ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function repeat(str, count) {
      count = Math.floor(count);
      if (str.length == 0 || count == 0) return "";
      var maxCount = str.length * count;
      count = Math.floor(Math.log(count) / Math.log(2));
      while (count) {
        str += str;
        count--;
      }
      str += str.substring(0, maxCount - str.length);
      return str;
    }
    var blue = "";
    var green = "";
    var red = "";
    var white = "";
    var kReadableOperator = {
      deepStrictEqual: "Expected values to be strictly deep-equal:",
      strictEqual: "Expected values to be strictly equal:",
      strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
      deepEqual: "Expected values to be loosely deep-equal:",
      equal: "Expected values to be loosely equal:",
      notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
      notStrictEqual: 'Expected "actual" to be strictly unequal to:',
      notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
      notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
      notEqual: 'Expected "actual" to be loosely unequal to:',
      notIdentical: "Values identical but not reference-equal:"
    };
    var kMaxShortLength = 10;
    function copyError(source) {
      var keys = Object.keys(source);
      var target = Object.create(Object.getPrototypeOf(source));
      keys.forEach(function(key) {
        target[key] = source[key];
      });
      Object.defineProperty(target, "message", {
        value: source.message
      });
      return target;
    }
    function inspectValue(val) {
      return inspect(val, {
        compact: false,
        customInspect: false,
        depth: 1e3,
        maxArrayLength: Infinity,
        // Assert compares only enumerable properties (with a few exceptions).
        showHidden: false,
        // Having a long line as error is better than wrapping the line for
        // comparison for now.
        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
        // have meta information about the inspected properties (i.e., know where
        // in what line the property starts and ends).
        breakLength: Infinity,
        // Assert does not detect proxies currently.
        showProxy: false,
        sorted: true,
        // Inspect getters as we also check them when comparing entries.
        getters: true
      });
    }
    function createErrDiff(actual, expected, operator) {
      var other = "";
      var res = "";
      var lastPos = 0;
      var end = "";
      var skipped = false;
      var actualInspected = inspectValue(actual);
      var actualLines = actualInspected.split("\n");
      var expectedLines = inspectValue(expected).split("\n");
      var i = 0;
      var indicator = "";
      if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
        operator = "strictEqualObject";
      }
      if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length;
        if (inputLength <= kMaxShortLength) {
          if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
            return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
          }
        } else if (operator !== "strictEqualObject") {
          var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
          if (inputLength < maxLength) {
            while (actualLines[0][i] === expectedLines[0][i]) {
              i++;
            }
            if (i > 2) {
              indicator = "\n  ".concat(repeat(" ", i), "^");
              i = 0;
            }
          }
        }
      }
      var a = actualLines[actualLines.length - 1];
      var b = expectedLines[expectedLines.length - 1];
      while (a === b) {
        if (i++ < 2) {
          end = "\n  ".concat(a).concat(end);
        } else {
          other = a;
        }
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0) break;
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
      }
      var maxLines = Math.max(actualLines.length, expectedLines.length);
      if (maxLines === 0) {
        var _actualLines = actualInspected.split("\n");
        if (_actualLines.length > 30) {
          _actualLines[26] = "".concat(blue, "...").concat(white);
          while (_actualLines.length > 27) {
            _actualLines.pop();
          }
        }
        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
      }
      if (i > 3) {
        end = "\n".concat(blue, "...").concat(white).concat(end);
        skipped = true;
      }
      if (other !== "") {
        end = "\n  ".concat(other).concat(end);
        other = "";
      }
      var printedLines = 0;
      var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
      var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
      for (i = 0; i < maxLines; i++) {
        var cur = i - lastPos;
        if (actualLines.length < i + 1) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(expectedLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(expectedLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
          printedLines++;
        } else if (expectedLines.length < i + 1) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(actualLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(actualLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
          printedLines++;
        } else {
          var expectedLine = expectedLines[i];
          var actualLine = actualLines[i];
          var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
          if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
            divergingLines = false;
            actualLine += ",";
          }
          if (divergingLines) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
            printedLines += 2;
          } else {
            res += other;
            other = "";
            if (cur === 1 || i === 0) {
              res += "\n  ".concat(actualLine);
              printedLines++;
            }
          }
        }
        if (printedLines > 20 && i < maxLines - 2) {
          return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
        }
      }
      return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
    }
    var AssertionError = function(_Error, _inspect$custom) {
      _inherits(AssertionError2, _Error);
      var _super = _createSuper(AssertionError2);
      function AssertionError2(options) {
        var _this;
        _classCallCheck(this, AssertionError2);
        if (_typeof(options) !== "object" || options === null) {
          throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
        var actual = options.actual, expected = options.expected;
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        if (message != null) {
          _this = _super.call(this, String(message));
        } else {
          if (process.stderr && process.stderr.isTTY) {
            if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
              blue = "\x1B[34m";
              green = "\x1B[32m";
              white = "\x1B[39m";
              red = "\x1B[31m";
            } else {
              blue = "";
              green = "";
              white = "";
              red = "";
            }
          }
          if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
            actual = copyError(actual);
            expected = copyError(expected);
          }
          if (operator === "deepStrictEqual" || operator === "strictEqual") {
            _this = _super.call(this, createErrDiff(actual, expected, operator));
          } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
            var base = kReadableOperator[operator];
            var res = inspectValue(actual).split("\n");
            if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
              base = kReadableOperator.notStrictEqualObject;
            }
            if (res.length > 30) {
              res[26] = "".concat(blue, "...").concat(white);
              while (res.length > 27) {
                res.pop();
              }
            }
            if (res.length === 1) {
              _this = _super.call(this, "".concat(base, " ").concat(res[0]));
            } else {
              _this = _super.call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n"));
            }
          } else {
            var _res = inspectValue(actual);
            var other = "";
            var knownOperators = kReadableOperator[operator];
            if (operator === "notDeepEqual" || operator === "notEqual") {
              _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
              if (_res.length > 1024) {
                _res = "".concat(_res.slice(0, 1021), "...");
              }
            } else {
              other = "".concat(inspectValue(expected));
              if (_res.length > 512) {
                _res = "".concat(_res.slice(0, 509), "...");
              }
              if (other.length > 512) {
                other = "".concat(other.slice(0, 509), "...");
              }
              if (operator === "deepEqual" || operator === "equal") {
                _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
              } else {
                other = " ".concat(operator, " ").concat(other);
              }
            }
            _this = _super.call(this, "".concat(_res).concat(other));
          }
        }
        Error.stackTraceLimit = limit;
        _this.generatedMessage = !message;
        Object.defineProperty(_assertThisInitialized(_this), "name", {
          value: "AssertionError [ERR_ASSERTION]",
          enumerable: false,
          writable: true,
          configurable: true
        });
        _this.code = "ERR_ASSERTION";
        _this.actual = actual;
        _this.expected = expected;
        _this.operator = operator;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
        }
        _this.stack;
        _this.name = "AssertionError";
        return _possibleConstructorReturn(_this);
      }
      _createClass(AssertionError2, [{
        key: "toString",
        value: function toString() {
          return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
        }
      }, {
        key: _inspect$custom,
        value: function value(recurseTimes, ctx) {
          return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
            customInspect: false,
            depth: 0
          }));
        }
      }]);
      return AssertionError2;
    }(_wrapNativeSuper(Error), inspect.custom);
    module.exports = AssertionError;
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/object.assign/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/object.assign/implementation.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var objectKeys = require_object_keys();
    var hasSymbols = require_shams()();
    var callBound = require_callBound();
    var toObject = Object;
    var $push = callBound("Array.prototype.push");
    var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
    module.exports = function assign(target, source1) {
      if (target == null) {
        throw new TypeError("target must be an object");
      }
      var to = toObject(target);
      if (arguments.length === 1) {
        return to;
      }
      for (var s = 1; s < arguments.length; ++s) {
        var from = toObject(arguments[s]);
        var keys = objectKeys(from);
        var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
        if (getSymbols) {
          var syms = getSymbols(from);
          for (var j = 0; j < syms.length; ++j) {
            var key = syms[j];
            if ($propIsEnumerable(from, key)) {
              $push(keys, key);
            }
          }
        }
        for (var i = 0; i < keys.length; ++i) {
          var nextKey = keys[i];
          if ($propIsEnumerable(from, nextKey)) {
            var propValue = from[nextKey];
            to[nextKey] = propValue;
          }
        }
      }
      return to;
    };
  }
});

// node_modules/object.assign/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/object.assign/polyfill.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var implementation = require_implementation2();
    var lacksProperEnumerationOrder = function() {
      if (!Object.assign) {
        return false;
      }
      var str = "abcdefghijklmnopqrst";
      var letters = str.split("");
      var map = {};
      for (var i = 0; i < letters.length; ++i) {
        map[letters[i]] = letters[i];
      }
      var obj = Object.assign({}, map);
      var actual = "";
      for (var k in obj) {
        actual += k;
      }
      return str !== actual;
    };
    var assignHasPendingExceptions = function() {
      if (!Object.assign || !Object.preventExtensions) {
        return false;
      }
      var thrower = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(thrower, "xy");
      } catch (e) {
        return thrower[1] === "y";
      }
      return false;
    };
    module.exports = function getPolyfill() {
      if (!Object.assign) {
        return implementation;
      }
      if (lacksProperEnumerationOrder()) {
        return implementation;
      }
      if (assignHasPendingExceptions()) {
        return implementation;
      }
      return Object.assign;
    };
  }
});

// node_modules/object-is/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/object-is/implementation.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module.exports = function is(a, b) {
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      }
      if (a === b) {
        return true;
      }
      if (numberIsNaN(a) && numberIsNaN(b)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/object-is/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/object-is/polyfill.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var implementation = require_implementation3();
    module.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/object-is/shim.js
var require_shim = __commonJS({
  "node_modules/object-is/shim.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var getPolyfill = require_polyfill2();
    var define2 = require_define_properties();
    module.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object-is/index.js
var require_object_is = __commonJS({
  "node_modules/object-is/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill2();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// node_modules/is-nan/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/is-nan/implementation.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module.exports = function isNaN2(value) {
      return value !== value;
    };
  }
});

// node_modules/is-nan/polyfill.js
var require_polyfill3 = __commonJS({
  "node_modules/is-nan/polyfill.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var implementation = require_implementation4();
    module.exports = function getPolyfill() {
      if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
        return Number.isNaN;
      }
      return implementation;
    };
  }
});

// node_modules/is-nan/shim.js
var require_shim2 = __commonJS({
  "node_modules/is-nan/shim.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill3();
    module.exports = function shimNumberIsNaN() {
      var polyfill = getPolyfill();
      define2(Number, { isNaN: polyfill }, {
        isNaN: function testIsNaN() {
          return Number.isNaN !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/is-nan/index.js
var require_is_nan = __commonJS({
  "node_modules/is-nan/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var callBind = require_call_bind();
    var define2 = require_define_properties();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill3();
    var shim = require_shim2();
    var polyfill = callBind(getPolyfill(), Number);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// node_modules/assert/build/internal/util/comparisons.js
var require_comparisons = __commonJS({
  "node_modules/assert/build/internal/util/comparisons.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var regexFlagsSupported = /a/g.flags !== void 0;
    var arrayFromSet = function arrayFromSet2(set) {
      var array = [];
      set.forEach(function(value) {
        return array.push(value);
      });
      return array;
    };
    var arrayFromMap = function arrayFromMap2(map) {
      var array = [];
      map.forEach(function(value, key) {
        return array.push([key, value]);
      });
      return array;
    };
    var objectIs = Object.is ? Object.is : require_object_is();
    var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    };
    var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
    var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
    var objectToString = uncurryThis(Object.prototype.toString);
    var _require$types = require_util().types;
    var isAnyArrayBuffer = _require$types.isAnyArrayBuffer;
    var isArrayBufferView = _require$types.isArrayBufferView;
    var isDate = _require$types.isDate;
    var isMap = _require$types.isMap;
    var isRegExp = _require$types.isRegExp;
    var isSet = _require$types.isSet;
    var isNativeError = _require$types.isNativeError;
    var isBoxedPrimitive = _require$types.isBoxedPrimitive;
    var isNumberObject = _require$types.isNumberObject;
    var isStringObject = _require$types.isStringObject;
    var isBooleanObject = _require$types.isBooleanObject;
    var isBigIntObject = _require$types.isBigIntObject;
    var isSymbolObject = _require$types.isSymbolObject;
    var isFloat32Array = _require$types.isFloat32Array;
    var isFloat64Array = _require$types.isFloat64Array;
    function isNonIndex(key) {
      if (key.length === 0 || key.length > 10) return true;
      for (var i = 0; i < key.length; i++) {
        var code = key.charCodeAt(i);
        if (code < 48 || code > 57) return true;
      }
      return key.length === 10 && key >= Math.pow(2, 32);
    }
    function getOwnNonIndexProperties(value) {
      return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
    }
    function compare(a, b) {
      if (a === b) {
        return 0;
      }
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    var ONLY_ENUMERABLE = void 0;
    var kStrict = true;
    var kLoose = false;
    var kNoIterator = 0;
    var kIsArray = 1;
    var kIsSet = 2;
    var kIsMap = 3;
    function areSimilarRegExps(a, b) {
      return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
    }
    function areSimilarFloatArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (var offset = 0; offset < a.byteLength; offset++) {
        if (a[offset] !== b[offset]) {
          return false;
        }
      }
      return true;
    }
    function areSimilarTypedArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
    }
    function areEqualArrayBuffers(buf1, buf2) {
      return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
    }
    function isEqualBoxedPrimitive(val1, val2) {
      if (isNumberObject(val1)) {
        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
      }
      if (isStringObject(val1)) {
        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
      }
      if (isBooleanObject(val1)) {
        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
      }
      if (isBigIntObject(val1)) {
        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
      }
      return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
    }
    function innerDeepEqual(val1, val2, strict, memos) {
      if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? objectIs(val1, val2) : true;
      }
      if (strict) {
        if (_typeof(val1) !== "object") {
          return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
        }
        if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
          return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
          return false;
        }
      } else {
        if (val1 === null || _typeof(val1) !== "object") {
          if (val2 === null || _typeof(val2) !== "object") {
            return val1 == val2;
          }
          return false;
        }
        if (val2 === null || _typeof(val2) !== "object") {
          return false;
        }
      }
      var val1Tag = objectToString(val1);
      var val2Tag = objectToString(val2);
      if (val1Tag !== val2Tag) {
        return false;
      }
      if (Array.isArray(val1)) {
        if (val1.length !== val2.length) {
          return false;
        }
        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (keys1.length !== keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
      }
      if (val1Tag === "[object Object]") {
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
          return false;
        }
      }
      if (isDate(val1)) {
        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
          return false;
        }
      } else if (isRegExp(val1)) {
        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
          return false;
        }
      } else if (isNativeError(val1) || val1 instanceof Error) {
        if (val1.message !== val2.message || val1.name !== val2.name) {
          return false;
        }
      } else if (isArrayBufferView(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
          if (!areSimilarFloatArrays(val1, val2)) {
            return false;
          }
        } else if (!areSimilarTypedArrays(val1, val2)) {
          return false;
        }
        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (_keys.length !== _keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
      } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsSet);
      } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsMap);
      } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2)) {
          return false;
        }
      } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kNoIterator);
    }
    function getEnumerables(val, keys) {
      return keys.filter(function(k) {
        return propertyIsEnumerable(val, k);
      });
    }
    function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
      if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
      }
      var i = 0;
      for (; i < aKeys.length; i++) {
        if (!hasOwnProperty(val2, aKeys[i])) {
          return false;
        }
      }
      if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
          var count = 0;
          for (i = 0; i < symbolKeysA.length; i++) {
            var key = symbolKeysA[i];
            if (propertyIsEnumerable(val1, key)) {
              if (!propertyIsEnumerable(val2, key)) {
                return false;
              }
              aKeys.push(key);
              count++;
            } else if (propertyIsEnumerable(val2, key)) {
              return false;
            }
          }
          var symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
            return false;
          }
        } else {
          var _symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
            return false;
          }
        }
      }
      if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
        return true;
      }
      if (memos === void 0) {
        memos = {
          val1: /* @__PURE__ */ new Map(),
          val2: /* @__PURE__ */ new Map(),
          position: 0
        };
      } else {
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== void 0) {
          var val2MemoB = memos.val2.get(val2);
          if (val2MemoB !== void 0) {
            return val2MemoA === val2MemoB;
          }
        }
        memos.position++;
      }
      memos.val1.set(val1, memos.position);
      memos.val2.set(val2, memos.position);
      var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
      memos.val1.delete(val1);
      memos.val2.delete(val2);
      return areEq;
    }
    function setHasEqualElement(set, val1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i = 0; i < setValues.length; i++) {
        var val2 = setValues[i];
        if (innerDeepEqual(val1, val2, strict, memo)) {
          set.delete(val2);
          return true;
        }
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      switch (_typeof(prim)) {
        case "undefined":
          return null;
        case "object":
          return void 0;
        case "symbol":
          return false;
        case "string":
          prim = +prim;
        case "number":
          if (numberIsNaN(prim)) {
            return false;
          }
      }
      return true;
    }
    function setMightHaveLoosePrim(a, b, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) return altValue;
      return b.has(altValue) && !a.has(altValue);
    }
    function mapMightHaveLoosePrim(a, b, prim, item, memo) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      var curB = b.get(altValue);
      if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
      }
      return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
    }
    function setEquiv(a, b, strict, memo) {
      var set = null;
      var aValues = arrayFromSet(a);
      for (var i = 0; i < aValues.length; i++) {
        var val = aValues[i];
        if (_typeof(val) === "object" && val !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        } else if (!b.has(val)) {
          if (strict) return false;
          if (!setMightHaveLoosePrim(a, b, val)) {
            return false;
          }
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        }
      }
      if (set !== null) {
        var bValues = arrayFromSet(b);
        for (var _i = 0; _i < bValues.length; _i++) {
          var _val = bValues[_i];
          if (_typeof(_val) === "object" && _val !== null) {
            if (!setHasEqualElement(set, _val, strict, memo)) return false;
          } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i = 0; i < setValues.length; i++) {
        var key2 = setValues[i];
        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
          set.delete(key2);
          return true;
        }
      }
      return false;
    }
    function mapEquiv(a, b, strict, memo) {
      var set = null;
      var aEntries = arrayFromMap(a);
      for (var i = 0; i < aEntries.length; i++) {
        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof(key) === "object" && key !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(key);
        } else {
          var item2 = b.get(key);
          if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
            if (strict) return false;
            if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key);
          }
        }
      }
      if (set !== null) {
        var bEntries = arrayFromMap(b);
        for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
          var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
          if (_typeof(_key) === "object" && _key !== null) {
            if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
          } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function objEquiv(a, b, strict, keys, memos, iterationType) {
      var i = 0;
      if (iterationType === kIsSet) {
        if (!setEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsMap) {
        if (!mapEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsArray) {
        for (; i < a.length; i++) {
          if (hasOwnProperty(a, i)) {
            if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
              return false;
            }
          } else if (hasOwnProperty(b, i)) {
            return false;
          } else {
            var keysA = Object.keys(a);
            for (; i < keysA.length; i++) {
              var key = keysA[i];
              if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                return false;
              }
            }
            if (keysA.length !== Object.keys(b).length) {
              return false;
            }
            return true;
          }
        }
      }
      for (i = 0; i < keys.length; i++) {
        var _key2 = keys[i];
        if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
          return false;
        }
      }
      return true;
    }
    function isDeepEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kLoose);
    }
    function isDeepStrictEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kStrict);
    }
    module.exports = {
      isDeepEqual,
      isDeepStrictEqual
    };
  }
});

// node_modules/assert/build/assert.js
var require_assert = __commonJS({
  "node_modules/assert/build/assert.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var _require = require_errors2();
    var _require$codes = _require.codes;
    var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
    var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var AssertionError = require_assertion_error();
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var _require$types = require_util().types;
    var isPromise = _require$types.isPromise;
    var isRegExp = _require$types.isRegExp;
    var objectAssign = require_polyfill()();
    var objectIs = require_polyfill2()();
    var RegExpPrototypeTest = require_callBound()("RegExp.prototype.test");
    var isDeepEqual;
    var isDeepStrictEqual;
    function lazyLoadComparison() {
      var comparison = require_comparisons();
      isDeepEqual = comparison.isDeepEqual;
      isDeepStrictEqual = comparison.isDeepStrictEqual;
    }
    var warned = false;
    var assert = module.exports = ok;
    var NO_EXCEPTION_SENTINEL = {};
    function innerFail(obj) {
      if (obj.message instanceof Error) throw obj.message;
      throw new AssertionError(obj);
    }
    function fail(actual, expected, message, operator, stackStartFn) {
      var argsLen = arguments.length;
      var internalMessage;
      if (argsLen === 0) {
        internalMessage = "Failed";
      } else if (argsLen === 1) {
        message = actual;
        actual = void 0;
      } else {
        if (warned === false) {
          warned = true;
          var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
          warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        if (argsLen === 2) operator = "!=";
      }
      if (message instanceof Error) throw message;
      var errArgs = {
        actual,
        expected,
        operator: operator === void 0 ? "fail" : operator,
        stackStartFn: stackStartFn || fail
      };
      if (message !== void 0) {
        errArgs.message = message;
      }
      var err = new AssertionError(errArgs);
      if (internalMessage) {
        err.message = internalMessage;
        err.generatedMessage = true;
      }
      throw err;
    }
    assert.fail = fail;
    assert.AssertionError = AssertionError;
    function innerOk(fn, argLen, value, message) {
      if (!value) {
        var generatedMessage = false;
        if (argLen === 0) {
          generatedMessage = true;
          message = "No value argument passed to `assert.ok()`";
        } else if (message instanceof Error) {
          throw message;
        }
        var err = new AssertionError({
          actual: value,
          expected: true,
          message,
          operator: "==",
          stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
      }
    }
    function ok() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      innerOk.apply(void 0, [ok, args.length].concat(args));
    }
    assert.ok = ok;
    assert.equal = function equal(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual != expected) {
        innerFail({
          actual,
          expected,
          message,
          operator: "==",
          stackStartFn: equal
        });
      }
    };
    assert.notEqual = function notEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual == expected) {
        innerFail({
          actual,
          expected,
          message,
          operator: "!=",
          stackStartFn: notEqual
        });
      }
    };
    assert.deepEqual = function deepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0) lazyLoadComparison();
      if (!isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "deepEqual",
          stackStartFn: deepEqual
        });
      }
    };
    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0) lazyLoadComparison();
      if (isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notDeepEqual",
          stackStartFn: notDeepEqual
        });
      }
    };
    assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0) lazyLoadComparison();
      if (!isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "deepStrictEqual",
          stackStartFn: deepStrictEqual
        });
      }
    };
    assert.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0) lazyLoadComparison();
      if (isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notDeepStrictEqual",
          stackStartFn: notDeepStrictEqual
        });
      }
    }
    assert.strictEqual = function strictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (!objectIs(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "strictEqual",
          stackStartFn: strictEqual
        });
      }
    };
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (objectIs(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notStrictEqual",
          stackStartFn: notStrictEqual
        });
      }
    };
    var Comparison = _createClass(function Comparison2(obj, keys, actual) {
      var _this = this;
      _classCallCheck(this, Comparison2);
      keys.forEach(function(key) {
        if (key in obj) {
          if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
            _this[key] = actual[key];
          } else {
            _this[key] = obj[key];
          }
        }
      });
    });
    function compareExceptionKey(actual, expected, key, message, keys, fn) {
      if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
        if (!message) {
          var a = new Comparison(actual, keys);
          var b = new Comparison(expected, keys, actual);
          var err = new AssertionError({
            actual: a,
            expected: b,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.actual = actual;
          err.expected = expected;
          err.operator = fn.name;
          throw err;
        }
        innerFail({
          actual,
          expected,
          message,
          operator: fn.name,
          stackStartFn: fn
        });
      }
    }
    function expectedException(actual, expected, msg, fn) {
      if (typeof expected !== "function") {
        if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
        if (arguments.length === 2) {
          throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
        }
        if (_typeof(actual) !== "object" || actual === null) {
          var err = new AssertionError({
            actual,
            expected,
            message: msg,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.operator = fn.name;
          throw err;
        }
        var keys = Object.keys(expected);
        if (expected instanceof Error) {
          keys.push("name", "message");
        } else if (keys.length === 0) {
          throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
        }
        if (isDeepEqual === void 0) lazyLoadComparison();
        keys.forEach(function(key) {
          if (typeof actual[key] === "string" && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
            return;
          }
          compareExceptionKey(actual, expected, key, msg, keys, fn);
        });
        return true;
      }
      if (expected.prototype !== void 0 && actual instanceof expected) {
        return true;
      }
      if (Error.isPrototypeOf(expected)) {
        return false;
      }
      return expected.call({}, actual) === true;
    }
    function getActual(fn) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
      }
      try {
        fn();
      } catch (e) {
        return e;
      }
      return NO_EXCEPTION_SENTINEL;
    }
    function checkIsPromise(obj) {
      return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
    }
    function waitForActual(promiseFn) {
      return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === "function") {
          resultPromise = promiseFn();
          if (!checkIsPromise(resultPromise)) {
            throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
          }
        } else if (checkIsPromise(promiseFn)) {
          resultPromise = promiseFn;
        } else {
          throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
        }
        return Promise.resolve().then(function() {
          return resultPromise;
        }).then(function() {
          return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
          return e;
        });
      });
    }
    function expectsError(stackStartFn, actual, error, message) {
      if (typeof error === "string") {
        if (arguments.length === 4) {
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
        }
        if (_typeof(actual) === "object" && actual !== null) {
          if (actual.message === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
          }
        } else if (actual === error) {
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
        }
        message = error;
        error = void 0;
      } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
      }
      if (actual === NO_EXCEPTION_SENTINEL) {
        var details = "";
        if (error && error.name) {
          details += " (".concat(error.name, ")");
        }
        details += message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
        innerFail({
          actual: void 0,
          expected: error,
          operator: stackStartFn.name,
          message: "Missing expected ".concat(fnType).concat(details),
          stackStartFn
        });
      }
      if (error && !expectedException(actual, error, message, stackStartFn)) {
        throw actual;
      }
    }
    function expectsNoError(stackStartFn, actual, error, message) {
      if (actual === NO_EXCEPTION_SENTINEL) return;
      if (typeof error === "string") {
        message = error;
        error = void 0;
      }
      if (!error || expectedException(actual, error)) {
        var details = message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
        innerFail({
          actual,
          expected: error,
          operator: stackStartFn.name,
          message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
          stackStartFn
        });
      }
      throw actual;
    }
    assert.throws = function throws(promiseFn) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
    };
    assert.rejects = function rejects(promiseFn) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(void 0, [rejects, result].concat(args));
      });
    };
    assert.doesNotThrow = function doesNotThrow(fn) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
    };
    assert.doesNotReject = function doesNotReject(fn) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }
      return waitForActual(fn).then(function(result) {
        return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
      });
    };
    assert.ifError = function ifError(err) {
      if (err !== null && err !== void 0) {
        var message = "ifError got unwanted exception: ";
        if (_typeof(err) === "object" && typeof err.message === "string") {
          if (err.message.length === 0 && err.constructor) {
            message += err.constructor.name;
          } else {
            message += err.message;
          }
        } else {
          message += inspect(err);
        }
        var newErr = new AssertionError({
          actual: err,
          expected: null,
          operator: "ifError",
          message,
          stackStartFn: ifError
        });
        var origStack = err.stack;
        if (typeof origStack === "string") {
          var tmp2 = origStack.split("\n");
          tmp2.shift();
          var tmp1 = newErr.stack.split("\n");
          for (var i = 0; i < tmp2.length; i++) {
            var pos = tmp1.indexOf(tmp2[i]);
            if (pos !== -1) {
              tmp1 = tmp1.slice(0, pos);
              break;
            }
          }
          newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
        }
        throw newErr;
      }
    };
    function internalMatch(string, regexp, message, fn, fnName) {
      if (!isRegExp(regexp)) {
        throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
      }
      var match = fnName === "match";
      if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
        if (message instanceof Error) {
          throw message;
        }
        var generatedMessage = !message;
        message = message || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
        var err = new AssertionError({
          actual: string,
          expected: regexp,
          message,
          operator: fnName,
          stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
      }
    }
    assert.match = function match(string, regexp, message) {
      internalMatch(string, regexp, message, match, "match");
    };
    assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
      internalMatch(string, regexp, message, doesNotMatch, "doesNotMatch");
    };
    function strict() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      innerOk.apply(void 0, [strict, args.length].concat(args));
    }
    assert.strict = objectAssign(strict, assert, {
      equal: assert.strictEqual,
      deepEqual: assert.deepStrictEqual,
      notEqual: assert.notStrictEqual,
      notDeepEqual: assert.notDeepStrictEqual
    });
    assert.strict.strict = assert.strict;
  }
});

// node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "node_modules/punycode/punycode.js"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode2 = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode2;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode2;
        } else {
          for (key in punycode2) {
            punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
          }
        }
      } else {
        root.punycode = punycode2;
      }
    })(exports);
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util2 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util2();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function canTrustToString(obj) {
      return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS({
  "node_modules/side-channel-list/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var listGetNode = function(list, key, isDelete) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) != null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          if (!isDelete) {
            curr.next = /** @type {NonNullable<typeof list.next>} */
            list.next;
            list.next = curr;
          }
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      if (!objects) {
        return void 0;
      }
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      if (!objects) {
        return false;
      }
      return !!listGetNode(objects, key);
    };
    var listDelete = function(objects, key) {
      if (objects) {
        return listGetNode(objects, key, true);
      }
    };
    module.exports = function getSideChannelList() {
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          var root = $o && $o.next;
          var deletedNode = listDelete($o, key);
          if (deletedNode && root && root === deletedNode) {
            $o = void 0;
          }
          return !!deletedNode;
        },
        get: function(key) {
          return listGet($o, key);
        },
        has: function(key) {
          return listHas($o, key);
        },
        set: function(key, value) {
          if (!$o) {
            $o = {
              next: void 0
            };
          }
          listSet(
            /** @type {NonNullable<typeof $o>} */
            $o,
            key,
            value
          );
        }
      };
      return channel;
    };
  }
});

// node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS({
  "node_modules/side-channel-map/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapDelete = callBound("Map.prototype.delete", true);
    var $mapSize = callBound("Map.prototype.size", true);
    module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */
    function getSideChannelMap() {
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          if ($m) {
            var result = $mapDelete($m, key);
            if ($mapSize($m) === 0) {
              $m = void 0;
            }
            return result;
          }
          return false;
        },
        get: function(key) {
          if ($m) {
            return $mapGet($m, key);
          }
        },
        has: function(key) {
          if ($m) {
            return $mapHas($m, key);
          }
          return false;
        },
        set: function(key, value) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        }
      };
      return channel;
    };
  }
});

// node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS({
  "node_modules/side-channel-weakmap/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var getSideChannelMap = require_side_channel_map();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
    module.exports = $WeakMap ? (
      /** @type {Exclude<import('.'), false>} */
      function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
          assert: function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          "delete": function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapDelete($wm, key);
              }
            } else if (getSideChannelMap) {
              if ($m) {
                return $m["delete"](key);
              }
            }
            return false;
          },
          get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            }
            return $m && $m.get(key);
          },
          has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            }
            return !!$m && $m.has(key);
          },
          set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
              if (!$m) {
                $m = getSideChannelMap();
              }
              $m.set(key, value);
            }
          }
        };
        return channel;
      }
    ) : getSideChannelMap;
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var getSideChannelList = require_side_channel_list();
    var getSideChannelMap = require_side_channel_map();
    var getSideChannelWeakMap = require_side_channel_weakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    module.exports = function getSideChannel() {
      var $channelData;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          return !!$channelData && $channelData["delete"](key);
        },
        get: function(key) {
          return $channelData && $channelData.get(key);
        },
        has: function(key) {
          return !!$channelData && $channelData.has(key);
        },
        set: function(key, value) {
          if (!$channelData) {
            $channelData = makeChannel();
          }
          $channelData.set(key, value);
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? { __proto__: null } : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object" && typeof source !== "function") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter2 === "function") {
        obj = filter2(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format2) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format2);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format2))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter2)) {
        objKeys = filter2;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter2,
          sort,
          allowDots,
          serializeDate,
          format2,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format2 = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format2 = opts.format;
      }
      var formatter = formats.formatters[format2];
      var filter2 = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter2 = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter2,
        format: format2,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter2;
      if (typeof options.filter === "function") {
        filter2 = options.filter;
        obj = filter2("", obj);
      } else if (isArray(options.filter)) {
        filter2 = options.filter;
        objKeys = filter2;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];
        if (options.skipNulls && value === null) {
          continue;
        }
        pushToArray(keys, stringify(
          value,
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false,
      throwOnLimitExceeded: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options, currentArrayLength) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(
        options.delimiter,
        options.throwOnLimitExceeded ? limit + 1 : limit
      );
      if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
      }
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(
              part.slice(pos + 1),
              options,
              isArray(obj[key]) ? obj[key].length : 0
            ),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var currentArrayLength = 0;
      if (chain.length > 0 && chain[chain.length - 1] === "[]") {
        var parentKey = chain.slice(0, -1).join("");
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
      }
      var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
        } else {
          obj = options.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
        throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? { __proto__: null } : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var stringify = require_stringify();
    var parse2 = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse: parse2,
      stringify
    };
  }
});

// node_modules/node-stdlib-browser/esm/proxy/url.js
var url_exports = {};
__export(url_exports, {
  URL: () => URL,
  URLSearchParams: () => URLSearchParams,
  Url: () => UrlImport,
  default: () => api,
  domainToASCII: () => domainToASCII,
  domainToUnicode: () => domainToUnicode,
  fileURLToPath: () => fileURLToPath,
  format: () => formatImportWithOverloads,
  parse: () => parseImport,
  pathToFileURL: () => pathToFileURL,
  resolve: () => resolveImport,
  resolveObject: () => resolveObject
});
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === "object" && url instanceof Url) {
    return url;
  }
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}
function urlFormat(obj) {
  if (typeof obj === "string") {
    obj = urlParse(obj);
  }
  if (!(obj instanceof Url)) {
    return Url.prototype.format.call(obj);
  }
  return obj.format();
}
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
function urlResolveObject(source, relative) {
  if (!source) {
    return relative;
  }
  return urlParse(source, false, true).resolveObject(relative);
}
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === ".") {
      parts.splice(i, 1);
    } else if (last === "..") {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : "/";
    if (typeof path !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
    return !!p;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
}
function isURLInstance(instance) {
  var resolved = (
    /** @type {URL|null} */
    instance != null ? instance : null
  );
  return Boolean(resolved !== null && (resolved == null ? void 0 : resolved.href) && (resolved == null ? void 0 : resolved.origin));
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  }
  var pathname = url.pathname;
  for (var n = 0; n < pathname.length; n++) {
    if (pathname[n] === "%") {
      var third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        throw new TypeError("File URL path must not include encoded / characters");
      }
    }
  }
  return decodeURIComponent(pathname);
}
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes("\n")) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("	")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
var import_dist, import_dist2, import_dist3, import_punycode, import_qs, punycode, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol, querystring, parse, resolve$1, resolveObject, format, Url_1, _globalThis, formatImport, parseImport, resolveImport, UrlImport, URL, URLSearchParams, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx, CHAR_FORWARD_SLASH, domainToASCII, domainToUnicode, pathToFileURL, fileURLToPath, formatImportWithOverloads, api;
var init_url = __esm({
  "node_modules/node-stdlib-browser/esm/proxy/url.js"() {
    import_dist = __toESM(require_dist());
    import_dist2 = __toESM(require_dist2());
    import_dist3 = __toESM(require_dist3());
    import_punycode = __toESM(require_punycode());
    import_qs = __toESM(require_lib());
    punycode = import_punycode.default;
    protocolPattern = /^([a-z0-9.+-]+:)/i;
    portPattern = /:[0-9]*$/;
    simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
    delims = [
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      "\n",
      "	"
    ];
    unwise = [
      "{",
      "}",
      "|",
      "\\",
      "^",
      "`"
    ].concat(delims);
    autoEscape = ["'"].concat(unwise);
    nonHostChars = [
      "%",
      "/",
      "?",
      ";",
      "#"
    ].concat(autoEscape);
    hostEndingChars = [
      "/",
      "?",
      "#"
    ];
    hostnameMaxLen = 255;
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    unsafeProtocol = {
      javascript: true,
      "javascript:": true
    };
    hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    querystring = import_qs.default;
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (typeof url !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1) {
            continue;
          }
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
      }
      this.href = this.format();
      return this;
    };
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
        query = querystring.stringify(this.query, {
          arrayFormat: "repeat",
          addQueryPrefix: false
        });
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":") {
        protocol += ":";
      }
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") {
          pathname = "/" + pathname;
        }
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#") {
        hash = "#" + hash;
      }
      if (search && search.charAt(0) !== "?") {
        search = "?" + search;
      }
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    Url.prototype.resolveObject = function(relative) {
      if (typeof relative === "string") {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol") {
            result[rkey] = relative[rkey];
          }
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.pathname = "/";
          result.path = result.pathname;
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift())) {
          }
          if (!relative.host) {
            relative.host = "";
          }
          if (!relative.hostname) {
            relative.hostname = "";
          }
          if (relPath[0] !== "") {
            relPath.unshift("");
          }
          if (relPath.length < 2) {
            relPath.unshift("");
          }
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "") {
            srcPath[0] = result.host;
          } else {
            srcPath.unshift(result.host);
          }
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "") {
              relPath[0] = relative.host;
            } else {
              relPath.unshift(relative.host);
            }
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath) {
          srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (relative.search != null) {
        if (psychotic) {
          result.host = srcPath.shift();
          result.hostname = result.host;
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.hostname = authInHost.shift();
            result.host = result.hostname;
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (result.pathname !== null || result.search !== null) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
          srcPath.splice(i, 1);
        } else if (last === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        result.host = result.hostname;
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.hostname = authInHost.shift();
          result.host = result.hostname;
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (srcPath.length > 0) {
        result.pathname = srcPath.join("/");
      } else {
        result.pathname = null;
        result.path = null;
      }
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    parse = urlParse;
    resolve$1 = urlResolve;
    resolveObject = urlResolveObject;
    format = urlFormat;
    Url_1 = Url;
    _globalThis = function(Object2) {
      function get() {
        var _global2 = this || self;
        delete Object2.prototype.__magic__;
        return _global2;
      }
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (this) {
        return get();
      } else {
        Object2.defineProperty(Object2.prototype, "__magic__", {
          configurable: true,
          get
        });
        var _global = __magic__;
        return _global;
      }
    }(Object);
    formatImport = /** @type {formatImport}*/
    format;
    parseImport = /** @type {parseImport}*/
    parse;
    resolveImport = /** @type {resolveImport}*/
    resolve$1;
    UrlImport = /** @type {UrlImport}*/
    Url_1;
    URL = _globalThis.URL;
    URLSearchParams = _globalThis.URLSearchParams;
    percentRegEx = /%/g;
    backslashRegEx = /\\/g;
    newlineRegEx = /\n/g;
    carriageReturnRegEx = /\r/g;
    tabRegEx = /\t/g;
    CHAR_FORWARD_SLASH = 47;
    domainToASCII = /**
     * @type {domainToASCII}
     */
    function domainToASCII2(domain) {
      if (typeof domain === "undefined") {
        throw new TypeError('The "domain" argument must be specified');
      }
      return new URL("http://" + domain).hostname;
    };
    domainToUnicode = /**
     * @type {domainToUnicode}
     */
    function domainToUnicode2(domain) {
      if (typeof domain === "undefined") {
        throw new TypeError('The "domain" argument must be specified');
      }
      return new URL("http://" + domain).hostname;
    };
    pathToFileURL = /**
     * @type {(url: string) => URL}
     */
    function pathToFileURL2(filepath) {
      var outURL = new URL("file://");
      var resolved = resolve(filepath);
      var filePathLast = filepath.charCodeAt(filepath.length - 1);
      if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
        resolved += "/";
      }
      outURL.pathname = encodePathChars(resolved);
      return outURL;
    };
    fileURLToPath = /**
     * @type {fileURLToPath & ((path: string | URL) => string)}
     */
    function fileURLToPath2(path) {
      if (!isURLInstance(path) && typeof path !== "string") {
        throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof path + " (" + path + ")");
      }
      var resolved = new URL(path);
      if (resolved.protocol !== "file:") {
        throw new TypeError("The URL must be of scheme file");
      }
      return getPathFromURLPosix(resolved);
    };
    formatImportWithOverloads = /**
     * @type {(
     *   ((urlObject: URL, options?: URLFormatOptions) => string) &
     *   ((urlObject: UrlObject | string, options?: never) => string)
     * )}
     */
    function formatImportWithOverloads2(urlObject, options) {
      var _options$auth, _options$fragment, _options$search, _options$unicode;
      if (options === void 0) {
        options = {};
      }
      if (!(urlObject instanceof URL)) {
        return formatImport(urlObject);
      }
      if (typeof options !== "object" || options === null) {
        throw new TypeError('The "options" argument must be of type object.');
      }
      var auth = (_options$auth = options.auth) != null ? _options$auth : true;
      var fragment = (_options$fragment = options.fragment) != null ? _options$fragment : true;
      var search = (_options$search = options.search) != null ? _options$search : true;
      (_options$unicode = options.unicode) != null ? _options$unicode : false;
      var parsed = new URL(urlObject.toString());
      if (!auth) {
        parsed.username = "";
        parsed.password = "";
      }
      if (!fragment) {
        parsed.hash = "";
      }
      if (!search) {
        parsed.search = "";
      }
      return parsed.toString();
    };
    api = {
      format: formatImportWithOverloads,
      parse: parseImport,
      resolve: resolveImport,
      resolveObject,
      Url: UrlImport,
      URL,
      URLSearchParams,
      domainToASCII,
      domainToUnicode,
      pathToFileURL,
      fileURLToPath
    };
  }
});

// node_modules/jsonschema/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/jsonschema/lib/helpers.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var uri = (init_url(), __toCommonJS(url_exports));
    var ValidationError = exports.ValidationError = function ValidationError2(message, instance, schema, propertyPath, name, argument) {
      if (propertyPath) {
        this.property = propertyPath;
      }
      if (message) {
        this.message = message;
      }
      if (schema) {
        if (schema.id) {
          this.schema = schema.id;
        } else {
          this.schema = schema;
        }
      }
      if (instance) {
        this.instance = instance;
      }
      this.name = name;
      this.argument = argument;
      this.stack = this.toString();
    };
    ValidationError.prototype.toString = function toString() {
      return this.property + " " + this.message;
    };
    var ValidatorResult = exports.ValidatorResult = function ValidatorResult2(instance, schema, options, ctx) {
      this.instance = instance;
      this.schema = schema;
      this.propertyPath = ctx.propertyPath;
      this.errors = [];
      this.throwError = options && options.throwError;
      this.disableFormat = options && options.disableFormat === true;
    };
    ValidatorResult.prototype.addError = function addError(detail) {
      var err;
      if (typeof detail == "string") {
        err = new ValidationError(detail, this.instance, this.schema, this.propertyPath);
      } else {
        if (!detail) throw new Error("Missing error detail");
        if (!detail.message) throw new Error("Missing error message");
        if (!detail.name) throw new Error("Missing validator type");
        err = new ValidationError(detail.message, this.instance, this.schema, this.propertyPath, detail.name, detail.argument);
      }
      if (this.throwError) {
        throw err;
      }
      this.errors.push(err);
      return err;
    };
    ValidatorResult.prototype.importErrors = function importErrors(res) {
      if (typeof res == "string" || res && res.validatorType) {
        this.addError(res);
      } else if (res && res.errors) {
        Array.prototype.push.apply(this.errors, res.errors);
      }
    };
    function stringizer(v, i) {
      return i + ": " + v.toString() + "\n";
    }
    ValidatorResult.prototype.toString = function toString(res) {
      return this.errors.map(stringizer).join("");
    };
    Object.defineProperty(ValidatorResult.prototype, "valid", { get: function() {
      return !this.errors.length;
    } });
    var SchemaError = exports.SchemaError = function SchemaError2(msg, schema) {
      this.message = msg;
      this.schema = schema;
      Error.call(this, msg);
      Error.captureStackTrace(this, SchemaError2);
    };
    SchemaError.prototype = Object.create(
      Error.prototype,
      {
        constructor: { value: SchemaError, enumerable: false },
        name: { value: "SchemaError", enumerable: false }
      }
    );
    var SchemaContext = exports.SchemaContext = function SchemaContext2(schema, options, propertyPath, base, schemas) {
      this.schema = schema;
      this.options = options;
      this.propertyPath = propertyPath;
      this.base = base;
      this.schemas = schemas;
    };
    SchemaContext.prototype.resolve = function resolve2(target) {
      return uri.resolve(this.base, target);
    };
    SchemaContext.prototype.makeChild = function makeChild(schema, propertyName) {
      var propertyPath = propertyName === void 0 ? this.propertyPath : this.propertyPath + makeSuffix(propertyName);
      var base = uri.resolve(this.base, schema.id || "");
      var ctx = new SchemaContext(schema, this.options, propertyPath, base, Object.create(this.schemas));
      if (schema.id && !ctx.schemas[base]) {
        ctx.schemas[base] = schema;
      }
      return ctx;
    };
    var FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {
      "date-time": /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\.\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,
      "date": /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,
      "time": /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,
      "email": /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
      "ip-address": /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
      "ipv6": /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
      "uri": /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/,
      "color": /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,
      // hostname regex from: http://stackoverflow.com/a/1420225/5628
      "hostname": /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
      "host-name": /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
      "alpha": /^[a-zA-Z]+$/,
      "alphanumeric": /^[a-zA-Z0-9]+$/,
      "utc-millisec": function(input) {
        return typeof input === "string" && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
      },
      "regex": function(input) {
        var result = true;
        try {
          new RegExp(input);
        } catch (e) {
          result = false;
        }
        return result;
      },
      "style": /\s*(.+?):\s*([^;]+);?/g,
      "phone": /^\+(?:[0-9] ?){6,14}[0-9]$/
    };
    FORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;
    FORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;
    FORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS["ip-address"];
    exports.isFormat = function isFormat(input, format2, validator) {
      if (typeof input === "string" && FORMAT_REGEXPS[format2] !== void 0) {
        if (FORMAT_REGEXPS[format2] instanceof RegExp) {
          return FORMAT_REGEXPS[format2].test(input);
        }
        if (typeof FORMAT_REGEXPS[format2] === "function") {
          return FORMAT_REGEXPS[format2](input);
        }
      } else if (validator && validator.customFormats && typeof validator.customFormats[format2] === "function") {
        return validator.customFormats[format2](input);
      }
      return true;
    };
    var makeSuffix = exports.makeSuffix = function makeSuffix2(key) {
      key = key.toString();
      if (!key.match(/[.\s\[\]]/) && !key.match(/^[\d]/)) {
        return "." + key;
      }
      if (key.match(/^\d+$/)) {
        return "[" + key + "]";
      }
      return "[" + JSON.stringify(key) + "]";
    };
    exports.deepCompareStrict = function deepCompareStrict(a, b) {
      if (typeof a !== typeof b) {
        return false;
      }
      if (a instanceof Array) {
        if (!(b instanceof Array)) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        return a.every(function(v, i) {
          return deepCompareStrict(a[i], b[i]);
        });
      }
      if (typeof a === "object") {
        if (!a || !b) {
          return a === b;
        }
        var aKeys = Object.keys(a);
        var bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        return aKeys.every(function(v) {
          return deepCompareStrict(a[v], b[v]);
        });
      }
      return a === b;
    };
    function deepMerger(target, dst, e, i) {
      if (typeof e === "object") {
        dst[i] = deepMerge(target[i], e);
      } else {
        if (target.indexOf(e) === -1) {
          dst.push(e);
        }
      }
    }
    function copyist(src, dst, key) {
      dst[key] = src[key];
    }
    function copyistWithDeepMerge(target, src, dst, key) {
      if (typeof src[key] !== "object" || !src[key]) {
        dst[key] = src[key];
      } else {
        if (!target[key]) {
          dst[key] = src[key];
        } else {
          dst[key] = deepMerge(target[key], src[key]);
        }
      }
    }
    function deepMerge(target, src) {
      var array = Array.isArray(src);
      var dst = array && [] || {};
      if (array) {
        target = target || [];
        dst = dst.concat(target);
        src.forEach(deepMerger.bind(null, target, dst));
      } else {
        if (target && typeof target === "object") {
          Object.keys(target).forEach(copyist.bind(null, target, dst));
        }
        Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));
      }
      return dst;
    }
    module.exports.deepMerge = deepMerge;
    exports.objectGetPath = function objectGetPath(o, s) {
      var parts = s.split("/").slice(1);
      var k;
      while (typeof (k = parts.shift()) == "string") {
        var n = decodeURIComponent(k.replace(/~0/, "~").replace(/~1/g, "/"));
        if (!(n in o)) return;
        o = o[n];
      }
      return o;
    };
    function pathEncoder(v) {
      return "/" + encodeURIComponent(v).replace(/~/g, "%7E");
    }
    exports.encodePath = function encodePointer(a) {
      return a.map(pathEncoder).join("");
    };
    exports.getDecimalPlaces = function getDecimalPlaces(number) {
      var decimalPlaces = 0;
      if (isNaN(number)) return decimalPlaces;
      if (typeof number !== "number") {
        number = Number(number);
      }
      var parts = number.toString().split("e");
      if (parts.length === 2) {
        if (parts[1][0] !== "-") {
          return decimalPlaces;
        } else {
          decimalPlaces = Number(parts[1].slice(1));
        }
      }
      var decimalParts = parts[0].split(".");
      if (decimalParts.length === 2) {
        decimalPlaces += decimalParts[1].length;
      }
      return decimalPlaces;
    };
  }
});

// node_modules/jsonschema/lib/attribute.js
var require_attribute = __commonJS({
  "node_modules/jsonschema/lib/attribute.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var helpers = require_helpers();
    var ValidatorResult = helpers.ValidatorResult;
    var SchemaError = helpers.SchemaError;
    var attribute = {};
    attribute.ignoreProperties = {
      // informative properties
      "id": true,
      "default": true,
      "description": true,
      "title": true,
      // arguments to other properties
      "exclusiveMinimum": true,
      "exclusiveMaximum": true,
      "additionalItems": true,
      // special-handled properties
      "$schema": true,
      "$ref": true,
      "extends": true
    };
    var validators = attribute.validators = {};
    validators.type = function validateType(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var types = Array.isArray(schema.type) ? schema.type : [schema.type];
      if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {
        var list = types.map(function(v) {
          return v.id && "<" + v.id + ">" || v + "";
        });
        result.addError({
          name: "type",
          argument: list,
          message: "is not of a type(s) " + list
        });
      }
      return result;
    };
    function testSchema(instance, options, ctx, callback, schema) {
      var res = this.validateSchema(instance, schema, options, ctx);
      if (!res.valid && callback instanceof Function) {
        callback(res);
      }
      return res.valid;
    }
    validators.anyOf = function validateAnyOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var inner = new ValidatorResult(instance, schema, options, ctx);
      if (!Array.isArray(schema.anyOf)) {
        throw new SchemaError("anyOf must be an array");
      }
      if (!schema.anyOf.some(
        testSchema.bind(
          this,
          instance,
          options,
          ctx,
          function(res) {
            inner.importErrors(res);
          }
        )
      )) {
        var list = schema.anyOf.map(function(v, i) {
          return v.id && "<" + v.id + ">" || v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
        });
        if (options.nestedErrors) {
          result.importErrors(inner);
        }
        result.addError({
          name: "anyOf",
          argument: list,
          message: "is not any of " + list.join(",")
        });
      }
      return result;
    };
    validators.allOf = function validateAllOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema.allOf)) {
        throw new SchemaError("allOf must be an array");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var self2 = this;
      schema.allOf.forEach(function(v, i) {
        var valid = self2.validateSchema(instance, v, options, ctx);
        if (!valid.valid) {
          var msg = v.id && "<" + v.id + ">" || v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
          result.addError({
            name: "allOf",
            argument: { id: msg, length: valid.errors.length, valid },
            message: "does not match allOf schema " + msg + " with " + valid.errors.length + " error[s]:"
          });
          result.importErrors(valid);
        }
      });
      return result;
    };
    validators.oneOf = function validateOneOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema.oneOf)) {
        throw new SchemaError("oneOf must be an array");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var inner = new ValidatorResult(instance, schema, options, ctx);
      var count = schema.oneOf.filter(
        testSchema.bind(
          this,
          instance,
          options,
          ctx,
          function(res) {
            inner.importErrors(res);
          }
        )
      ).length;
      var list = schema.oneOf.map(function(v, i) {
        return v.id && "<" + v.id + ">" || v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
      });
      if (count !== 1) {
        if (options.nestedErrors) {
          result.importErrors(inner);
        }
        result.addError({
          name: "oneOf",
          argument: list,
          message: "is not exactly one from " + list.join(",")
        });
      }
      return result;
    };
    validators.properties = function validateProperties(instance, schema, options, ctx) {
      if (instance === void 0 || !(instance instanceof Object)) return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var properties = schema.properties || {};
      for (var property in properties) {
        if (typeof options.preValidateProperty == "function") {
          options.preValidateProperty(instance, property, properties[property], options, ctx);
        }
        var prop = (instance || void 0) && instance[property];
        var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));
        if (res.instance !== result.instance[property]) result.instance[property] = res.instance;
        result.importErrors(res);
      }
      return result;
    };
    function testAdditionalProperty(instance, schema, options, ctx, property, result) {
      if (schema.properties && schema.properties[property] !== void 0) {
        return;
      }
      if (schema.additionalProperties === false) {
        result.addError({
          name: "additionalProperties",
          argument: property,
          message: "additionalProperty " + JSON.stringify(property) + " exists in instance when not allowed"
        });
      } else {
        var additionalProperties = schema.additionalProperties || {};
        if (typeof options.preValidateProperty == "function") {
          options.preValidateProperty(instance, property, additionalProperties, options, ctx);
        }
        var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));
        if (res.instance !== result.instance[property]) result.instance[property] = res.instance;
        result.importErrors(res);
      }
    }
    validators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {
      if (instance === void 0) return;
      if (!this.types.object(instance)) return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var patternProperties = schema.patternProperties || {};
      for (var property in instance) {
        var test = true;
        for (var pattern in patternProperties) {
          var expr = new RegExp(pattern);
          if (!expr.test(property)) {
            continue;
          }
          test = false;
          if (typeof options.preValidateProperty == "function") {
            options.preValidateProperty(instance, property, patternProperties[pattern], options, ctx);
          }
          var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));
          if (res.instance !== result.instance[property]) result.instance[property] = res.instance;
          result.importErrors(res);
        }
        if (test) {
          testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
        }
      }
      return result;
    };
    validators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {
      if (instance === void 0) return;
      if (!this.types.object(instance)) return;
      if (schema.patternProperties) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      for (var property in instance) {
        testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
      }
      return result;
    };
    validators.minProperties = function validateMinProperties(instance, schema, options, ctx) {
      if (!instance || typeof instance !== "object") {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var keys = Object.keys(instance);
      if (!(keys.length >= schema.minProperties)) {
        result.addError({
          name: "minProperties",
          argument: schema.minProperties,
          message: "does not meet minimum property length of " + schema.minProperties
        });
      }
      return result;
    };
    validators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {
      if (!instance || typeof instance !== "object") {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var keys = Object.keys(instance);
      if (!(keys.length <= schema.maxProperties)) {
        result.addError({
          name: "maxProperties",
          argument: schema.maxProperties,
          message: "does not meet maximum property length of " + schema.maxProperties
        });
      }
      return result;
    };
    validators.items = function validateItems(instance, schema, options, ctx) {
      if (!Array.isArray(instance)) {
        return null;
      }
      var self2 = this;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (instance === void 0 || !schema.items) {
        return result;
      }
      instance.every(function(value, i) {
        var items = Array.isArray(schema.items) ? schema.items[i] || schema.additionalItems : schema.items;
        if (items === void 0) {
          return true;
        }
        if (items === false) {
          result.addError({
            name: "items",
            message: "additionalItems not permitted"
          });
          return false;
        }
        var res = self2.validateSchema(value, items, options, ctx.makeChild(items, i));
        if (res.instance !== result.instance[i]) result.instance[i] = res.instance;
        result.importErrors(res);
        return true;
      });
      return result;
    };
    validators.minimum = function validateMinimum(instance, schema, options, ctx) {
      if (typeof instance !== "number") {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var valid = true;
      if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {
        valid = instance > schema.minimum;
      } else {
        valid = instance >= schema.minimum;
      }
      if (!valid) {
        result.addError({
          name: "minimum",
          argument: schema.minimum,
          message: "must have a minimum value of " + schema.minimum
        });
      }
      return result;
    };
    validators.maximum = function validateMaximum(instance, schema, options, ctx) {
      if (typeof instance !== "number") {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var valid;
      if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {
        valid = instance < schema.maximum;
      } else {
        valid = instance <= schema.maximum;
      }
      if (!valid) {
        result.addError({
          name: "maximum",
          argument: schema.maximum,
          message: "must have a maximum value of " + schema.maximum
        });
      }
      return result;
    };
    var validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy2(instance, schema, options, ctx, validationType, errorMessage) {
      if (typeof instance !== "number") {
        return null;
      }
      var validationArgument = schema[validationType];
      if (validationArgument == 0) {
        throw new SchemaError(validationType + " cannot be zero");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var instanceDecimals = helpers.getDecimalPlaces(instance);
      var divisorDecimals = helpers.getDecimalPlaces(validationArgument);
      var maxDecimals = Math.max(instanceDecimals, divisorDecimals);
      var multiplier = Math.pow(10, maxDecimals);
      if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {
        result.addError({
          name: validationType,
          argument: validationArgument,
          message: errorMessage + JSON.stringify(validationArgument)
        });
      }
      return result;
    };
    validators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {
      return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, "multipleOf", "is not a multiple of (divisible by) ");
    };
    validators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {
      return validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, "divisibleBy", "is not divisible by (multiple of) ");
    };
    validators.required = function validateRequired(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (instance === void 0 && schema.required === true) {
        result.addError({
          name: "required",
          message: "is required"
        });
      } else if (instance && typeof instance === "object" && Array.isArray(schema.required)) {
        schema.required.forEach(function(n) {
          if (instance[n] === void 0) {
            result.addError({
              name: "required",
              argument: n,
              message: "requires property " + JSON.stringify(n)
            });
          }
        });
      }
      return result;
    };
    validators.pattern = function validatePattern(instance, schema, options, ctx) {
      if (typeof instance !== "string") {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!instance.match(schema.pattern)) {
        result.addError({
          name: "pattern",
          argument: schema.pattern,
          message: "does not match pattern " + JSON.stringify(schema.pattern)
        });
      }
      return result;
    };
    validators.format = function validateFormat(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {
        result.addError({
          name: "format",
          argument: schema.format,
          message: "does not conform to the " + JSON.stringify(schema.format) + " format"
        });
      }
      return result;
    };
    validators.minLength = function validateMinLength(instance, schema, options, ctx) {
      if (!(typeof instance === "string")) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!(instance.length >= schema.minLength)) {
        result.addError({
          name: "minLength",
          argument: schema.minLength,
          message: "does not meet minimum length of " + schema.minLength
        });
      }
      return result;
    };
    validators.maxLength = function validateMaxLength(instance, schema, options, ctx) {
      if (!(typeof instance === "string")) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!(instance.length <= schema.maxLength)) {
        result.addError({
          name: "maxLength",
          argument: schema.maxLength,
          message: "does not meet maximum length of " + schema.maxLength
        });
      }
      return result;
    };
    validators.minItems = function validateMinItems(instance, schema, options, ctx) {
      if (!Array.isArray(instance)) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!(instance.length >= schema.minItems)) {
        result.addError({
          name: "minItems",
          argument: schema.minItems,
          message: "does not meet minimum length of " + schema.minItems
        });
      }
      return result;
    };
    validators.maxItems = function validateMaxItems(instance, schema, options, ctx) {
      if (!Array.isArray(instance)) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!(instance.length <= schema.maxItems)) {
        result.addError({
          name: "maxItems",
          argument: schema.maxItems,
          message: "does not meet maximum length of " + schema.maxItems
        });
      }
      return result;
    };
    validators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!Array.isArray(instance)) {
        return result;
      }
      function testArrays2(v, i, a) {
        for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {
          return false;
        }
        return true;
      }
      if (!instance.every(testArrays2)) {
        result.addError({
          name: "uniqueItems",
          message: "contains duplicate item"
        });
      }
      return result;
    };
    function testArrays(v, i, a) {
      var j, len = a.length;
      for (j = i + 1, len; j < len; j++) {
        if (helpers.deepCompareStrict(v, a[j])) {
          return false;
        }
      }
      return true;
    }
    validators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {
      if (!Array.isArray(instance)) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!instance.every(testArrays)) {
        result.addError({
          name: "uniqueItems",
          message: "contains duplicate item"
        });
      }
      return result;
    };
    validators.dependencies = function validateDependencies(instance, schema, options, ctx) {
      if (!instance || typeof instance != "object") {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      for (var property in schema.dependencies) {
        if (instance[property] === void 0) {
          continue;
        }
        var dep = schema.dependencies[property];
        var childContext = ctx.makeChild(dep, property);
        if (typeof dep == "string") {
          dep = [dep];
        }
        if (Array.isArray(dep)) {
          dep.forEach(function(prop) {
            if (instance[prop] === void 0) {
              result.addError({
                // FIXME there's two different "dependencies" errors here with slightly different outputs
                // Can we make these the same? Or should we create different error types?
                name: "dependencies",
                argument: childContext.propertyPath,
                message: "property " + prop + " not found, required by " + childContext.propertyPath
              });
            }
          });
        } else {
          var res = this.validateSchema(instance, dep, options, childContext);
          if (result.instance !== res.instance) result.instance = res.instance;
          if (res && res.errors.length) {
            result.addError({
              name: "dependencies",
              argument: childContext.propertyPath,
              message: "does not meet dependency required by " + childContext.propertyPath
            });
            result.importErrors(res);
          }
        }
      }
      return result;
    };
    validators["enum"] = function validateEnum(instance, schema, options, ctx) {
      if (!Array.isArray(schema["enum"])) {
        throw new SchemaError("enum expects an array", schema);
      }
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!schema["enum"].some(helpers.deepCompareStrict.bind(null, instance))) {
        result.addError({
          name: "enum",
          argument: schema["enum"],
          message: "is not one of enum values: " + schema["enum"].join(",")
        });
      }
      return result;
    };
    validators["const"] = function validateEnum(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!helpers.deepCompareStrict(schema["const"], instance)) {
        result.addError({
          name: "const",
          argument: schema["const"],
          message: "does not exactly match expected constant: " + schema["const"]
        });
      }
      return result;
    };
    validators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {
      var self2 = this;
      if (instance === void 0) return null;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var notTypes = schema.not || schema.disallow;
      if (!notTypes) return null;
      if (!Array.isArray(notTypes)) notTypes = [notTypes];
      notTypes.forEach(function(type) {
        if (self2.testType(instance, schema, options, ctx, type)) {
          var schemaId = type && type.id && "<" + type.id + ">" || type;
          result.addError({
            name: "not",
            argument: schemaId,
            message: "is of prohibited type " + schemaId
          });
        }
      });
      return result;
    };
    module.exports = attribute;
  }
});

// node_modules/jsonschema/lib/validator.js
var require_validator = __commonJS({
  "node_modules/jsonschema/lib/validator.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var urilib = (init_url(), __toCommonJS(url_exports));
    var attribute = require_attribute();
    var helpers = require_helpers();
    var ValidatorResult = helpers.ValidatorResult;
    var SchemaError = helpers.SchemaError;
    var SchemaContext = helpers.SchemaContext;
    var Validator = function Validator2() {
      this.customFormats = Object.create(Validator2.prototype.customFormats);
      this.schemas = {};
      this.unresolvedRefs = [];
      this.types = Object.create(types);
      this.attributes = Object.create(attribute.validators);
    };
    Validator.prototype.customFormats = {};
    Validator.prototype.schemas = null;
    Validator.prototype.types = null;
    Validator.prototype.attributes = null;
    Validator.prototype.unresolvedRefs = null;
    Validator.prototype.addSchema = function addSchema(schema, uri) {
      if (!schema) {
        return null;
      }
      var ourUri = uri || schema.id;
      this.addSubSchema(ourUri, schema);
      if (ourUri) {
        this.schemas[ourUri] = schema;
      }
      return this.schemas[ourUri];
    };
    Validator.prototype.addSubSchema = function addSubSchema(baseuri, schema) {
      if (!schema || typeof schema != "object") return;
      if (schema.$ref) {
        var resolvedUri = urilib.resolve(baseuri, schema.$ref);
        if (this.schemas[resolvedUri] === void 0) {
          this.schemas[resolvedUri] = null;
          this.unresolvedRefs.push(resolvedUri);
        }
        return;
      }
      var ourUri = schema.id && urilib.resolve(baseuri, schema.id);
      var ourBase = ourUri || baseuri;
      if (ourUri) {
        if (this.schemas[ourUri]) {
          if (!helpers.deepCompareStrict(this.schemas[ourUri], schema)) {
            throw new Error("Schema <" + schema + "> already exists with different definition");
          }
          return this.schemas[ourUri];
        }
        this.schemas[ourUri] = schema;
        var documentUri = ourUri.replace(/^([^#]*)#$/, "$1");
        this.schemas[documentUri] = schema;
      }
      this.addSubSchemaArray(ourBase, schema.items instanceof Array ? schema.items : [schema.items]);
      this.addSubSchemaArray(ourBase, schema.extends instanceof Array ? schema.extends : [schema.extends]);
      this.addSubSchema(ourBase, schema.additionalItems);
      this.addSubSchemaObject(ourBase, schema.properties);
      this.addSubSchema(ourBase, schema.additionalProperties);
      this.addSubSchemaObject(ourBase, schema.definitions);
      this.addSubSchemaObject(ourBase, schema.patternProperties);
      this.addSubSchemaObject(ourBase, schema.dependencies);
      this.addSubSchemaArray(ourBase, schema.disallow);
      this.addSubSchemaArray(ourBase, schema.allOf);
      this.addSubSchemaArray(ourBase, schema.anyOf);
      this.addSubSchemaArray(ourBase, schema.oneOf);
      this.addSubSchema(ourBase, schema.not);
      return this.schemas[ourUri];
    };
    Validator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {
      if (!(schemas instanceof Array)) return;
      for (var i = 0; i < schemas.length; i++) {
        this.addSubSchema(baseuri, schemas[i]);
      }
    };
    Validator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {
      if (!schemas || typeof schemas != "object") return;
      for (var p in schemas) {
        this.addSubSchema(baseuri, schemas[p]);
      }
    };
    Validator.prototype.setSchemas = function setSchemas(schemas) {
      this.schemas = schemas;
    };
    Validator.prototype.getSchema = function getSchema(urn) {
      return this.schemas[urn];
    };
    Validator.prototype.validate = function validate(instance, schema, options, ctx) {
      if (!options) {
        options = {};
      }
      var propertyName = options.propertyName || "instance";
      var base = urilib.resolve(options.base || "/", schema.id || "");
      if (!ctx) {
        ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));
        if (!ctx.schemas[base]) {
          ctx.schemas[base] = schema;
        }
      }
      if (schema) {
        var result = this.validateSchema(instance, schema, options, ctx);
        if (!result) {
          throw new Error("Result undefined");
        }
        return result;
      }
      throw new SchemaError("no schema specified", schema);
    };
    function shouldResolve(schema) {
      var ref = typeof schema === "string" ? schema : schema.$ref;
      if (typeof ref == "string") return ref;
      return false;
    }
    Validator.prototype.validateSchema = function validateSchema(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!schema) {
        throw new Error("schema is undefined");
      }
      if (schema["extends"]) {
        if (schema["extends"] instanceof Array) {
          var schemaobj = { schema, ctx };
          schema["extends"].forEach(this.schemaTraverser.bind(this, schemaobj));
          schema = schemaobj.schema;
          schemaobj.schema = null;
          schemaobj.ctx = null;
          schemaobj = null;
        } else {
          schema = helpers.deepMerge(schema, this.superResolve(schema["extends"], ctx));
        }
      }
      var switchSchema;
      if (switchSchema = shouldResolve(schema)) {
        var resolved = this.resolve(schema, switchSchema, ctx);
        var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);
        return this.validateSchema(instance, resolved.subschema, options, subctx);
      }
      var skipAttributes = options && options.skipAttributes || [];
      for (var key in schema) {
        if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {
          var validatorErr = null;
          var validator = this.attributes[key];
          if (validator) {
            validatorErr = validator.call(this, instance, schema, options, ctx);
          } else if (options.allowUnknownAttributes === false) {
            throw new SchemaError("Unsupported attribute: " + key, schema);
          }
          if (validatorErr) {
            result.importErrors(validatorErr);
          }
        }
      }
      if (typeof options.rewrite == "function") {
        var value = options.rewrite.call(this, instance, schema, options, ctx);
        result.instance = value;
      }
      return result;
    };
    Validator.prototype.schemaTraverser = function schemaTraverser(schemaobj, s) {
      schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));
    };
    Validator.prototype.superResolve = function superResolve(schema, ctx) {
      var ref;
      if (ref = shouldResolve(schema)) {
        return this.resolve(schema, ref, ctx).subschema;
      }
      return schema;
    };
    Validator.prototype.resolve = function resolve2(schema, switchSchema, ctx) {
      switchSchema = ctx.resolve(switchSchema);
      if (ctx.schemas[switchSchema]) {
        return { subschema: ctx.schemas[switchSchema], switchSchema };
      }
      var parsed = urilib.parse(switchSchema);
      var fragment = parsed && parsed.hash;
      var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);
      if (!document || !ctx.schemas[document]) {
        throw new SchemaError("no such schema <" + switchSchema + ">", schema);
      }
      var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));
      if (subschema === void 0) {
        throw new SchemaError("no such schema " + fragment + " located in <" + document + ">", schema);
      }
      return { subschema, switchSchema };
    };
    Validator.prototype.testType = function validateType(instance, schema, options, ctx, type) {
      if (typeof this.types[type] == "function") {
        return this.types[type].call(this, instance);
      }
      if (type && typeof type == "object") {
        var res = this.validateSchema(instance, type, options, ctx);
        return res === void 0 || !(res && res.errors.length);
      }
      return true;
    };
    var types = Validator.prototype.types = {};
    types.string = function testString(instance) {
      return typeof instance == "string";
    };
    types.number = function testNumber(instance) {
      return typeof instance == "number" && isFinite(instance);
    };
    types.integer = function testInteger(instance) {
      return typeof instance == "number" && instance % 1 === 0;
    };
    types.boolean = function testBoolean(instance) {
      return typeof instance == "boolean";
    };
    types.array = function testArray(instance) {
      return Array.isArray(instance);
    };
    types["null"] = function testNull(instance) {
      return instance === null;
    };
    types.date = function testDate(instance) {
      return instance instanceof Date;
    };
    types.any = function testAny(instance) {
      return true;
    };
    types.object = function testObject(instance) {
      return instance && typeof instance === "object" && !(instance instanceof Array) && !(instance instanceof Date);
    };
    module.exports = Validator;
  }
});

// node_modules/jsonschema/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/jsonschema/lib/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var Validator = module.exports.Validator = require_validator();
    module.exports.ValidatorResult = require_helpers().ValidatorResult;
    module.exports.ValidationError = require_helpers().ValidationError;
    module.exports.SchemaError = require_helpers().SchemaError;
    module.exports.validate = function(instance, schema, options) {
      var v = new Validator();
      return v.validate(instance, schema, options);
    };
  }
});

// node_modules/ripple-address-codec/dist/utils.js
var require_utils2 = __commonJS({
  "node_modules/ripple-address-codec/dist/utils.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatArgs = exports.seqEqual = void 0;
    function seqEqual(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        return false;
      }
      for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
          return false;
        }
      }
      return true;
    }
    exports.seqEqual = seqEqual;
    function isSequence(val) {
      return typeof val !== "number";
    }
    function concatArgs(...args) {
      const ret = [];
      args.forEach((arg) => {
        if (isSequence(arg)) {
          for (const j of arg) {
            ret.push(j);
          }
        } else {
          ret.push(arg);
        }
      });
      return ret;
    }
    exports.concatArgs = concatArgs;
  }
});

// node_modules/ripple-address-codec/dist/xrp-codec.js
var require_xrp_codec = __commonJS({
  "node_modules/ripple-address-codec/dist/xrp-codec.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
    var baseCodec = require_src();
    var createHash = require_browser();
    var utils_1 = require_utils2();
    var Codec = class {
      constructor(options) {
        this._sha256 = options.sha256;
        this._alphabet = options.alphabet;
        this._codec = baseCodec(this._alphabet);
      }
      /**
       * Encoder.
       *
       * @param bytes - Buffer of data to encode.
       * @param opts - Options object including the version bytes and the expected length of the data to encode.
       */
      encode(bytes, opts) {
        const versions = opts.versions;
        return this._encodeVersioned(bytes, versions, opts.expectedLength);
      }
      /**
       * Decoder.
       *
       * @param base58string - Base58Check-encoded string to decode.
       * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.
       */
      /* eslint-disable max-lines-per-function --
       * TODO refactor */
      decode(base58string, opts) {
        var _a;
        const versions = opts.versions;
        const types = opts.versionTypes;
        const withoutSum = this.decodeChecked(base58string);
        if (versions.length > 1 && !opts.expectedLength) {
          throw new Error("expectedLength is required because there are >= 2 possible versions");
        }
        const versionLengthGuess = typeof versions[0] === "number" ? 1 : versions[0].length;
        const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;
        const versionBytes = withoutSum.slice(0, -payloadLength);
        const payload = withoutSum.slice(-payloadLength);
        for (let i = 0; i < versions.length; i++) {
          const version = Array.isArray(versions[i]) ? versions[i] : [versions[i]];
          if ((0, utils_1.seqEqual)(versionBytes, version)) {
            return {
              version,
              bytes: payload,
              type: types ? types[i] : null
            };
          }
        }
        throw new Error("version_invalid: version bytes do not match any of the provided version(s)");
      }
      encodeChecked(buffer) {
        const check = this._sha256(this._sha256(buffer)).slice(0, 4);
        return this._encodeRaw(Buffer.from((0, utils_1.concatArgs)(buffer, check)));
      }
      decodeChecked(base58string) {
        const buffer = this._decodeRaw(base58string);
        if (buffer.length < 5) {
          throw new Error("invalid_input_size: decoded data must have length >= 5");
        }
        if (!this._verifyCheckSum(buffer)) {
          throw new Error("checksum_invalid");
        }
        return buffer.slice(0, -4);
      }
      _encodeVersioned(bytes, versions, expectedLength) {
        if (expectedLength && bytes.length !== expectedLength) {
          throw new Error("unexpected_payload_length: bytes.length does not match expectedLength. Ensure that the bytes are a Buffer.");
        }
        return this.encodeChecked(Buffer.from((0, utils_1.concatArgs)(versions, bytes)));
      }
      _encodeRaw(bytes) {
        return this._codec.encode(bytes);
      }
      /* eslint-enable max-lines-per-function */
      _decodeRaw(base58string) {
        return this._codec.decode(base58string);
      }
      _verifyCheckSum(bytes) {
        const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4);
        const checksum = bytes.slice(-4);
        return (0, utils_1.seqEqual)(computed, checksum);
      }
    };
    var ACCOUNT_ID = 0;
    var ACCOUNT_PUBLIC_KEY = 35;
    var FAMILY_SEED = 33;
    var NODE_PUBLIC = 28;
    var ED25519_SEED = [1, 225, 75];
    var codecOptions = {
      sha256(bytes) {
        return createHash("sha256").update(Buffer.from(bytes)).digest();
      },
      alphabet: "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"
    };
    var codecWithXrpAlphabet = new Codec(codecOptions);
    exports.codec = codecWithXrpAlphabet;
    function encodeSeed(entropy, type) {
      if (entropy.length !== 16) {
        throw new Error("entropy must have length 16");
      }
      const opts = {
        expectedLength: 16,
        // for secp256k1, use `FAMILY_SEED`
        versions: type === "ed25519" ? ED25519_SEED : [FAMILY_SEED]
      };
      return codecWithXrpAlphabet.encode(entropy, opts);
    }
    exports.encodeSeed = encodeSeed;
    function decodeSeed(seed, opts = {
      versionTypes: ["ed25519", "secp256k1"],
      versions: [ED25519_SEED, FAMILY_SEED],
      expectedLength: 16
    }) {
      return codecWithXrpAlphabet.decode(seed, opts);
    }
    exports.decodeSeed = decodeSeed;
    function encodeAccountID(bytes) {
      const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports.encodeAccountID = encodeAccountID;
    exports.encodeAddress = encodeAccountID;
    function decodeAccountID(accountId) {
      const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
      return codecWithXrpAlphabet.decode(accountId, opts).bytes;
    }
    exports.decodeAccountID = decodeAccountID;
    exports.decodeAddress = decodeAccountID;
    function decodeNodePublic(base58string) {
      const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
      return codecWithXrpAlphabet.decode(base58string, opts).bytes;
    }
    exports.decodeNodePublic = decodeNodePublic;
    function encodeNodePublic(bytes) {
      const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports.encodeNodePublic = encodeNodePublic;
    function encodeAccountPublic(bytes) {
      const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
      return codecWithXrpAlphabet.encode(bytes, opts);
    }
    exports.encodeAccountPublic = encodeAccountPublic;
    function decodeAccountPublic(base58string) {
      const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
      return codecWithXrpAlphabet.decode(base58string, opts).bytes;
    }
    exports.decodeAccountPublic = decodeAccountPublic;
    function isValidClassicAddress(address) {
      try {
        decodeAccountID(address);
      } catch (_error) {
        return false;
      }
      return true;
    }
    exports.isValidClassicAddress = isValidClassicAddress;
  }
});

// node_modules/ripple-address-codec/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/ripple-address-codec/dist/index.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
    var assert = __importStar(require_assert());
    var xrp_codec_1 = require_xrp_codec();
    Object.defineProperty(exports, "codec", { enumerable: true, get: function() {
      return xrp_codec_1.codec;
    } });
    Object.defineProperty(exports, "encodeSeed", { enumerable: true, get: function() {
      return xrp_codec_1.encodeSeed;
    } });
    Object.defineProperty(exports, "decodeSeed", { enumerable: true, get: function() {
      return xrp_codec_1.decodeSeed;
    } });
    Object.defineProperty(exports, "encodeAccountID", { enumerable: true, get: function() {
      return xrp_codec_1.encodeAccountID;
    } });
    Object.defineProperty(exports, "decodeAccountID", { enumerable: true, get: function() {
      return xrp_codec_1.decodeAccountID;
    } });
    Object.defineProperty(exports, "encodeNodePublic", { enumerable: true, get: function() {
      return xrp_codec_1.encodeNodePublic;
    } });
    Object.defineProperty(exports, "decodeNodePublic", { enumerable: true, get: function() {
      return xrp_codec_1.decodeNodePublic;
    } });
    Object.defineProperty(exports, "encodeAccountPublic", { enumerable: true, get: function() {
      return xrp_codec_1.encodeAccountPublic;
    } });
    Object.defineProperty(exports, "decodeAccountPublic", { enumerable: true, get: function() {
      return xrp_codec_1.decodeAccountPublic;
    } });
    Object.defineProperty(exports, "isValidClassicAddress", { enumerable: true, get: function() {
      return xrp_codec_1.isValidClassicAddress;
    } });
    var PREFIX_BYTES = {
      // 5, 68
      main: Buffer.from([5, 68]),
      // 4, 147
      test: Buffer.from([4, 147])
    };
    var MAX_32_BIT_UNSIGNED_INT = 4294967295;
    function classicAddressToXAddress(classicAddress, tag, test) {
      const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);
      return encodeXAddress(accountId, tag, test);
    }
    exports.classicAddressToXAddress = classicAddressToXAddress;
    function encodeXAddress(accountId, tag, test) {
      if (accountId.length !== 20) {
        throw new Error("Account ID must be 20 bytes");
      }
      if (tag > MAX_32_BIT_UNSIGNED_INT) {
        throw new Error("Invalid tag");
      }
      const theTag = tag || 0;
      const flag = tag === false || tag == null ? 0 : 1;
      const bytes = Buffer.concat([
        test ? PREFIX_BYTES.test : PREFIX_BYTES.main,
        accountId,
        Buffer.from([
          // 0x00 if no tag, 0x01 if 32-bit tag
          flag,
          // first byte
          theTag & 255,
          // second byte
          theTag >> 8 & 255,
          // third byte
          theTag >> 16 & 255,
          // fourth byte
          theTag >> 24 & 255,
          0,
          0,
          0,
          // four zero bytes (reserved for 64-bit tags)
          0
        ])
      ]);
      return xrp_codec_1.codec.encodeChecked(bytes);
    }
    exports.encodeXAddress = encodeXAddress;
    function xAddressToClassicAddress(xAddress) {
      const { accountId, tag, test } = decodeXAddress(xAddress);
      const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);
      return {
        classicAddress,
        tag,
        test
      };
    }
    exports.xAddressToClassicAddress = xAddressToClassicAddress;
    function decodeXAddress(xAddress) {
      const decoded = xrp_codec_1.codec.decodeChecked(xAddress);
      const test = isBufferForTestAddress(decoded);
      const accountId = decoded.slice(2, 22);
      const tag = tagFromBuffer(decoded);
      return {
        accountId,
        tag,
        test
      };
    }
    exports.decodeXAddress = decodeXAddress;
    function isBufferForTestAddress(buf) {
      const decodedPrefix = buf.slice(0, 2);
      if (PREFIX_BYTES.main.equals(decodedPrefix)) {
        return false;
      }
      if (PREFIX_BYTES.test.equals(decodedPrefix)) {
        return true;
      }
      throw new Error("Invalid X-address: bad prefix");
    }
    function tagFromBuffer(buf) {
      const flag = buf[22];
      if (flag >= 2) {
        throw new Error("Unsupported X-address");
      }
      if (flag === 1) {
        return buf[23] + buf[24] * 256 + buf[25] * 65536 + buf[26] * 16777216;
      }
      assert.strictEqual(flag, 0, "flag must be zero to indicate no tag");
      assert.ok(Buffer.from("0000000000000000", "hex").equals(buf.slice(23, 23 + 8)), "remaining bytes must be zero");
      return false;
    }
    function isValidXAddress(xAddress) {
      try {
        decodeXAddress(xAddress);
      } catch (_error) {
        return false;
      }
      return true;
    }
    exports.isValidXAddress = isValidXAddress;
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format2(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format2(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format2(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format3) {
          var str, x = this;
          if (format3 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format3 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format3 = dp;
              dp = rm = null;
            } else {
              format3 = FORMAT;
            }
          } else if (typeof format3 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format3);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format3.groupSize, g2 = +format3.secondaryGroupSize, groupSeparator = format3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format3.decimalSeparator || "") + ((g2 = +format3.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format3.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format3.prefix || "") + str + (format3.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format2(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/ripple-keypairs/dist/Sha512.js
var require_Sha512 = __commonJS({
  "node_modules/ripple-keypairs/dist/Sha512.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var hashjs = __importStar(require_hash());
    var BigNum = require_bn();
    var Sha512 = class {
      constructor() {
        this.hash = hashjs.sha512();
      }
      add(bytes) {
        this.hash.update(bytes);
        return this;
      }
      addU32(i) {
        return this.add([
          i >>> 24 & 255,
          i >>> 16 & 255,
          i >>> 8 & 255,
          i & 255
        ]);
      }
      finish() {
        return this.hash.digest();
      }
      first256() {
        return this.finish().slice(0, 32);
      }
      first256BN() {
        return new BigNum(this.first256());
      }
    };
    exports.default = Sha512;
  }
});

// node_modules/ripple-keypairs/dist/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/ripple-keypairs/dist/secp256k1.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;
    var elliptic = __importStar(require_elliptic());
    var Sha512_1 = __importDefault(require_Sha512());
    var secp256k1 = elliptic.ec("secp256k1");
    function deriveScalar(bytes, discrim) {
      const order = secp256k1.curve.n;
      for (let i = 0; i <= 4294967295; i++) {
        const hasher = new Sha512_1.default().add(bytes);
        if (discrim !== void 0) {
          hasher.addU32(discrim);
        }
        hasher.addU32(i);
        const key = hasher.first256BN();
        if (key.cmpn(0) > 0 && key.cmp(order) < 0) {
          return key;
        }
      }
      throw new Error("impossible unicorn ;)");
    }
    function derivePrivateKey(seed, opts = {}) {
      const root = opts.validator;
      const order = secp256k1.curve.n;
      const privateGen = deriveScalar(seed);
      if (root) {
        return privateGen;
      }
      const publicGen = secp256k1.g.mul(privateGen);
      const accountIndex = opts.accountIndex || 0;
      return deriveScalar(publicGen.encodeCompressed(), accountIndex).add(privateGen).mod(order);
    }
    exports.derivePrivateKey = derivePrivateKey;
    function accountPublicFromPublicGenerator(publicGenBytes) {
      const rootPubPoint = secp256k1.curve.decodePoint(publicGenBytes);
      const scalar = deriveScalar(publicGenBytes, 0);
      const point = secp256k1.g.mul(scalar);
      const offset = rootPubPoint.add(point);
      return offset.encodeCompressed();
    }
    exports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;
  }
});

// node_modules/ripple-keypairs/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/ripple-keypairs/dist/utils.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computePublicKeyHash = exports.hexToBytes = exports.bytesToHex = void 0;
    var assert = __importStar(require_assert());
    var hashjs = __importStar(require_hash());
    var BN = require_bn();
    function bytesToHex(a) {
      return Array.from(a, (byteValue) => {
        const hex = byteValue.toString(16).toUpperCase();
        return hex.length > 1 ? hex : `0${hex}`;
      }).join("");
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(a) {
      assert.ok(a.length % 2 === 0);
      return a.length === 0 ? [] : new BN(a, 16).toArray(null, a.length / 2);
    }
    exports.hexToBytes = hexToBytes;
    function computePublicKeyHash(publicKeyBytes) {
      const hash256 = hashjs.sha256().update(publicKeyBytes).digest();
      const hash160 = hashjs.ripemd160().update(hash256).digest();
      return Buffer.from(hash160);
    }
    exports.computePublicKeyHash = computePublicKeyHash;
  }
});

// node_modules/ripple-keypairs/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/ripple-keypairs/dist/index.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;
    var assert = __importStar(require_assert());
    var brorand = require_brorand();
    var hashjs = __importStar(require_hash());
    var elliptic = __importStar(require_elliptic());
    var addressCodec = __importStar(require_dist4());
    var secp256k1_1 = require_secp256k1();
    var utils = __importStar(require_utils3());
    var Ed25519 = elliptic.eddsa("ed25519");
    var Secp256k1 = elliptic.ec("secp256k1");
    var { hexToBytes } = utils;
    var { bytesToHex } = utils;
    function generateSeed(options = {}) {
      assert.ok(!options.entropy || options.entropy.length >= 16, "entropy too short");
      const entropy = options.entropy ? options.entropy.slice(0, 16) : brorand(16);
      const type = options.algorithm === "ed25519" ? "ed25519" : "secp256k1";
      return addressCodec.encodeSeed(Buffer.from(entropy), type);
    }
    exports.generateSeed = generateSeed;
    function hash(message) {
      return hashjs.sha512().update(message).digest().slice(0, 32);
    }
    var secp256k1 = {
      deriveKeypair(entropy, options) {
        const prefix = "00";
        const privateKey = prefix + (0, secp256k1_1.derivePrivateKey)(entropy, options).toString(16, 64).toUpperCase();
        const publicKey = bytesToHex(Secp256k1.keyFromPrivate(privateKey.slice(2)).getPublic().encodeCompressed());
        return { privateKey, publicKey };
      },
      sign(message, privateKey) {
        return bytesToHex(Secp256k1.sign(hash(message), hexToBytes(privateKey), {
          canonical: true
        }).toDER());
      },
      verify(message, signature, publicKey) {
        return Secp256k1.verify(hash(message), signature, hexToBytes(publicKey));
      }
    };
    var ed25519 = {
      deriveKeypair(entropy) {
        const prefix = "ED";
        const rawPrivateKey = hash(entropy);
        const privateKey = prefix + bytesToHex(rawPrivateKey);
        const publicKey = prefix + bytesToHex(Ed25519.keyFromSecret(rawPrivateKey).pubBytes());
        return { privateKey, publicKey };
      },
      sign(message, privateKey) {
        assert.ok(Array.isArray(message), "message must be array of octets");
        return bytesToHex(Ed25519.sign(message, hexToBytes(privateKey).slice(1)).toBytes());
      },
      verify(message, signature, publicKey) {
        return Ed25519.verify(message, hexToBytes(signature), hexToBytes(publicKey).slice(1));
      }
    };
    function select(algorithm) {
      const methods = { "ecdsa-secp256k1": secp256k1, ed25519 };
      return methods[algorithm];
    }
    function deriveKeypair(seed, options) {
      const decoded = addressCodec.decodeSeed(seed);
      const algorithm = decoded.type === "ed25519" ? "ed25519" : "ecdsa-secp256k1";
      const method = select(algorithm);
      const keypair = method.deriveKeypair(decoded.bytes, options);
      const messageToVerify = hash("This test message should verify.");
      const signature = method.sign(messageToVerify, keypair.privateKey);
      if (method.verify(messageToVerify, signature, keypair.publicKey) !== true) {
        throw new Error("derived keypair did not generate verifiable signature");
      }
      return keypair;
    }
    exports.deriveKeypair = deriveKeypair;
    function getAlgorithmFromKey(key) {
      const bytes = hexToBytes(key);
      return bytes.length === 33 && bytes[0] === 237 ? "ed25519" : "ecdsa-secp256k1";
    }
    function sign(messageHex, privateKey) {
      const algorithm = getAlgorithmFromKey(privateKey);
      return select(algorithm).sign(hexToBytes(messageHex), privateKey);
    }
    exports.sign = sign;
    function verify(messageHex, signature, publicKey) {
      const algorithm = getAlgorithmFromKey(publicKey);
      return select(algorithm).verify(hexToBytes(messageHex), signature, publicKey);
    }
    exports.verify = verify;
    function deriveAddressFromBytes(publicKeyBytes) {
      return addressCodec.encodeAccountID(utils.computePublicKeyHash(publicKeyBytes));
    }
    function deriveAddress(publicKey) {
      return deriveAddressFromBytes(Buffer.from(hexToBytes(publicKey)));
    }
    exports.deriveAddress = deriveAddress;
    function deriveNodeAddress(publicKey) {
      const generatorBytes = addressCodec.decodeNodePublic(publicKey);
      const accountPublicBytes = (0, secp256k1_1.accountPublicFromPublicGenerator)(generatorBytes);
      return deriveAddressFromBytes(accountPublicBytes);
    }
    exports.deriveNodeAddress = deriveNodeAddress;
    var { decodeSeed } = addressCodec;
    exports.decodeSeed = decodeSeed;
  }
});

// node_modules/ripple-lib/dist/npm/common/utils.js
var require_utils4 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/utils.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidSecret = exports.iso8601ToRippleTime = exports.rippleTimeToISO8601 = exports.removeUndefined = exports.convertKeysFromSnakeCaseToCamelCase = exports.toRippledAmount = exports.xrpToDrops = exports.dropsToXrp = void 0;
    var _ = __importStar(require_lodash());
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_keypairs_1 = require_dist5();
    var errors_1 = require_errors();
    var ripple_address_codec_1 = require_dist4();
    function isValidSecret(secret) {
      try {
        ripple_keypairs_1.deriveKeypair(secret);
        return true;
      } catch (err) {
        return false;
      }
    }
    exports.isValidSecret = isValidSecret;
    function dropsToXrp(drops) {
      if (typeof drops === "string") {
        if (!drops.match(/^-?[0-9]*\.?[0-9]*$/)) {
          throw new errors_1.ValidationError(`dropsToXrp: invalid value '${drops}', should be a number matching (^-?[0-9]*\\.?[0-9]*$).`);
        } else if (drops === ".") {
          throw new errors_1.ValidationError(`dropsToXrp: invalid value '${drops}', should be a BigNumber or string-encoded number.`);
        }
      }
      drops = new bignumber_js_1.default(drops).toString(10);
      if (drops.includes(".")) {
        throw new errors_1.ValidationError(`dropsToXrp: value '${drops}' has too many decimal places.`);
      }
      if (!drops.match(/^-?[0-9]+$/)) {
        throw new errors_1.ValidationError(`dropsToXrp: failed sanity check - value '${drops}', does not match (^-?[0-9]+$).`);
      }
      return new bignumber_js_1.default(drops).dividedBy(1e6).toString(10);
    }
    exports.dropsToXrp = dropsToXrp;
    function xrpToDrops(xrp) {
      if (typeof xrp === "string") {
        if (!xrp.match(/^-?[0-9]*\.?[0-9]*$/)) {
          throw new errors_1.ValidationError(`xrpToDrops: invalid value '${xrp}', should be a number matching (^-?[0-9]*\\.?[0-9]*$).`);
        } else if (xrp === ".") {
          throw new errors_1.ValidationError(`xrpToDrops: invalid value '${xrp}', should be a BigNumber or string-encoded number.`);
        }
      }
      xrp = new bignumber_js_1.default(xrp).toString(10);
      if (!xrp.match(/^-?[0-9.]+$/)) {
        throw new errors_1.ValidationError(`xrpToDrops: failed sanity check - value '${xrp}', does not match (^-?[0-9.]+$).`);
      }
      const components = xrp.split(".");
      if (components.length > 2) {
        throw new errors_1.ValidationError(`xrpToDrops: failed sanity check - value '${xrp}' has too many decimal points.`);
      }
      const fraction = components[1] || "0";
      if (fraction.length > 6) {
        throw new errors_1.ValidationError(`xrpToDrops: value '${xrp}' has too many decimal places.`);
      }
      return new bignumber_js_1.default(xrp).times(1e6).integerValue(bignumber_js_1.default.ROUND_FLOOR).toString(10);
    }
    exports.xrpToDrops = xrpToDrops;
    function toRippledAmount(amount) {
      if (typeof amount === "string")
        return amount;
      if (amount.currency === "XRP") {
        return xrpToDrops(amount.value);
      }
      if (amount.currency === "drops") {
        return amount.value;
      }
      let issuer = amount.counterparty || amount.issuer;
      let tag = false;
      try {
        ({ classicAddress: issuer, tag } = ripple_address_codec_1.xAddressToClassicAddress(issuer));
      } catch (e) {
      }
      if (tag !== false) {
        throw new errors_1.ValidationError("Issuer X-address includes a tag");
      }
      return {
        currency: amount.currency,
        issuer,
        value: amount.value
      };
    }
    exports.toRippledAmount = toRippledAmount;
    function convertKeysFromSnakeCaseToCamelCase(obj) {
      if (typeof obj === "object") {
        const accumulator = Array.isArray(obj) ? [] : {};
        let newKey;
        return Object.entries(obj).reduce((result, [key, value]) => {
          newKey = key;
          const FINDSNAKE = /([a-zA-Z]_[a-zA-Z])/g;
          if (FINDSNAKE.test(key)) {
            newKey = key.replace(FINDSNAKE, (r) => r[0] + r[2].toUpperCase());
          }
          result[newKey] = convertKeysFromSnakeCaseToCamelCase(value);
          return result;
        }, accumulator);
      }
      return obj;
    }
    exports.convertKeysFromSnakeCaseToCamelCase = convertKeysFromSnakeCaseToCamelCase;
    function removeUndefined(obj) {
      return _.omitBy(obj, (value) => value == null);
    }
    exports.removeUndefined = removeUndefined;
    function rippleToUnixTimestamp(rpepoch) {
      return (rpepoch + 946684800) * 1e3;
    }
    function unixToRippleTimestamp(timestamp) {
      return Math.round(timestamp / 1e3) - 946684800;
    }
    function rippleTimeToISO8601(rippleTime) {
      return new Date(rippleToUnixTimestamp(rippleTime)).toISOString();
    }
    exports.rippleTimeToISO8601 = rippleTimeToISO8601;
    function iso8601ToRippleTime(iso8601) {
      return unixToRippleTimestamp(Date.parse(iso8601));
    }
    exports.iso8601ToRippleTime = iso8601ToRippleTime;
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/tx-json.json
var require_tx_json = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/tx-json.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "tx-json",
      link: "https://xrpl.org/transaction-formats.html",
      description: "An object in rippled txJSON format",
      type: "object",
      properties: {
        Account: { $ref: "address" },
        TransactionType: { type: "string" }
      },
      required: ["Account", "TransactionType"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/transaction-type.json
var require_transaction_type = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/transaction-type.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "transactionType",
      link: "transaction-types",
      description: "The type of the transaction.",
      type: "string",
      enum: [
        "payment",
        "order",
        "orderCancellation",
        "trustline",
        "settings",
        "escrowCreation",
        "escrowCancellation",
        "escrowExecution",
        "paymentChannelCreate",
        "paymentChannelFund",
        "paymentChannelClaim",
        "checkCreate",
        "checkCancel",
        "checkCash",
        "depositPreauth",
        "accountDelete"
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/hash128.json
var require_hash128 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/hash128.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "hash128",
      description: "The hexadecimal representation of a 128-bit hash",
      type: "string",
      pattern: "^[A-F0-9]{32}$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/hash256.json
var require_hash256 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/hash256.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "hash256",
      description: "The hexadecimal representation of a 256-bit hash",
      type: "string",
      pattern: "^[A-F0-9]{64}$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/sequence.json
var require_sequence = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/sequence.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "sequence",
      link: "account-sequence-number",
      description: "An account transaction sequence number",
      type: "integer",
      minimum: 0
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/ticket-sequence.json
var require_ticket_sequence = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/ticket-sequence.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "ticket-sequence",
      link: "account-sequence-number",
      description: "An account transaction tickt sequence number",
      type: "integer",
      minimum: 1
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/signature.json
var require_signature = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/signature.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "signature",
      description: "The hexadecimal representation of a signature.",
      type: "string",
      pattern: "^[A-F0-9]+$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/issue.json
var require_issue = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/issue.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "issue",
      description: "The currency code, and the counterparty if it's not XRP.",
      allOf: [
        { $ref: "amountbase" },
        { not: { required: ["value"] } }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/ledger-version.json
var require_ledger_version = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/ledger-version.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "ledgerVersion",
      description: "A ledger version number",
      oneOf: [
        {
          type: "integer",
          minimum: 1
        },
        {
          type: "string",
          enum: ["validated", "closed", "current"]
        }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/max-adjustment.json
var require_max_adjustment = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/max-adjustment.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "maxAdjustment",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address to send from."
        },
        maxAmount: {
          $ref: "laxAmount",
          description: "The maximum amount to send. (This field cannot be used with source.amount)"
        },
        tag: { $ref: "tag" }
      },
      required: ["address", "maxAmount"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/memo.json
var require_memo = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/memo.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "memo",
      description: "Memo objects represent arbitrary data that can be included in a transaction",
      type: "object",
      properties: {
        type: {
          pattern: "^[A-Za-z0-9\\-._~:/?#[\\]@!$&'()*+,;=%]*$",
          description: "Conventionally, a unique relation (according to [RFC 5988](http://tools.ietf.org/html/rfc5988#section-4)) that defines the format of this memo. Only characters allowed in URLs are permitted."
        },
        format: {
          pattern: "^[A-Za-z0-9\\-._~:/?#[\\]@!$&'()*+,;=%]*$",
          description: "Conventionally containing information on how the memo is encoded, for example as a [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml). Only characters allowed in URLs are permitted."
        },
        data: {
          type: "string",
          description: "Arbitrary string, conventionally containing the content of the memo."
        }
      },
      additionalProperties: false,
      anyOf: [
        { required: ["data"] },
        { required: ["type"] }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/memos.json
var require_memos = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/memos.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "memos",
      link: "transaction-memos",
      description: "Array of memos to attach to the transaction.",
      type: "array",
      items: {
        $ref: "memo"
      }
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/public-key.json
var require_public_key = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/public-key.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "publicKey",
      description: "The hexadecimal representation of a secp256k1 or Ed25519 public key.",
      type: "string",
      pattern: "^[A-F0-9]+$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/private-key.json
var require_private_key = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/private-key.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "privateKey",
      description: "The hexadecimal representation of a secp256k1 or Ed25519 private key.",
      type: "string",
      pattern: "^[A-F0-9]+$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/uint32.json
var require_uint32 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/uint32.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "uint32",
      description: "A 32-bit unsigned integer",
      type: "integer",
      minimum: 0,
      maximum: 4294967295
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/value.json
var require_value = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/value.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "value",
      link: "value",
      description: "A string representation of a non-negative floating point number",
      type: "string",
      pattern: "^[0-9]*[.]?[0-9]+([eE][-+]?[0-9]+)?$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/source-adjustment.json
var require_source_adjustment = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/source-adjustment.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "sourceAdjustment",
      type: "object",
      oneOf: [
        { $ref: "sourceExactAdjustment" },
        { $ref: "maxAdjustment" }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/destination-adjustment.json
var require_destination_adjustment = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/destination-adjustment.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "destinationAdjustment",
      type: "object",
      oneOf: [
        { $ref: "destinationExactAdjustment" },
        { $ref: "minAdjustment" }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/tag.json
var require_tag = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/tag.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "tag",
      description: "An arbitrary 32-bit unsigned integer. It typically maps to an off-ledger account; for example, a hosted wallet or exchange account.",
      type: "integer",
      $ref: "uint32"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/lax-amount.json
var require_lax_amount = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/lax-amount.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "laxAmount",
      description: "Amount where counterparty is optional",
      link: "amount",
      type: "object",
      properties: {
        currency: { $ref: "currency" },
        counterparty: { $ref: "address" },
        value: { $ref: "value" }
      },
      required: ["currency", "value"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/lax-lax-amount.json
var require_lax_lax_amount = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/lax-lax-amount.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "laxLaxAmount",
      description: "Amount where counterparty and value are optional",
      link: "amount",
      type: "object",
      properties: {
        currency: { $ref: "currency" },
        counterparty: { $ref: "address" },
        value: { $ref: "value" }
      },
      required: ["currency"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/min-adjustment.json
var require_min_adjustment = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/min-adjustment.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "minAdjustment",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "An address representing the destination of the transaction."
        },
        minAmount: {
          $ref: "laxAmount",
          description: "The minimum amount to be delivered. (This field cannot be used with destination.amount)"
        },
        tag: { $ref: "tag" }
      },
      required: ["address", "minAmount"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/source-exact-adjustment.json
var require_source_exact_adjustment = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/source-exact-adjustment.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "sourceExactAdjustment",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address to send from."
        },
        amount: {
          $ref: "laxAmount",
          description: "An exact amount to send. If the counterparty is not specified, amounts with any counterparty may be used. (This field cannot be used with source.maxAmount)"
        },
        tag: { $ref: "tag" }
      },
      required: ["address", "amount"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/destination-exact-adjustment.json
var require_destination_exact_adjustment = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/destination-exact-adjustment.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "destinationExactAdjustment",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "An address representing the destination of the transaction."
        },
        amount: {
          $ref: "laxAmount",
          description: "An exact amount to deliver to the recipient. If the counterparty is not specified, amounts with any counterparty may be used. (This field cannot be used with `destination.minAmount`.)"
        },
        tag: { $ref: "tag" }
      },
      required: ["address", "amount"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/destination-address-tag.json
var require_destination_address_tag = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/destination-address-tag.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "destinationAddressTag",
      description: "A destination address and optional tag, with no amount included. When parsing an incoming transaction, the original specification's amount is hidden to prevent misinterpretation. For the amount that the transaction delivered, see `outcome.deliveredAmount`.",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "An address representing the destination of the transaction."
        },
        tag: { $ref: "tag" }
      },
      required: ["address"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/transaction-hash.json
var require_transaction_hash = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/transaction-hash.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "transactionHash",
      link: "transaction-id",
      description: "A hash of a transaction used to identify the transaction, represented in hexadecimal.",
      type: "string",
      pattern: "^[A-F0-9]{64}$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/address.json
var require_address = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/address.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "address",
      description: "An account address on the XRP Ledger",
      type: "string",
      format: "address",
      link: "address",
      oneOf: [
        { $ref: "xAddress" },
        { $ref: "classicAddress" }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/x-address.json
var require_x_address = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/x-address.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "xAddress",
      description: "An XRP Ledger address in X-address format",
      type: "string",
      format: "xAddress",
      link: "x-address",
      pattern: "^[XT][1-9A-HJ-NP-Za-km-z]{46}$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/classic-address.json
var require_classic_address = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/classic-address.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "classicAddress",
      description: "A classic address (Account ID) for the XRP Ledger",
      type: "string",
      format: "classicAddress",
      link: "classic-address",
      pattern: "^r[1-9A-HJ-NP-Za-km-z]{24,34}$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/adjustment.json
var require_adjustment = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/adjustment.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "adjustment",
      type: "object",
      properties: {
        address: { $ref: "address" },
        amount: { $ref: "amount" },
        tag: { $ref: "tag" }
      },
      required: ["address", "amount"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/quality.json
var require_quality = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/quality.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "quality",
      description: "Ratio for incoming/outgoing transit fees.",
      type: "number",
      minimum: 1e-9,
      maximum: 4.294967295
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/amount.json
var require_amount = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/amount.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "amount",
      link: "amount",
      description: "An Amount on the XRP Ledger",
      allOf: [
        { $ref: "amountbase" },
        { required: ["value"] }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/amountbase.json
var require_amountbase = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/amountbase.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "amountbase",
      description: "Base class for amount and issue",
      type: "object",
      properties: {
        value: {
          description: "The quantity of the currency, denoted as a string so that it does not lose precision",
          $ref: "value"
        },
        currency: {
          description: 'The three-character code or hexadecimal string used to denote currencies, or "drops" for the smallest unit of XRP.',
          $ref: "currency"
        },
        counterparty: {
          description: 'The XRP Ledger address of the account that owes or is owed the funds (omitted if `currency` is "XRP" or "drops")',
          $ref: "address"
        }
      },
      additionalProperties: false,
      required: ["currency"],
      oneOf: [
        {
          properties: {
            currency: {
              not: {
                enum: ["XRP", "drops"]
              }
            }
          },
          required: ["counterparty"]
        },
        {
          properties: {
            currency: {
              enum: ["XRP", "drops"]
            }
          },
          not: {
            required: ["counterparty"]
          }
        }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/balance.json
var require_balance = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/balance.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "balance",
      description: "Balance amount",
      link: "amount",
      type: "object",
      properties: {
        value: {
          description: "The balance on the trustline",
          $ref: "signedValue"
        },
        currency: {
          description: "The three-character code or hexadecimal string used to denote currencies",
          $ref: "currency"
        },
        counterparty: {
          description: "The XRP Ledger address of the account that owes or is owed the funds.",
          $ref: "address"
        }
      },
      additionalProperties: false,
      required: ["currency", "value"],
      oneOf: [
        {
          properties: {
            currency: {
              not: {
                enum: ["XRP"]
              }
            }
          },
          required: ["counterparty"]
        },
        {
          properties: {
            currency: {
              enum: ["XRP"]
            }
          },
          not: {
            required: ["counterparty"]
          }
        }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/blob.json
var require_blob = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/blob.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "blob",
      description: "An uppercase hexadecimal string representation of a transaction",
      type: "string",
      minLength: 1,
      pattern: "^[0-9A-F]*$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/currency.json
var require_currency = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/currency.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "currency",
      description: "The three-character code or hexadecimal string used to denote currencies",
      type: "string",
      link: "currency",
      pattern: "^([a-zA-Z0-9<>(){}[\\]|?!@#$%^&*]{3}|[A-F0-9]{40}|drops)$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/signed-value.json
var require_signed_value = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/signed-value.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "signedValue",
      description: "A string representation of a floating point number",
      type: "string",
      link: "value",
      pattern: "^[-]?[0-9]*[.]?[0-9]+([eE][-+]?[0-9]+)?$"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/orderbook.json
var require_orderbook = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/orderbook.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "orderbook",
      type: "object",
      properties: {
        base: { $ref: "issue" },
        counter: { $ref: "issue" }
      },
      required: ["base", "counter"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/instructions.json
var require_instructions = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/instructions.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "instructions",
      link: "transaction-instructions",
      description: "Instructions for executing the transaction",
      type: "object",
      properties: {
        sequence: {
          description: "The initiating account's sequence number for this transaction. `sequence` and `ticketSequence` are mutually exclusive, only one of them can be set.",
          $ref: "sequence"
        },
        ticketSequence: {
          description: "The ticket sequence to be used for this transaction. `sequence` and `ticketSequence` are mutually exclusive, only one of them can be set.",
          $ref: "ticket-sequence"
        },
        fee: {
          description: "An exact fee to pay for the transaction, before multiplying for multi-signed transactions. See [Transaction Fees](#transaction-fees) for more information.",
          $ref: "value"
        },
        maxFee: {
          description: "Deprecated: Use `maxFeeXRP` in the RippleAPI constructor instead. The maximum fee to pay for this transaction. If this exceeds `maxFeeXRP`, use `maxFeeXRP` instead. See [Transaction Fees](#transaction-fees) for more information.",
          $ref: "value"
        },
        maxLedgerVersion: {
          description: "The highest ledger version that the transaction can be included in. If this option and `maxLedgerVersionOffset` are both omitted, the default is 3 greater than the current validated ledger version (equivalent to `maxLedgerVersionOffset=3`). Use `null` to not set a maximum ledger version. If not null, this must be an integer greater than 0, or one of the following strings: 'validated', 'closed', 'current'.",
          oneOf: [
            { $ref: "ledgerVersion" },
            { type: "null" }
          ]
        },
        maxLedgerVersionOffset: {
          description: "Offset from current validated ledger version to highest ledger version that the transaction can be included in.",
          type: "integer",
          minimum: 0
        },
        signersCount: {
          description: "Number of signers that can multi-sign this transaction.",
          type: "integer",
          minimum: 1
        }
      },
      additionalProperties: false,
      not: {
        anyOf: [
          {
            description: "fee and maxFee are mutually exclusive",
            required: ["fee", "maxFee"]
          },
          {
            description: "maxLedgerVersion and maxLedgerVersionOffset are mutually exclusive",
            required: ["maxLedgerVersion", "maxLedgerVersionOffset"]
          },
          {
            description: "sequence and ticketSequence are mutually exclusive",
            required: ["sequence", "ticketSequence"]
          }
        ]
      }
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/objects/settings-plus-memos.json
var require_settings_plus_memos = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/objects/settings-plus-memos.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "settingsPlusMemos",
      type: "object",
      properties: {
        defaultRipple: {
          type: "boolean",
          description: "Enable [rippling](https://xrpl.org/rippling.html) on this accounts trust lines by default. Currency issuers should enable this setting; most others should not."
        },
        depositAuth: {
          type: "boolean",
          description: "Enable [Deposit Authorization](https://xrpl.org/depositauth.html) on this account. If set, transactions cannot send value of any kind to this account unless the sender of those transactions is the account itself. (Requires the [DepositAuth amendment](https://xrpl.org/known-amendments.html#depositauth))"
        },
        disableMasterKey: {
          type: "boolean",
          description: "Disallows use of the master key to sign transactions for this account. To disable the master key, you must authorize the transaction by signing it with the master key pair. You cannot use a regular key pair or a multi-signature. You can re-enable the master key pair using a regular key pair or multi-signature. See [AccountSet](https://xrpl.org/accountset.html)."
        },
        disallowIncomingXRP: {
          type: "boolean",
          description: "Indicates that client applications should not send XRP to this account. Not enforced by rippled."
        },
        domain: {
          type: "string",
          description: "The domain that owns this account, as a hexadecimal string representing the ASCII for the domain in lowercase."
        },
        emailHash: {
          description: "Hash of an email address to be used for generating an avatar image. Conventionally, clients use Gravatar to display this image. Use `null` to clear.",
          oneOf: [
            { type: "null" },
            { $ref: "hash128" }
          ]
        },
        walletLocator: {
          description: "Transaction hash or any other 64 character hexadecimal string, that may or may not represent the result of a hash operation. Use `null` to clear.",
          oneOf: [
            { type: "null" },
            { $ref: "hash256" }
          ]
        },
        enableTransactionIDTracking: {
          type: "boolean",
          description: "Track the ID of this accounts most recent transaction."
        },
        globalFreeze: {
          type: "boolean",
          description: "Freeze all assets issued by this account."
        },
        memos: { $ref: "memos" },
        messageKey: {
          type: "string",
          description: "Public key for sending encrypted messages to this account. Conventionally, it should be a secp256k1 key, the same encryption that is used by the rest of Ripple."
        },
        noFreeze: {
          type: "boolean",
          description: "Permanently give up the ability to freeze individual trust lines. This flag can never be disabled after being enabled."
        },
        passwordSpent: {
          type: "boolean",
          description: "Indicates that the account has used its free SetRegularKey transaction."
        },
        regularKey: {
          oneOf: [
            { $ref: "address" },
            { type: "null" }
          ],
          description: "The public key of a new keypair, to use as the regular key to this account, as a base-58-encoded string in the same format as an account address. Use `null` to remove the regular key."
        },
        requireAuthorization: {
          type: "boolean",
          description: "If set, this account must individually give other users permission to hold this accounts issued tokens."
        },
        requireDestinationTag: {
          type: "boolean",
          description: "Requires incoming payments to specify a destination tag."
        },
        signers: {
          type: "object",
          description: "Settings that determine what sets of accounts can be used to sign a transaction on behalf of this account using multisigning.",
          properties: {
            threshold: {
              $ref: "uint32",
              description: "A target number for the signer weights. A multi-signature from this list is valid only if the sum weights of the signatures provided is equal or greater than this value. To delete the signers setting, use the value `0`."
            },
            weights: {
              type: "array",
              description: "Weights of signatures for each signer.",
              items: {
                type: "object",
                description: "An association of an address and a weight.",
                properties: {
                  address: { $ref: "address" },
                  weight: {
                    $ref: "uint32",
                    description: "The weight that the signature of this account counts as towards the threshold."
                  }
                },
                required: ["address", "weight"],
                additionalProperties: false
              },
              minItems: 1,
              maxItems: 8
            }
          },
          required: ["threshold"],
          additionalProperties: false
        },
        transferRate: {
          description: "The fee to charge when users transfer this accounts issuances, as the decimal amount that must be sent to deliver 1 unit. Has precision up to 9 digits beyond the decimal point. Use `null` to set no fee.",
          oneOf: [
            { type: "null" },
            { type: "number", minimum: 1, maximum: 4.294967295 }
          ]
        },
        tickSize: {
          description: "Tick size to use for offers involving a currency issued by this address. The exchange rates of those offers is rounded to this many significant digits. Valid values are 3 to 15 inclusive, or 0 to disable.",
          enum: [0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/settings.json
var require_settings = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/settings.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "settings",
      link: "settings",
      $ref: "settingsPlusMemos",
      oneOf: [
        {
          required: ["memos"],
          minProperties: 2,
          maxProperties: 2
        },
        {
          not: {
            required: ["memos"]
          },
          minProperties: 1,
          maxProperties: 1
        }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/payment.json
var require_payment = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/payment.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "payment",
      link: "payment",
      type: "object",
      properties: {
        source: {
          $ref: "sourceAdjustment",
          description: "The source of the funds to be sent."
        },
        destination: {
          $ref: "destinationAdjustment",
          description: "The destination of the funds to be sent."
        },
        paths: {
          type: "string",
          description: "The paths of trustlines and orders to use in executing the payment."
        },
        memos: { $ref: "memos" },
        invoiceID: {
          description: "A 256-bit hash that can be used to identify a particular payment.",
          $ref: "hash256"
        },
        allowPartialPayment: {
          description: "If true, this payment can deliver less than the full amount.",
          type: "boolean"
        },
        noDirectRipple: {
          description: "If true and paths are specified, the sender would like the XRP Ledger to disregard any direct paths from the source account to the destination account. This may be used to take advantage of an arbitrage opportunity or by gateways wishing to issue balances from a hot wallet to a user who has mistakenly set a trustline directly to the hot wallet.",
          type: "boolean"
        },
        limitQuality: {
          description: "Only take paths where all the conversions have an input:output ratio that is equal or better than the ratio of destination.amount:source.maxAmount.",
          type: "boolean"
        }
      },
      required: ["source", "destination"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/get-payment.json
var require_get_payment = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/get-payment.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getPayment",
      description: "A specification of a payment in a response for getTransaction or getTransactions.",
      type: "object",
      properties: {
        source: {
          $ref: "sourceAdjustment",
          description: "The source of the funds to be sent."
        },
        destination: {
          $ref: "destinationAddressTag",
          description: "The destination of the funds to be sent. Since this is a payment response, the amount is not shown here. For the amount that the transaction delivered, see `outcome.deliveredAmount`."
        },
        paths: {
          type: "string",
          description: "The paths of trustlines and orders to use in executing the payment."
        },
        memos: { $ref: "memos" },
        invoiceID: {
          description: "A 256-bit hash that can be used to identify a particular payment.",
          $ref: "hash256"
        },
        allowPartialPayment: {
          description: "If true, this payment can deliver less than the full amount.",
          type: "boolean"
        },
        noDirectRipple: {
          description: "If true and paths are specified, the sender would like the XRP Ledger to disregard any direct paths from the source account to the destination account. This may be used to take advantage of an arbitrage opportunity or by gateways wishing to issue balances from a hot wallet to a user who has mistakenly set a trustline directly to the hot wallet.",
          type: "boolean"
        },
        limitQuality: {
          description: "Only take paths where all the conversions have an input:output ratio that is equal or better than the ratio of destination.amount:source.maxAmount.",
          type: "boolean"
        }
      },
      required: ["source", "destination"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/escrow-cancellation.json
var require_escrow_cancellation = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/escrow-cancellation.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "escrowCancellation",
      link: "escrow-cancellation",
      type: "object",
      properties: {
        memos: { $ref: "memos" },
        owner: {
          $ref: "address",
          description: "The address of the owner of the escrow to cancel."
        },
        escrowSequence: {
          $ref: "sequence",
          description: "The [account sequence number](#account-sequence-number) of the [Escrow Creation](#escrow-creation) transaction for the escrow to cancel."
        }
      },
      required: ["owner", "escrowSequence"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/order-cancellation.json
var require_order_cancellation = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/order-cancellation.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "orderCancellation",
      link: "order-cancellation",
      type: "object",
      properties: {
        orderSequence: {
          $ref: "sequence",
          description: "The [account sequence number](#account-sequence-number) of the order to cancel."
        },
        memos: { $ref: "memos" }
      },
      required: ["orderSequence"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/order.json
var require_order = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/order.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "order",
      link: "order",
      type: "object",
      properties: {
        direction: {
          type: "string",
          enum: ["buy", "sell"],
          description: 'Equal to "buy" for buy orders and "sell" for sell orders.'
        },
        quantity: {
          $ref: "amount",
          description: "The amount of currency to buy or sell."
        },
        totalPrice: {
          $ref: "amount",
          description: "The total price to be paid for the `quantity` to be bought or sold."
        },
        immediateOrCancel: {
          type: "boolean",
          description: "Treat the offer as an [Immediate or Cancel order](http://en.wikipedia.org/wiki/Immediate_or_cancel). If enabled, do not create an object in the ledger that can be matched later: instead, only execute as much as can be fulfilled immediately. This cannot be used with `fillOrKill`."
        },
        fillOrKill: {
          type: "boolean",
          description: "Treat the offer as a [Fill or Kill order](http://en.wikipedia.org/wiki/Fill_or_kill). Only attempt to match existing offers in the ledger, and only do so if the entire quantity can be exchanged. This cannot be used with `immediateOrCancel`."
        },
        passive: {
          description: "If enabled, the offer does not consume offers that exactly match it, and instead becomes an Offer node in the ledger. It still consumes offers that cross it.",
          type: "boolean"
        },
        expirationTime: {
          type: "string",
          format: "date-time",
          description: "Time after which the offer is no longer active, as an [ISO 8601 date-time](https://en.wikipedia.org/wiki/ISO_8601)."
        },
        orderToReplace: {
          $ref: "sequence",
          description: "The [account sequence number](#account-sequence-number) of an order to cancel before the new order is created, effectively replacing the old order."
        },
        memos: { $ref: "memos" }
      },
      required: ["direction", "quantity", "totalPrice"],
      additionalProperties: false,
      not: {
        description: "immediateOrCancel and fillOrKill are mutually exclusive",
        required: ["immediateOrCancel", "fillOrKill"]
      }
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/escrow-execution.json
var require_escrow_execution = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/escrow-execution.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "escrowExecution",
      link: "escrow-execution",
      type: "object",
      properties: {
        memos: { $ref: "memos" },
        owner: {
          $ref: "address",
          description: "The address of the owner of the escrow to execute."
        },
        escrowSequence: {
          $ref: "sequence",
          description: "The [account sequence number](#account-sequence-number) of the [Escrow Creation](#escrow-creation) transaction for the escrow to execute."
        },
        condition: {
          type: "string",
          description: "A hex value representing a [PREIMAGE-SHA-256 crypto-condition](https://tools.ietf.org/html/draft-thomas-crypto-conditions-02#section-8.1). This must match the original `condition` from the escrow creation transaction.",
          pattern: "^[A-F0-9]{0,256}$"
        },
        fulfillment: {
          type: "string",
          description: "A hex value representing the [PREIMAGE-SHA-256 crypto-condition](https://tools.ietf.org/html/draft-thomas-crypto-conditions-02#section-8.1) fulfillment for `condition`.",
          pattern: "^[A-F0-9]+$"
        }
      },
      required: ["owner", "escrowSequence"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/escrow-creation.json
var require_escrow_creation = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/escrow-creation.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "escrowCreation",
      link: "escrow-creation",
      type: "object",
      properties: {
        amount: {
          $ref: "value",
          description: "Amount of XRP for sender to escrow."
        },
        destination: {
          $ref: "address",
          description: "Address to receive escrowed XRP."
        },
        memos: { $ref: "memos" },
        condition: {
          type: "string",
          description: "A hex value representing a [PREIMAGE-SHA-256 crypto-condition](https://tools.ietf.org/html/draft-thomas-crypto-conditions-02#section-8.1). If present, `fulfillment` is required upon execution.",
          pattern: "^[A-F0-9]{0,256}$"
        },
        allowCancelAfter: {
          type: "string",
          format: "date-time",
          description: "If present, the escrow may be cancelled after this time."
        },
        allowExecuteAfter: {
          type: "string",
          format: "date-time",
          description: "If present, the escrow can not be executed before this time."
        },
        sourceTag: {
          $ref: "tag",
          description: "Source tag."
        },
        destinationTag: {
          $ref: "tag",
          description: "Destination tag."
        }
      },
      required: ["amount", "destination"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/payment-channel-create.json
var require_payment_channel_create = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/payment-channel-create.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "paymentChannelCreate",
      link: "payment-channel-create",
      type: "object",
      properties: {
        amount: {
          $ref: "value",
          description: "Amount of XRP for sender to set aside in this channel."
        },
        destination: {
          $ref: "address",
          description: "Address to receive XRP claims against this channel."
        },
        settleDelay: {
          type: "number",
          description: "Amount of seconds the source address must wait before closing the channel if it has unclaimed XRP."
        },
        publicKey: {
          $ref: "publicKey",
          description: "Public key of the key pair the source may use to sign claims against this channel."
        },
        cancelAfter: {
          type: "string",
          format: "date-time",
          description: "Time when this channel expires. This expiration cannot be changed after creating the channel."
        },
        sourceTag: {
          $ref: "tag",
          description: "Source tag."
        },
        destinationTag: {
          $ref: "tag",
          description: "Destination tag."
        },
        memos: { $ref: "memos" }
      },
      required: ["amount", "destination", "settleDelay", "publicKey"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/payment-channel-fund.json
var require_payment_channel_fund = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/payment-channel-fund.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "paymentChannelFund",
      link: "payment-channel-fund",
      type: "object",
      properties: {
        amount: {
          $ref: "value",
          description: "Amount of XRP to fund the channel with."
        },
        channel: {
          $ref: "hash256",
          description: "256-bit hexadecimal channel identifier."
        },
        expiration: {
          type: "string",
          format: "date-time",
          description: "New expiration for this channel. (This does not change the cancelAfter expiration, if the channel has one.) Cannot move the expiration sooner than settleDelay seconds from time of the request."
        },
        memos: { $ref: "memos" }
      },
      required: ["amount", "channel"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/payment-channel-claim.json
var require_payment_channel_claim = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/payment-channel-claim.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "paymentChannelClaim",
      link: "payment-channel-claim",
      type: "object",
      properties: {
        channel: {
          $ref: "hash256",
          description: "256-bit hexadecimal channel identifier."
        },
        amount: {
          $ref: "value",
          description: "Amount of XRP authorized by this signature."
        },
        balance: {
          $ref: "value",
          description: "Total XRP balance delivered by this channel after claim is processed."
        },
        signature: {
          $ref: "signature",
          description: "Signed claim authorizing withdrawal of XRP from the channel. (Required except from the channel's source address.)"
        },
        publicKey: {
          $ref: "publicKey",
          description: "Public key of the channel. (For verifying the signature.)"
        },
        renew: {
          type: "boolean",
          description: "Clear the channel's expiration time."
        },
        close: {
          type: "boolean",
          description: "Request to close the channel. If the channel has no XRP remaining or the destination address requests it, closes the channel immediately (returning unclaimed XRP to the source address). Otherwise, sets the channel to expire after settleDelay seconds have passed."
        },
        memos: { $ref: "memos" }
      },
      required: ["channel"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/check-create.json
var require_check_create = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/check-create.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "checkCreate",
      link: "check-create",
      type: "object",
      properties: {
        destination: {
          $ref: "address",
          description: "Address of the account that can cash the check."
        },
        sendMax: {
          $ref: "laxAmount",
          description: "Amount of source currency the check is allowed to debit the sender, including transfer fees on non-XRP currencies."
        },
        destinationTag: {
          $ref: "tag",
          description: "Destination tag that identifies the reason for the check, or a hosted recipient to pay."
        },
        expiration: {
          type: "string",
          format: "date-time",
          description: "Time after which the check is no longer valid."
        },
        invoiceID: {
          $ref: "hash256",
          description: "256-bit hash, as a 64-character hexadecimal string, representing a specific reason or identifier for this check."
        },
        memos: { $ref: "memos" }
      },
      required: ["destination", "sendMax"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/check-cash.json
var require_check_cash = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/check-cash.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "checkCash",
      link: "check-cash",
      type: "object",
      properties: {
        checkID: {
          $ref: "hash256",
          description: "The ID of the Check ledger object to cash, as a 64-character hexadecimal string."
        },
        amount: {
          $ref: "laxAmount",
          description: "Redeem the Check for exactly this amount, if possible. The currency must match that of the sendMax of the corresponding CheckCreate transaction. You must provide either this field or deliverMin."
        },
        deliverMin: {
          $ref: "laxAmount",
          description: "Redeem the Check for at least this amount and for as much as possible. The currency must match that of the sendMax of the corresponding CheckCreate transaction. You must provide either this field or amount."
        },
        memos: { $ref: "memos" }
      },
      required: ["checkID"],
      oneOf: [
        { required: ["amount"] },
        { required: ["deliverMin"] }
      ],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/check-cancel.json
var require_check_cancel = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/check-cancel.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "checkCancel",
      link: "check-cancel",
      type: "object",
      properties: {
        checkID: {
          $ref: "hash256",
          description: "The ID of the Check ledger object to cancel, as a 64-character hexadecimal string."
        },
        memos: { $ref: "memos" }
      },
      required: ["checkID"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/trustline.json
var require_trustline = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/trustline.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "trustline",
      link: "trustline",
      type: "object",
      properties: {
        currency: {
          $ref: "currency",
          description: "The currency this trustline applies to."
        },
        counterparty: {
          $ref: "address",
          description: "The address of the account this trustline extends trust to."
        },
        limit: {
          $ref: "value",
          description: "The maximum amount that the owner of the trustline can be owed through the trustline."
        },
        qualityIn: {
          $ref: "quality",
          description: "Incoming balances on this trustline are valued at this ratio."
        },
        qualityOut: {
          $ref: "quality",
          description: "Outgoing balances on this trustline are valued at this ratio."
        },
        ripplingDisabled: {
          type: "boolean",
          description: "If true, payments cannot ripple through this trustline."
        },
        authorized: {
          type: "boolean",
          description: "If true, authorize the counterparty to hold issuances from this account."
        },
        frozen: {
          type: "boolean",
          description: "If true, the trustline is frozen, which means that funds can only be sent to the owner."
        },
        memos: { $ref: "memos" }
      },
      required: ["currency", "counterparty", "limit"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/deposit-preauth.json
var require_deposit_preauth = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/deposit-preauth.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "depositPreauth",
      link: "deposit-preauth",
      type: "object",
      properties: {
        authorize: {
          $ref: "address",
          description: "Address of the account that can cash the check."
        },
        unauthorize: {
          $ref: "address",
          description: "Address of the account that can cash the check."
        },
        memos: { $ref: "memos" }
      },
      oneOf: [
        { required: ["authorize"] },
        { required: ["unauthorize"] }
      ],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/specifications/account-delete.json
var require_account_delete = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/specifications/account-delete.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "accountDelete",
      link: "account-delete",
      type: "object",
      properties: {
        destination: {
          $ref: "address",
          description: "Address of an account to receive any leftover XRP after deleting the sending account. Must be a funded account in the ledger, and must not be the sending account."
        },
        destinationTag: {
          $ref: "tag",
          description: "(Optional) Arbitrary destination tag that identifies a hosted recipient or other information for the recipient of the deleted account's leftover XRP."
        },
        destinationXAddress: {
          $ref: "address",
          description: "X-address of an account to receive any leftover XRP after deleting the sending account. Must be a funded account in the ledger, and must not be the sending account."
        },
        memos: { $ref: "memos" }
      },
      anyOf: [
        {
          required: ["destination"]
        },
        {
          required: ["destinationXAddress"]
        }
      ],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/sign.json
var require_sign = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/sign.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "sign",
      type: "object",
      properties: {
        signedTransaction: {
          type: "string",
          pattern: "^[A-F0-9]+$",
          description: "The signed transaction represented as an uppercase hexadecimal string."
        },
        id: {
          $ref: "transactionHash",
          description: "The [Transaction ID](#transaction-id) of the signed transaction."
        }
      },
      required: ["signedTransaction", "id"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/submit.json
var require_submit = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/submit.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "submit",
      type: "object",
      properties: {
        resultCode: {
          type: "string",
          description: "Deprecated: Use `engine_result` instead."
        },
        resultMessage: {
          type: "string",
          description: "Deprecated: Use `engine_result_message` instead."
        },
        engine_result: {
          type: "string",
          description: "Code indicating the preliminary result of the transaction, for example `tesSUCCESS`. [List of transaction responses](https://xrpl.org/transaction-results.html)"
        },
        engine_result_code: {
          type: "integer",
          description: "Numeric code indicating the preliminary result of the transaction, directly correlated to `engine_result`"
        },
        engine_result_message: {
          type: "string",
          description: "Human-readable explanation of the transaction's preliminary result."
        },
        tx_blob: {
          type: "string",
          description: "The complete transaction in hex string format."
        },
        tx_json: {
          $ref: "tx-json",
          description: "The complete transaction in JSON format."
        }
      },
      required: ["resultCode", "resultMessage", "engine_result", "engine_result_code", "engine_result_message", "tx_blob", "tx_json"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-account-info.json
var require_get_account_info = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-account-info.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getAccountInfo",
      type: "object",
      properties: {
        sequence: {
          $ref: "sequence",
          description: "The next (smallest unused) sequence number for this account."
        },
        xrpBalance: {
          $ref: "value",
          description: "The XRP balance owned by the account."
        },
        ownerCount: {
          type: "integer",
          minimum: 0,
          description: "Number of other ledger entries (specifically, trust lines and offers) attributed to this account. This is used to calculate the total reserve required to use the account."
        },
        previousInitiatedTransactionID: {
          $ref: "hash256",
          description: "Hash value representing the most recent transaction that was initiated by this account."
        },
        previousAffectingTransactionID: {
          $ref: "hash256",
          description: "Hash value representing the most recent transaction that affected this account node directly. **Note:** This does not include changes to the accounts trust lines and offers."
        },
        previousAffectingTransactionLedgerVersion: {
          $ref: "ledgerVersion",
          description: "The ledger version that the transaction identified by the `previousAffectingTransactionID` was validated in."
        }
      },
      required: [
        "sequence",
        "xrpBalance",
        "ownerCount",
        "previousAffectingTransactionID",
        "previousAffectingTransactionLedgerVersion"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-account-objects.json
var require_get_account_objects = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-account-objects.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "AccountObjectsResponse",
      description: "Response format for account_objects",
      type: "object",
      properties: {
        account: {
          $ref: "address",
          description: "Unique address of the account this request corresponds to."
        },
        account_objects: {
          type: "array",
          items: {
            type: "object"
          },
          description: "Array of objects owned by this account. Each object is in its raw ledger format."
        },
        ledger_hash: {
          type: "string",
          description: "(May be omitted) The identifying hash of the ledger that was used to generate this response."
        },
        ledger_index: {
          $ref: "ledgerVersion",
          description: "(May be omitted) The sequence number of the ledger that was used to generate this response."
        },
        ledger_current_index: {
          $ref: "ledgerVersion",
          description: "(May be omitted) The sequence number of the ledger that was used to generate this response."
        },
        limit: {
          type: "integer",
          description: "(May be omitted) The limit that was used in this request, if any."
        },
        validated: {
          type: "boolean",
          description: "If included and set to true, the information in this request comes from a validated ledger version. Otherwise, the information is subject to change."
        }
      },
      required: ["account", "account_objects"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-balances.json
var require_get_balances = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-balances.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getBalances",
      type: "array",
      items: { $ref: "balance" }
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-balance-sheet.json
var require_get_balance_sheet = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-balance-sheet.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getBalanceSheet",
      description: "getBalanceSheet response",
      type: "object",
      properties: {
        balances: {
          type: "array",
          items: { $ref: "amount" },
          description: `Amounts issued to the "hotwallet" accounts from the request. The keys are the accounts' addresses, and the values are arrays of currency amounts they hold. The issuer (omitted from the currency amounts) is the account from the request.`
        },
        assets: {
          type: "array",
          items: { $ref: "amount" },
          description: "Total amounts held that are issued by others. For the recommended gateway configuration, there should be none."
        },
        obligations: {
          type: "array",
          items: {
            type: "object",
            required: ["currency", "value"],
            additionalProperties: false,
            properties: {
              currency: { $ref: "currency" },
              value: { $ref: "value" }
            },
            description: "An amount that is owed."
          },
          description: "Total amounts issued to accounts that are not hot wallets, as a map of currencies to the total value issued."
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-ledger.json
var require_get_ledger = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-ledger.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getLedger",
      type: "object",
      properties: {
        stateHash: {
          $ref: "hash256",
          description: "Hash of all state information in this ledger."
        },
        closeTime: {
          type: "string",
          format: "date-time",
          description: "The approximate time when this ledger was closed. This number is rounded based on the `closeTimeResolution`. If it would have been rounded to the same time as a previous ledger, the close time is recorded as 1 second later instead."
        },
        closeTimeResolution: {
          type: "integer",
          minimum: 1,
          description: "A number of seconds, indicating how much the `closeTime` could be rounded. Ledger close times are approximate so that small differences in servers clocks don't hinder consensus."
        },
        closeFlags: {
          type: "integer",
          minimum: 0,
          description: 'A bit-map of flags relating to the closing of this ledger. Currently, the ledger has only one flag defined for `closeFlags`: **sLCF_NoConsensusTime** (value 1). If this flag is enabled, it means that validators disagreed on the correct close time for the ledger, but built otherwise the same ledger, so they declared consensus while "agreeing to disagree" on the close time. In this case, the consensus ledger contains a `closeTime` value that is 1 second after that of the previous ledger. (In this case, there is no official close time, but the actual real-world close time is probably 3-6 seconds later than the specified `closeTime`.)'
        },
        ledgerHash: {
          $ref: "hash256",
          description: "Unique identifying hash of the entire ledger."
        },
        ledgerVersion: {
          $ref: "ledgerVersion",
          description: "The ledger version of this ledger."
        },
        parentLedgerHash: {
          $ref: "hash256",
          description: "Unique identifying hash of the ledger that came immediately before this one."
        },
        parentCloseTime: {
          type: "string",
          format: "date-time",
          description: "The previous ledger's recorded close time."
        },
        totalDrops: {
          $ref: "value",
          description: "Total number of drops (1/1,000,000th of an XRP) in the network, as a quoted integer. (This decreases as transaction fees cause XRP to be destroyed.)"
        },
        transactionHash: {
          $ref: "hash256",
          description: "Hash of the transaction information included in this ledger."
        },
        transactions: {
          description: "Array of all transactions that were validated in this ledger. Transactions are represented in the same format as the return value of [getTransaction](#gettransaction).",
          type: "array",
          items: {
            $ref: "getTransaction",
            description: "A transaction in the same format as the return value of [getTransaction](#gettransaction)."
          }
        },
        transactionHashes: {
          description: "An array of hashes of all transactions that were validated in this ledger.",
          type: "array",
          items: {
            $ref: "transactionHash"
          }
        },
        rawState: {
          type: "string",
          description: "A JSON string containing all state data for this ledger in rippled JSON format."
        },
        stateHashes: {
          description: "An array of hashes of all state data in this ledger.",
          type: "array",
          items: {
            $ref: "hash256"
          }
        }
      },
      required: [
        "stateHash",
        "closeTime",
        "closeTimeResolution",
        "closeFlags",
        "ledgerHash",
        "ledgerVersion",
        "parentLedgerHash",
        "parentCloseTime",
        "totalDrops",
        "transactionHash"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-orderbook.json
var require_get_orderbook = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-orderbook.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getOrderbook",
      type: "object",
      properties: {
        bids: {
          $ref: "orderbookOrders",
          description: "The buy orders in the order book."
        },
        asks: {
          $ref: "orderbookOrders",
          description: "The sell orders in the order book."
        }
      },
      required: ["bids", "asks"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-orders.json
var require_get_orders = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-orders.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getOrders",
      type: "array",
      items: {
        type: "object",
        properties: {
          specification: {
            $ref: "order",
            description: "An order specification that would create an order equivalent to the current state of this order."
          },
          properties: {
            description: "Properties of the order not in the specification.",
            type: "object",
            properties: {
              maker: {
                $ref: "address",
                description: "The address of the account that submitted the order."
              },
              sequence: {
                $ref: "sequence",
                description: "The account sequence number of the transaction that created this order."
              },
              makerExchangeRate: {
                $ref: "value",
                description: 'The exchange rate from the point of view of the account that submitted the order (also known as "quality").'
              }
            },
            required: ["maker", "sequence", "makerExchangeRate"],
            addtionalProperties: false
          }
        },
        required: ["specification", "properties"],
        additionalProperties: false
      }
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/order-change.json
var require_order_change = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/order-change.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "orderChange",
      type: "object",
      description: "A change to an order.",
      properties: {
        direction: {
          type: "string",
          enum: ["buy", "sell"],
          description: 'Equal to "buy" for buy orders and "sell" for sell orders.'
        },
        quantity: {
          $ref: "amount",
          description: "The amount to be bought or sold by the maker."
        },
        totalPrice: {
          $ref: "amount",
          description: "The total amount to be paid or received by the taker."
        },
        makerExchangeRate: {
          $ref: "value",
          description: "The exchange rate between the `quantity` currency and the `totalPrice` currency from the point of view of the maker."
        },
        sequence: {
          $ref: "sequence",
          description: "The order sequence number, used to identify the order for cancellation"
        },
        status: {
          enum: ["created", "filled", "partially-filled", "cancelled"],
          description: 'The status of the order. One of "created", "filled", "partially-filled", "cancelled".'
        },
        expirationTime: {
          type: "string",
          format: "date-time",
          description: "The time after which the order expires, if any."
        }
      },
      required: ["direction", "quantity", "totalPrice", "sequence", "status"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-payment-channel.json
var require_get_payment_channel = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-payment-channel.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getPaymentChannel",
      type: "object",
      properties: {
        account: {
          $ref: "address",
          description: "Address that created the payment channel."
        },
        destination: {
          $ref: "address",
          description: "Address to receive XRP claims against this channel."
        },
        amount: {
          $ref: "value",
          description: "The total amount of XRP funded in this channel."
        },
        balance: {
          $ref: "value",
          description: "The total amount of XRP delivered by this channel."
        },
        settleDelay: {
          type: "number",
          description: "Amount of seconds the source address must wait before closing the channel if it has unclaimed XRP."
        },
        expiration: {
          type: "string",
          format: "date-time",
          description: "Time when this channel expires."
        },
        publicKey: {
          $ref: "publicKey",
          description: "Public key of the key pair the source uses to sign claims against this channel."
        },
        cancelAfter: {
          type: "string",
          format: "date-time",
          description: "Time when this channel expires as specified at creation."
        },
        sourceTag: {
          $ref: "tag",
          description: "Source tag."
        },
        destinationTag: {
          $ref: "tag",
          description: "Destination tag."
        },
        previousAffectingTransactionID: {
          $ref: "hash256",
          description: "Hash value representing the most recent transaction that affected this payment channel."
        },
        previousAffectingTransactionLedgerVersion: {
          $ref: "ledgerVersion",
          description: "The ledger version that the transaction identified by the `previousAffectingTransactionID` was validated in."
        }
      },
      required: [
        "account",
        "destination",
        "amount",
        "balance",
        "settleDelay",
        "previousAffectingTransactionID",
        "previousAffectingTransactionLedgerVersion"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/prepare.json
var require_prepare = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/prepare.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepare",
      description: "Result of prepare function",
      type: "object",
      properties: {
        txJSON: {
          type: "string",
          description: "The prepared transaction in rippled JSON format."
        },
        instructions: {
          description: "The instructions for how to execute the transaction after adding automatic defaults.",
          type: "object",
          properties: {
            fee: {
              $ref: "value",
              description: "The fee to pay for the transaction. See [Transaction Fees](#transaction-fees) for more information. For multi-signed transactions, this fee is multiplied by (N+1), where N is the number of signatures you plan to provide."
            },
            sequence: {
              $ref: "sequence",
              description: "The initiating account's sequence number for this transaction. `sequence` and `ticketSequence` are mutually exclusive, only one of them can be set."
            },
            ticketSequence: {
              $ref: "ticket-sequence",
              description: "The initiating account's ticket sequence number for this transaction. `sequence` and `ticketSequence` are mutually exclusive, only one of them can be set."
            },
            maxLedgerVersion: {
              oneOf: [
                { $ref: "ledgerVersion" },
                { type: "null" }
              ],
              description: "The highest ledger version that the transaction can be included in. Set to `null` if there is no maximum. If not null, this must be an integer greater than 0, or one of the following strings: 'validated', 'closed', 'current'."
            }
          },
          additionalProperties: false,
          required: ["fee", "maxLedgerVersion"],
          anyOf: [
            { required: ["sequence"] },
            { required: ["ticketSequence"] }
          ]
        }
      },
      additionalProperties: false,
      required: ["txJSON", "instructions"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/ledger-event.json
var require_ledger_event = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/ledger-event.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "ledgerEvent",
      description: "A ledger event message",
      type: "object",
      properties: {
        baseFeeXRP: {
          $ref: "value",
          description: "Base fee, in XRP."
        },
        ledgerHash: {
          $ref: "hash256",
          description: "Unique hash of the ledger that was closed, as hex."
        },
        ledgerVersion: {
          $ref: "ledgerVersion",
          description: "Ledger version of the ledger that closed."
        },
        ledgerTimestamp: {
          type: "string",
          format: "date-time",
          description: "The time at which this ledger closed."
        },
        reserveBaseXRP: {
          $ref: "value",
          description: "The minimum reserve, in XRP, that is required for an account."
        },
        reserveIncrementXRP: {
          $ref: "value",
          description: "The increase in account reserve that is added for each item the account owns, such as offers or trust lines."
        },
        transactionCount: {
          type: "integer",
          minimum: 0,
          description: "Number of new transactions included in this ledger."
        },
        validatedLedgerVersions: {
          type: "string",
          description: "Range of ledgers that the server has available. This may be discontiguous."
        }
      },
      addtionalProperties: false,
      required: [
        "baseFeeXRP",
        "ledgerHash",
        "ledgerTimestamp",
        "reserveBaseXRP",
        "reserveIncrementXRP",
        "transactionCount",
        "ledgerVersion",
        "validatedLedgerVersions"
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-paths.json
var require_get_paths = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-paths.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getPaths",
      type: "array",
      items: {
        type: "object",
        properties: {
          source: {
            $ref: "sourceAdjustment",
            description: "Properties of the source of the payment."
          },
          destination: {
            $ref: "destinationAdjustment",
            description: "Properties of the destination of the payment."
          },
          paths: {
            type: "string",
            description: "The paths of trustlines and orders to use in executing the payment."
          }
        },
        required: ["source", "destination", "paths"],
        additionalProperties: false
      }
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-server-info.json
var require_get_server_info = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-server-info.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getServerInfo",
      type: "object",
      properties: {
        buildVersion: {
          type: "string",
          description: "The version number of the running rippled version."
        },
        completeLedgers: {
          type: "string",
          pattern: "[0-9,-]+",
          description: "Range expression indicating the sequence numbers of the ledger versions the local rippled has in its database. It is possible to be a disjoint sequence, e.g. 2500-5000,32570-7695432."
        },
        hostID: {
          type: "string",
          description: "On an admin request, returns the hostname of the server running the rippled instance; otherwise, returns a unique four letter word."
        },
        ioLatencyMs: {
          type: "number",
          description: "Amount of time spent waiting for I/O operations, in milliseconds. If this number is not very, very low, then the rippled server is probably having serious load issues."
        },
        load: {
          type: "object",
          description: "*(Admin only)* Detailed information about the current load state of the server.",
          properties: {
            jobTypes: {
              type: "array",
              description: "*(Admin only)* Information about the rate of different types of jobs the server is doing and how much time it spends on each.",
              items: { type: "object" }
            },
            threads: {
              type: "number",
              description: "*(Admin only)* The number of threads in the servers main job pool, performing various operations."
            }
          },
          required: ["jobTypes", "threads"]
        },
        lastClose: {
          type: "object",
          description: "Information about the last time the server closed a ledger.",
          properties: {
            convergeTimeS: {
              type: "number",
              description: "The time it took to reach a consensus for the last ledger closing, in seconds."
            },
            proposers: {
              type: "integer",
              minimum: 0,
              description: "Number of trusted validators participating in the ledger closing."
            }
          },
          required: ["convergeTimeS", "proposers"]
        },
        loadFactor: {
          type: "number",
          description: "The load factor the server is currently enforcing, as a multiplier on the base transaction fee. The load factor is determined by the highest of the individual servers load factor, clusters load factor, and the overall networks load factor."
        },
        peers: {
          type: "integer",
          minimum: 0,
          description: "How many other rippled servers the node is currently connected to."
        },
        pubkeyNode: {
          type: "string",
          description: "Public key used to verify this node for internal communications; this key is automatically generated by the server the first time it starts up."
        },
        pubkeyValidator: {
          type: "string",
          description: "*(Admin only)* Public key used by this node to sign ledger validations."
        },
        serverState: {
          type: "string",
          description: "A string indicating to what extent the server is participating in the network. See [Possible Server States](https://xrpl.org/rippled-server-states.html) for more details.",
          enum: ["disconnected", "connected", "syncing", "tracking", "full", "validating", "proposing"]
        },
        validatedLedger: {
          type: "object",
          description: "Information about the fully-validated ledger with the highest sequence number (the most recent).",
          properties: {
            age: {
              type: "integer",
              minimum: 0,
              description: "The time since the ledger was closed, in seconds."
            },
            baseFeeXRP: {
              $ref: "value",
              description: "Base fee, in XRP. This may be represented in scientific notation such as 1e-05 for 0.00005."
            },
            hash: {
              $ref: "hash256",
              description: "Unique hash for the ledger, as an uppercase hexadecimal string."
            },
            reserveBaseXRP: {
              $ref: "value",
              description: "Minimum amount of XRP necessary for every account to keep in reserve."
            },
            reserveIncrementXRP: {
              $ref: "value",
              description: "Amount of XRP added to the account reserve for each object an account owns in the ledger."
            },
            ledgerVersion: {
              type: "integer",
              minimum: 0,
              description: "Identifying ledger index of this ledger version."
            }
          },
          additionalProperties: false,
          required: ["age", "baseFeeXRP", "hash", "reserveBaseXRP", "reserveIncrementXRP", "ledgerVersion"]
        },
        validationQuorum: {
          type: "number",
          description: "Minimum number of trusted validations required to validate a ledger version. Some circumstances may cause the server to require more validations."
        }
      },
      required: ["buildVersion", "completeLedgers", "hostID", "ioLatencyMs", "lastClose", "loadFactor", "peers", "pubkeyNode", "serverState", "validatedLedger", "validationQuorum"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-settings.json
var require_get_settings = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-settings.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getSettings",
      $ref: "settingsPlusMemos",
      not: {
        required: ["memos"]
      }
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/orderbook-orders.json
var require_orderbook_orders = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/orderbook-orders.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "orderbookOrders",
      type: "array",
      items: {
        description: "An order in the order book.",
        type: "object",
        properties: {
          specification: {
            $ref: "order",
            description: "An order specification that would create an order equivalent to the current state of this order."
          },
          properties: {
            description: "Properties of the order not in the specification.",
            type: "object",
            properties: {
              maker: {
                $ref: "address",
                description: "The address of the account that submitted the order."
              },
              sequence: {
                $ref: "sequence",
                description: "The account sequence number of the transaction that created this order."
              },
              makerExchangeRate: {
                $ref: "value",
                description: 'The exchange rate from the point of view of the account that submitted the order (also known as "quality").'
              }
            },
            required: ["maker", "sequence", "makerExchangeRate"],
            addtionalProperties: false
          },
          state: {
            description: "The state of the order.",
            type: "object",
            properties: {
              fundedAmount: {
                $ref: "amount",
                description: "How much of the amount the maker would have to pay that the maker currently holds."
              },
              priceOfFundedAmount: {
                $ref: "amount",
                description: "How much the `fundedAmount` would convert to through the exchange rate of this order."
              }
            },
            required: ["fundedAmount", "priceOfFundedAmount"],
            additionalProperties: false
          },
          data: {
            description: "The raw order data. This may include `owner_funds`, `Flags`, and other fields.",
            type: "object",
            additionalProperties: true
          }
        },
        required: ["specification", "properties", "data"],
        additionalProperties: false
      }
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/outcome.json
var require_outcome = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/outcome.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "outcome",
      type: "object",
      description: "The outcome of the transaction (what effects it had).",
      properties: {
        result: {
          type: "string",
          description: "Result code returned by rippled. See [Transaction Results](https://xrpl.org/transaction-results.html) for a complete list."
        },
        timestamp: {
          type: "string",
          format: "date-time",
          description: "The timestamp when the transaction was validated. (May be missing when requesting transactions in binary mode.)"
        },
        fee: {
          $ref: "value",
          description: "The XRP fee that was charged for the transaction."
        },
        deliveredAmount: {
          $ref: "amount",
          description: "For payment transactions, it is impossible to reliably compute the actual delivered amount from the balanceChanges due to fixed precision. If the payment is not a partial payment and the transaction succeeded, the deliveredAmount should always be considered to be the amount specified in the transaction."
        },
        balanceChanges: {
          type: "object",
          additionalProperties: {
            type: "array",
            description: "Key is the XRP Ledger address; value is an array of signed amounts representing changes of balances for that address.",
            items: { $ref: "balance" }
          }
        },
        orderbookChanges: {
          type: "object",
          additionalProperties: {
            type: "array",
            description: "Key is the maker's XRP Ledger address; value is an array of changes",
            items: { $ref: "orderChange" }
          }
        },
        channelChanges: {
          type: "object",
          description: "Properties reflecting the details of the payment channel."
        },
        ledgerVersion: {
          $ref: "ledgerVersion",
          description: "The ledger version that the transaction was validated in."
        },
        indexInLedger: {
          type: "integer",
          minimum: 0,
          description: "The ordering index of the transaction in the ledger."
        }
      },
      required: [
        "result",
        "fee",
        "balanceChanges",
        "orderbookChanges",
        "ledgerVersion",
        "indexInLedger"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-transaction.json
var require_get_transaction = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-transaction.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getTransaction",
      description: "getTransaction response",
      link: "gettransaction",
      properties: {
        type: {
          $ref: "transactionType"
        },
        specification: {
          description: "A specification that would produce the same outcome as this transaction. *Exception:* For payment transactions, this omits the `destination.amount` field, to prevent misunderstanding. The structure of the specification depends on the value of the `type` field (see [Transaction Types](#transaction-types) for details). *Note:* This is **not** necessarily the same as the original specification."
        },
        outcome: {
          $ref: "outcome",
          description: "The outcome of the transaction (what effects it had)."
        },
        id: {
          $ref: "transactionHash",
          description: "A hash of the transaction that can be used to identify it."
        },
        address: {
          $ref: "address",
          description: "The address of the account that initiated the transaction."
        },
        sequence: {
          $ref: "sequence",
          description: "The account sequence number of the transaction for the account that initiated it."
        },
        rawTransaction: {
          description: "The raw transaction data as a JSON string. For advanced users only; exercise caution when interpreting this data.",
          type: "string"
        }
      },
      required: [
        "id",
        "address",
        "sequence",
        "type",
        "specification",
        "outcome"
      ],
      additionalProperties: false,
      oneOf: [
        {
          properties: {
            type: {
              enum: [
                "payment"
              ]
            },
            specification: {
              $ref: "getPayment"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "order"
              ]
            },
            specification: {
              $ref: "order"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "orderCancellation"
              ]
            },
            specification: {
              $ref: "orderCancellation"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "trustline"
              ]
            },
            specification: {
              $ref: "trustline"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "settings"
              ]
            },
            specification: {
              $ref: "getSettings"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "checkCreate"
              ]
            },
            specification: {
              $ref: "checkCreate"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "checkCancel"
              ]
            },
            specification: {
              $ref: "checkCancel"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "checkCash"
              ]
            },
            specification: {
              $ref: "checkCash"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "escrowCreation"
              ]
            },
            specification: {
              $ref: "escrowCreation"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "escrowCancellation"
              ]
            },
            specification: {
              $ref: "escrowCancellation"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "escrowExecution"
              ]
            },
            specification: {
              $ref: "escrowExecution"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "paymentChannelCreate"
              ]
            },
            specification: {
              $ref: "paymentChannelCreate"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "paymentChannelFund"
              ]
            },
            specification: {
              $ref: "paymentChannelFund"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "paymentChannelClaim"
              ]
            },
            specification: {
              $ref: "paymentChannelClaim"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "depositPreauth"
              ]
            },
            specification: {
              $ref: "depositPreauth"
            }
          }
        },
        {
          properties: {
            type: {
              enum: [
                "accountDelete"
              ]
            },
            specification: {
              $ref: "accountDelete"
            }
          }
        }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-transactions.json
var require_get_transactions = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-transactions.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getTransactions",
      type: "array",
      items: {
        $ref: "getTransaction"
      }
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/get-trustlines.json
var require_get_trustlines = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/get-trustlines.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getTrustlines",
      type: "array",
      items: {
        properties: {
          specification: {
            $ref: "trustline",
            description: "A trust line specification that would produce this trust line in its current state."
          },
          counterparty: {
            properties: {
              limit: {
                $ref: "value",
                description: "The maximum amount that the counterparty can be owed through the trust line."
              },
              ripplingDisabled: {
                type: "boolean",
                description: "If true, payments cannot ripple through this trustline."
              },
              frozen: {
                type: "boolean",
                description: "If true, the trust line is frozen, which means that funds can only be sent directly to the counterparty."
              },
              authorized: {
                type: "boolean",
                description: "If true, the counterparty authorizes this party to hold issuances from the counterparty."
              }
            },
            description: "Properties of the trustline from the perspective of the counterparty.",
            required: ["limit"],
            additionalProperties: false
          },
          state: {
            properties: {
              balance: {
                $ref: "signedValue",
                description: "The balance on the trust line, representing which party owes the other and by how much."
              }
            },
            description: "Non-settings details of the trust line's state.",
            required: ["balance"],
            additionalProperties: false
          }
        },
        required: ["specification", "counterparty", "state"],
        additionalProperties: false
      }
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/sign-payment-channel-claim.json
var require_sign_payment_channel_claim = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/sign-payment-channel-claim.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "signPaymentChannelClaim",
      type: "string",
      $ref: "signature",
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/output/verify-payment-channel-claim.json
var require_verify_payment_channel_claim = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/output/verify-payment-channel-claim.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "verifyPaymentChannelClaim",
      type: "boolean",
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-balances.json
var require_get_balances2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-balances.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getBalancesParameters",
      description: "Parameters for getBalances",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account to get balances for."
        },
        options: {
          description: "Options to filter and determine which balances to return.",
          properties: {
            counterparty: {
              $ref: "address",
              description: "Only return balances with this counterparty."
            },
            currency: {
              $ref: "currency",
              description: "Only return balances for this currency."
            },
            limit: {
              type: "integer",
              minimum: 1,
              description: "Return at most this many balances."
            },
            ledgerVersion: {
              $ref: "ledgerVersion",
              description: "Return balances as they were in this historical ledger version."
            }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false,
      required: ["address"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-balance-sheet.json
var require_get_balance_sheet2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-balance-sheet.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getBalanceSheetParameters",
      description: "Parameters for getBalanceSheet",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The XRP Ledger address of the account to get the balance sheet of."
        },
        options: {
          properties: {
            excludeAddresses: {
              type: "array",
              items: { $ref: "address" },
              uniqueItems: true,
              description: "Addresses to exclude from the balance totals."
            },
            ledgerVersion: {
              $ref: "ledgerVersion",
              description: "Get the balance sheet as of this historical ledger version."
            }
          },
          description: "Options to determine how the balances are calculated.",
          additionalProperties: false
        }
      },
      additionalProperties: false,
      required: ["address"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-ledger.json
var require_get_ledger2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-ledger.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getLedgerParameters",
      description: "Parameters for getLedger",
      type: "object",
      properties: {
        options: {
          description: "Options affecting what ledger and how much data to return.",
          properties: {
            ledgerHash: {
              type: "string",
              description: "Get ledger data for this historical ledger hash."
            },
            ledgerVersion: {
              $ref: "ledgerVersion",
              description: "Get ledger data for this historical ledger version."
            },
            includeAllData: {
              type: "boolean",
              description: "Include the details of the transactions or state information if `includeTransactions` or `includeState` is set."
            },
            includeTransactions: {
              type: "boolean",
              description: "Return an array of transactions in this ledger. By default, provides the identifying hashes for each transaction. If `includeAllData` is true, include the entire transaction JSON for each transaction instead."
            },
            includeState: {
              type: "boolean",
              description: "Return an array of state data in this ledger. By default, provides the identifying hashes of state data. If `includeAllData` is true, return the state data in JSON form instead. **Admin required:** This is a very large amount of data."
            }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-orders.json
var require_get_orders2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-orders.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getOrdersParameters",
      description: "Parameters for getOrders",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The XRP Ledger address of the account to get open orders for."
        },
        options: {
          description: "Options that determine what orders to return.",
          properties: {
            limit: {
              type: "integer",
              minimum: 1,
              description: "Return at most this many orders."
            },
            ledgerVersion: {
              $ref: "ledgerVersion",
              description: "Return orders as of this historical ledger version."
            }
          },
          additionalProperties: false
        }
      },
      required: ["address"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-orderbook.json
var require_get_orderbook2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-orderbook.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getOrderbookParameters",
      description: "Parameters for getOrderbook",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "Address of an account to use as point-of-view. (This affects which unfunded offers are returned.)"
        },
        orderbook: {
          $ref: "orderbook",
          description: "The order book to get."
        },
        options: {
          description: "Options to determine what to return.",
          properties: {
            limit: {
              type: "integer",
              minimum: 1,
              description: "Return at most this many orders from the order book."
            },
            ledgerVersion: {
              $ref: "ledgerVersion",
              description: "Return the order book as of this historical ledger version."
            }
          },
          additionalProperties: false
        }
      },
      required: ["address", "orderbook"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-paths.json
var require_get_paths2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-paths.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getPathsParameters",
      type: "object",
      properties: {
        pathfind: {
          description: "Specification of a pathfind request.",
          properties: {
            source: {
              description: "Properties of the source of funds.",
              type: "object",
              properties: {
                address: {
                  $ref: "address",
                  description: "The XRP Ledger address of the planned sender."
                },
                amount: {
                  $ref: "laxAmount",
                  description: "The amount of funds to send."
                },
                currencies: {
                  description: "An array of currencies (with optional counterparty) that may be used in the payment paths.",
                  type: "array",
                  items: {
                    description: "A currency with optional counterparty.",
                    type: "object",
                    properties: {
                      currency: { $ref: "currency" },
                      counterparty: {
                        $ref: "address",
                        description: "The counterparty for the currency; if omitted any counterparty may be used."
                      }
                    },
                    required: ["currency"],
                    additionalProperties: false
                  },
                  uniqueItems: true
                }
              },
              not: {
                required: ["amount", "currencies"]
              },
              additionalProperties: false,
              required: ["address"]
            },
            destination: {
              description: "Properties of the destination of funds.",
              type: "object",
              properties: {
                address: {
                  $ref: "address",
                  description: "An address representing the destination of the transaction."
                },
                amount: {
                  $ref: "laxLaxAmount",
                  description: "The amount to be received by the receiver (`value` may be ommitted if a source amount is specified)."
                }
              },
              required: ["address", "amount"],
              additionalProperties: false
            }
          },
          required: ["source", "destination"],
          additionalProperties: false
        }
      },
      additionalProperties: false,
      required: ["pathfind"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-payment-channel.json
var require_get_payment_channel2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-payment-channel.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getPaymentChannelParameters",
      description: "Parameters for getPaymentChannel",
      type: "object",
      properties: {
        id: {
          $ref: "hash256",
          description: "256-bit hexadecimal channel identifier."
        }
      },
      additionalProperties: false,
      required: ["id"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/api-options.json
var require_api_options = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/api-options.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "api-options",
      type: "object",
      properties: {
        trace: {
          type: "boolean",
          description: "If true, log rippled requests and responses to stdout."
        },
        feeCushion: {
          type: "number",
          minimum: 1,
          description: "Factor to multiply estimated fee by to provide a cushion in case the required fee rises during submission of a transaction. Defaults to `1.2`."
        },
        maxFeeXRP: {
          type: "string",
          description: "Maximum fee to use with transactions, in XRP. Must be a string-encoded number. Defaults to `'2'`."
        },
        server: {
          type: "string",
          description: "URI for rippled websocket port to connect to. Must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`.",
          format: "uri",
          pattern: "^(wss?|wss?\\+unix)://"
        },
        proxy: {
          format: "uri",
          description: "URI for HTTP/HTTPS proxy to use to connect to the rippled server."
        },
        timeout: {
          type: "integer",
          description: "Request timeout in milliseconds before considering a request to have failed. See also: connectionTimeout.",
          minimum: 1
        },
        connectionTimeout: {
          type: "integer",
          description: "Connection timeout, in milliseconds, before considering connect() to have failed.",
          minimum: 1
        },
        proxyAuthorization: {
          type: "string",
          description: "Username and password for HTTP basic authentication to the proxy in the format **username:password**."
        },
        authorization: {
          type: "string",
          description: "Username and password for HTTP basic authentication to the rippled server in the format **username:password**."
        },
        trustedCertificates: {
          type: "array",
          description: "Array of PEM-formatted SSL certificates to trust when connecting to a proxy. This is useful if you want to use a self-signed certificate on the proxy server. Note: Each element must contain a single certificate; concatenated certificates are not valid.",
          items: {
            type: "string",
            description: "A PEM-formatted SSL certificate to trust when connecting to a proxy."
          }
        },
        key: {
          type: "string",
          description: "A string containing the private key of the client in PEM format. (Can be an array of keys)."
        },
        passphrase: {
          type: "string",
          description: "The passphrase for the private key of the client."
        },
        certificate: {
          type: "string",
          description: "A string containing the certificate key of the client in PEM format. (Can be an array of certificates)."
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-settings.json
var require_get_settings2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-settings.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getSettingsParameters",
      description: "Parameters for getSettings",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account to get the settings of."
        },
        options: {
          description: "Options that affect what to return.",
          properties: {
            ledgerVersion: {
              $ref: "ledgerVersion",
              description: "Get the settings as of this historical ledger version."
            }
          },
          additionalProperties: false
        }
      },
      required: ["address"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-account-info.json
var require_get_account_info2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-account-info.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getAccountInfoParameters",
      description: "Parameters for getAccountInfo",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account to get the account info of."
        },
        options: {
          description: "Options that affect what to return.",
          properties: {
            ledgerVersion: {
              $ref: "ledgerVersion",
              description: "Get the account info as of this historical ledger version."
            }
          },
          additionalProperties: false
        }
      },
      required: ["address"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-account-objects.json
var require_get_account_objects2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-account-objects.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getAccountObjectsOptions",
      description: "Request options for getAccountObjects",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account to get the account objects of."
        },
        options: {
          description: "Options that affect what to return.",
          properties: {
            type: {
              type: "string",
              enum: [
                "check",
                "escrow",
                "offer",
                "payment_channel",
                "signer_list",
                "state"
              ],
              description: "(Optional) Filter results to include only this type of ledger object. The valid types are: `check`, `escrow`, `offer`, `payment_channel`, `signer_list`, and `state` (trust line)."
            },
            ledgerHash: {
              type: "string",
              description: "(Optional) A 20-byte hex string for the ledger version to use."
            },
            ledgerIndex: {
              oneOf: [
                {
                  $ref: "ledgerVersion"
                },
                {
                  type: "string"
                }
              ],
              description: "(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically."
            },
            limit: {
              type: "integer",
              minimum: 1,
              description: "(Optional) The maximum number of objects to include in the results."
            }
          },
          additionalProperties: false
        }
      },
      required: ["address"],
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-transaction.json
var require_get_transaction2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-transaction.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getTransactionParameters",
      description: "Parameters for getTransaction",
      type: "object",
      properties: {
        id: { $ref: "transactionHash" },
        options: {
          description: "Options to limit the ledger versions to search or include raw transaction data.",
          properties: {
            minLedgerVersion: {
              $ref: "ledgerVersion",
              description: "The lowest ledger version to search. This must be an integer greater than 0, or one of the following strings: 'validated', 'closed', 'current'."
            },
            maxLedgerVersion: {
              $ref: "ledgerVersion",
              description: "The highest ledger version to search. This must be an integer greater than 0, or one of the following strings: 'validated', 'closed', 'current'."
            },
            includeRawTransaction: {
              description: "Include raw transaction data. For advanced users; exercise caution when interpreting this data."
            }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false,
      required: ["id"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-transactions.json
var require_get_transactions2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-transactions.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getTransactionsParameters",
      description: "Parameters for getTransactions",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account to get transactions for."
        },
        options: {
          description: "Options to filter the resulting transactions.",
          properties: {
            start: {
              $ref: "hash256",
              description: "If specified, start the results from this transaction. You cannot use `start` with `minLedgerVersion` or `maxLedgerVersion`. When `start` is specified, these ledger versions are determined internally."
            },
            limit: {
              type: "integer",
              minimum: 1,
              description: "If specified, return at most this many transactions."
            },
            minLedgerVersion: {
              $ref: "ledgerVersion",
              description: "Return only transactions in this ledger version or higher."
            },
            maxLedgerVersion: {
              $ref: "ledgerVersion",
              description: "Return only transactions in this ledger version or lower."
            },
            earliestFirst: {
              type: "boolean",
              description: "If true, sort transactions so that the earliest ones come first. By default, the newest transactions come first."
            },
            excludeFailures: {
              type: "boolean",
              description: "If true, the result omits transactions that did not succeed."
            },
            initiated: {
              type: "boolean",
              description: "If true, return only transactions initiated by the account specified by `address`. If false, return only transactions not initiated by the account specified by `address`."
            },
            counterparty: {
              $ref: "address",
              description: "If provided, only return transactions with this account as a counterparty to the transaction."
            },
            types: {
              type: "array",
              items: { $ref: "transactionType" },
              description: "Only return transactions of the specified [Transaction Types](#transaction-types)."
            },
            includeRawTransactions: {
              description: "Include raw transaction data. For advanced users; exercise caution when interpreting this data. "
            },
            binary: {
              type: "boolean",
              description: "If true, return transactions in binary format rather than JSON."
            }
          },
          additionalProperties: false,
          not: {
            anyOf: [
              { required: ["start", "minLedgerVersion"] },
              { required: ["start", "maxLedgerVersion"] }
            ]
          }
        }
      },
      additionalProperties: false,
      required: ["address"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/get-trustlines.json
var require_get_trustlines2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/get-trustlines.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "getTrustlinesParameters",
      description: "Parameters for getTrustlines",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account to get trustlines for."
        },
        options: {
          description: "Options to filter and determine which trustlines to return.",
          properties: {
            counterparty: {
              $ref: "address",
              description: "Only return trustlines with this counterparty."
            },
            currency: {
              $ref: "currency",
              description: "Only return trustlines for this currency."
            },
            limit: {
              type: "integer",
              minimum: 1,
              description: "Return at most this many trustlines."
            },
            ledgerVersion: {
              $ref: "ledgerVersion",
              description: "Return trustlines as they were in this historical ledger version."
            }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false,
      required: ["address"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-payment.json
var require_prepare_payment = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-payment.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "preparePaymentParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        payment: {
          $ref: "payment",
          description: "The specification of the payment to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "payment"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-order.json
var require_prepare_order = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-order.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareOrderParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        order: {
          $ref: "order",
          description: "The specification of the order to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "order"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-trustline.json
var require_prepare_trustline = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-trustline.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareTrustlineParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        trustline: {
          $ref: "trustline",
          description: "The specification of the trustline to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "trustline"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-order-cancellation.json
var require_prepare_order_cancellation = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-order-cancellation.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareOrderCancellationParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        orderCancellation: {
          $ref: "orderCancellation",
          description: "The specification of the order cancellation to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "orderCancellation"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-settings.json
var require_prepare_settings = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-settings.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareSettingsParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        settings: {
          $ref: "settings",
          description: "The specification of the settings to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "settings"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-escrow-creation.json
var require_prepare_escrow_creation = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-escrow-creation.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareEscrowCreationParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        escrowCreation: {
          $ref: "escrowCreation",
          description: "The specification of the escrow creation to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "escrowCreation"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-escrow-cancellation.json
var require_prepare_escrow_cancellation = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-escrow-cancellation.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareEscrowCancellationParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        escrowCancellation: {
          $ref: "escrowCancellation",
          description: "The specification of the escrow cancellation to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "escrowCancellation"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-escrow-execution.json
var require_prepare_escrow_execution = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-escrow-execution.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareEscrowExecutionParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        escrowExecution: {
          $ref: "escrowExecution",
          description: "The specification of the escrow execution to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "escrowExecution"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-payment-channel-create.json
var require_prepare_payment_channel_create = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-payment-channel-create.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "preparePaymentChannelCreateParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        paymentChannelCreate: {
          $ref: "paymentChannelCreate",
          description: "The specification of the payment channel to create."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "paymentChannelCreate"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-payment-channel-fund.json
var require_prepare_payment_channel_fund = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-payment-channel-fund.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "preparePaymentChannelFundParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        paymentChannelFund: {
          $ref: "paymentChannelFund",
          description: "The channel to fund, and the details of how to fund it."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "paymentChannelFund"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-payment-channel-claim.json
var require_prepare_payment_channel_claim = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-payment-channel-claim.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "preparePaymentChannelClaimParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        paymentChannelClaim: {
          $ref: "paymentChannelClaim",
          description: "Details of the channel and claim."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "paymentChannelClaim"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-check-create.json
var require_prepare_check_create = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-check-create.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareCheckCreateParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        checkCreate: {
          $ref: "checkCreate",
          description: "The specification of the Check create creation to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "checkCreate"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-check-cash.json
var require_prepare_check_cash = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-check-cash.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareCheckCashParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        checkCash: {
          $ref: "checkCash",
          description: "The specification of the Check cash to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "checkCash"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-check-cancel.json
var require_prepare_check_cancel = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-check-cancel.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareCheckCancelParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        checkCancel: {
          $ref: "checkCancel",
          description: "The specification of the Check cancellation to prepare."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "checkCancel"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-ticket-create.json
var require_prepare_ticket_create = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/prepare-ticket-create.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "prepareTicketParameters",
      type: "object",
      properties: {
        address: {
          $ref: "address",
          description: "The address of the account that is creating the transaction."
        },
        ticketCount: {
          type: "number",
          description: "The number of tickets to be created."
        },
        instructions: { $ref: "instructions" }
      },
      additionalProperties: false,
      required: ["address", "ticketCount"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/compute-ledger-hash.json
var require_compute_ledger_hash = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/compute-ledger-hash.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "computeLedgerHashParameters",
      type: "object",
      properties: {
        ledger: {
          $ref: "getLedger",
          description: "The ledger header to hash."
        }
      },
      additionalProperties: false,
      required: ["ledger"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/sign.json
var require_sign2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/sign.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "signParameters",
      type: "object",
      properties: {
        txJSON: {
          type: "string",
          description: "Transaction represented as a JSON string in rippled format."
        },
        secret: {
          type: "string",
          format: "secret",
          description: "The secret of the account that is initiating the transaction. (This field cannot be used with keypair)."
        },
        keypair: {
          type: "object",
          properties: {
            privateKey: {
              type: "privateKey",
              description: "The uppercase hexadecimal representation of the secp256k1 or Ed25519 private key. Ed25519 keys are prefixed with 0xED. You can read about how keys are derived [here](https://xrpl.org/cryptographic-keys.html)."
            },
            publicKey: {
              type: "publicKey",
              description: "The uppercase hexadecimal representation of the secp256k1 or Ed25519 public key. Ed25519 keys are prefixed with 0xED. You can read about how keys are derived [here](https://xrpl.org/cryptographic-keys.html)."
            }
          },
          description: "The private and public key of the account that is initiating the transaction. (This field cannot be used with secret).",
          required: ["privateKey", "publicKey"],
          additionalProperties: false
        },
        options: {
          type: "object",
          description: "Options that control the type of signature to create.",
          properties: {
            signAs: {
              $ref: "address",
              description: "The account that the signature should count for in multisigning."
            }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false,
      required: ["txJSON"],
      oneOf: [
        {
          required: ["secret"],
          not: { required: ["keypair"] }
        },
        {
          required: ["keypair"],
          not: { required: ["secret"] }
        }
      ]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/submit.json
var require_submit2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/submit.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "submitParameters",
      type: "object",
      properties: {
        signedTransaction: {
          $ref: "blob",
          description: "A signed transaction as returned by [sign](#sign)."
        },
        failHard: {
          type: "boolean",
          description: "If `true`, and the transaction fails locally, do not retry or relay the transaction to other servers. Defaults to `false`."
        }
      },
      additionalProperties: false,
      required: ["signedTransaction"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/generate-address.json
var require_generate_address = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/generate-address.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "generateAddressParameters",
      type: "object",
      properties: {
        options: {
          type: "object",
          description: "Options to control how the address and secret are generated.",
          properties: {
            entropy: {
              type: "array",
              items: {
                type: "integer",
                minimum: 0,
                maximum: 255
              },
              description: "The entropy to use to generate the seed. Must be an array of length 16 with values from 0-255 (16 bytes of entropy)"
            },
            algorithm: {
              type: "string",
              enum: ["ecdsa-secp256k1", "ed25519"],
              description: "The digital signature algorithm to generate an address for. Can be `ecdsa-secp256k1` (default) or `ed25519`."
            },
            test: {
              type: "boolean",
              description: "Specifies whether the address is intended for use on a test network such as Testnet or Devnet. If `true`, the address should only be used for testing, and starts with `T`. If `false`, the address should only be used on Mainnet, and starts with `X`."
            },
            includeClassicAddress: {
              type: "boolean",
              description: "If `true`, also return the classic address."
            }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/sign-payment-channel-claim.json
var require_sign_payment_channel_claim2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/sign-payment-channel-claim.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "signPaymentChannelClaimParameters",
      type: "object",
      properties: {
        channel: {
          $ref: "hash256",
          description: "256-bit hexadecimal channel identifier."
        },
        amount: {
          $ref: "value",
          description: "Amount of XRP authorized by the claim."
        },
        privateKey: {
          $ref: "publicKey",
          description: "The private key to sign the payment channel claim."
        }
      },
      additionalProperties: false,
      required: ["channel", "amount", "privateKey"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/verify-payment-channel-claim.json
var require_verify_payment_channel_claim2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/verify-payment-channel-claim.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "verifyPaymentChannelClaimParameters",
      type: "object",
      properties: {
        channel: {
          $ref: "hash256",
          description: "256-bit hexadecimal channel identifier."
        },
        amount: {
          $ref: "value",
          description: "Amount of XRP authorized by the claim."
        },
        signature: {
          $ref: "signature",
          description: "Signature of this claim."
        },
        publicKey: {
          $ref: "publicKey",
          description: "Public key of the channel's sender"
        }
      },
      additionalProperties: false,
      required: ["channel", "amount", "signature", "publicKey"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schemas/input/combine.json
var require_combine = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schemas/input/combine.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-04/schema#",
      title: "combineParameters",
      type: "object",
      properties: {
        signedTransactions: {
          type: "array",
          description: "An array of signed transactions (from the output of [sign](#sign)) to combine.",
          items: {
            type: "string",
            pattern: "^[A-F0-9]+$",
            description: "A single-signed transaction represented as an uppercase hexadecimal string (from the output of [sign](#sign))"
          },
          minLength: 1
        }
      },
      additionalProperties: false,
      required: ["signedTransactions"]
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/schema-validator.js
var require_schema_validator = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/schema-validator.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidAddress = exports.isValidSecret = exports.schemaValidate = void 0;
    var _ = __importStar(require_lodash());
    var assert = __importStar(require_assert());
    var { Validator } = require_lib2();
    var errors_1 = require_errors();
    var ripple_address_codec_1 = require_dist4();
    var utils_1 = require_utils4();
    Object.defineProperty(exports, "isValidSecret", { enumerable: true, get: function() {
      return utils_1.isValidSecret;
    } });
    function loadSchemas() {
      const schemas = [
        require_tx_json(),
        require_transaction_type(),
        require_hash128(),
        require_hash256(),
        require_sequence(),
        require_ticket_sequence(),
        require_signature(),
        require_issue(),
        require_ledger_version(),
        require_max_adjustment(),
        require_memo(),
        require_memos(),
        require_public_key(),
        require_private_key(),
        require_uint32(),
        require_value(),
        require_source_adjustment(),
        require_destination_adjustment(),
        require_tag(),
        require_lax_amount(),
        require_lax_lax_amount(),
        require_min_adjustment(),
        require_source_exact_adjustment(),
        require_destination_exact_adjustment(),
        require_destination_address_tag(),
        require_transaction_hash(),
        require_address(),
        require_x_address(),
        require_classic_address(),
        require_adjustment(),
        require_quality(),
        require_amount(),
        require_amountbase(),
        require_balance(),
        require_blob(),
        require_currency(),
        require_signed_value(),
        require_orderbook(),
        require_instructions(),
        require_settings_plus_memos(),
        require_settings(),
        require_payment(),
        require_get_payment(),
        require_escrow_cancellation(),
        require_order_cancellation(),
        require_order(),
        require_escrow_execution(),
        require_escrow_creation(),
        require_payment_channel_create(),
        require_payment_channel_fund(),
        require_payment_channel_claim(),
        require_check_create(),
        require_check_cash(),
        require_check_cancel(),
        require_trustline(),
        require_deposit_preauth(),
        require_account_delete(),
        require_sign(),
        require_submit(),
        require_get_account_info(),
        require_get_account_objects(),
        require_get_balances(),
        require_get_balance_sheet(),
        require_get_ledger(),
        require_get_orderbook(),
        require_get_orders(),
        require_order_change(),
        require_get_payment_channel(),
        require_prepare(),
        require_ledger_event(),
        require_get_paths(),
        require_get_server_info(),
        require_get_settings(),
        require_orderbook_orders(),
        require_outcome(),
        require_get_transaction(),
        require_get_transactions(),
        require_get_trustlines(),
        require_sign_payment_channel_claim(),
        require_verify_payment_channel_claim(),
        require_get_balances2(),
        require_get_balance_sheet2(),
        require_get_ledger2(),
        require_get_orders2(),
        require_get_orderbook2(),
        require_get_paths2(),
        require_get_payment_channel2(),
        require_api_options(),
        require_get_settings2(),
        require_get_account_info2(),
        require_get_account_objects2(),
        require_get_transaction2(),
        require_get_transactions2(),
        require_get_trustlines2(),
        require_prepare_payment(),
        require_prepare_order(),
        require_prepare_trustline(),
        require_prepare_order_cancellation(),
        require_prepare_settings(),
        require_prepare_escrow_creation(),
        require_prepare_escrow_cancellation(),
        require_prepare_escrow_execution(),
        require_prepare_payment_channel_create(),
        require_prepare_payment_channel_fund(),
        require_prepare_payment_channel_claim(),
        require_prepare_check_create(),
        require_prepare_check_cash(),
        require_prepare_check_cancel(),
        require_prepare_ticket_create(),
        require_compute_ledger_hash(),
        require_sign2(),
        require_submit2(),
        require_generate_address(),
        require_sign_payment_channel_claim2(),
        require_verify_payment_channel_claim2(),
        require_combine()
      ];
      const titles = schemas.map((schema) => schema.title);
      const duplicates = Object.keys(_.pickBy(_.countBy(titles), (count) => count > 1));
      assert.ok(duplicates.length === 0, "Duplicate schemas for: " + duplicates);
      const validator = new Validator();
      validator.customFormats.xAddress = function(instance) {
        if (instance == null) {
          return true;
        }
        return ripple_address_codec_1.isValidXAddress(instance);
      };
      validator.customFormats.classicAddress = function(instance) {
        if (instance == null) {
          return true;
        }
        return isValidAddress(instance);
      };
      validator.customFormats.secret = function(instance) {
        if (instance == null) {
          return true;
        }
        return utils_1.isValidSecret(instance);
      };
      schemas.forEach((schema) => validator.addSchema(schema, "/" + schema.title));
      return validator;
    }
    var schemaValidator = loadSchemas();
    function schemaValidate(schemaName, object) {
      const schema = schemaValidator.getSchema("/" + schemaName);
      if (schema == null) {
        throw new errors_1.ValidationError("no schema for " + schemaName);
      }
      const result = schemaValidator.validate(object, schema);
      if (!result.valid) {
        throw new errors_1.ValidationError(result.errors.join());
      }
    }
    exports.schemaValidate = schemaValidate;
    function isValidAddress(address) {
      return ripple_address_codec_1.isValidXAddress(address) || ripple_address_codec_1.isValidClassicAddress(address);
    }
    exports.isValidAddress = isValidAddress;
  }
});

// node_modules/ripple-lib/dist/npm/common/validate.js
var require_validate = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/validate.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tx_json = exports.instructions = exports.apiOptions = exports.verifyPaymentChannelClaim = exports.signPaymentChannelClaim = exports.generateAddress = exports.computeLedgerHash = exports.submit = exports.combine = exports.sign = exports.prepareTicketCreate = exports.prepareCheckCancel = exports.prepareCheckCash = exports.prepareCheckCreate = exports.preparePaymentChannelClaim = exports.preparePaymentChannelFund = exports.preparePaymentChannelCreate = exports.prepareEscrowExecution = exports.prepareEscrowCancellation = exports.prepareEscrowCreation = exports.prepareSettings = exports.prepareTrustline = exports.prepareOrderCancellation = exports.prepareOrder = exports.preparePayment = exports.getLedger = exports.getPaymentChannel = exports.getTransaction = exports.getOrderbook = exports.getOrders = exports.getBalanceSheet = exports.getBalances = exports.getTrustlines = exports.getAccountInfo = exports.getSettings = exports.getTransactions = exports.getPaths = void 0;
    var _ = __importStar(require_lodash());
    var errors_1 = require_errors();
    var schema_validator_1 = require_schema_validator();
    function error(text) {
      return new errors_1.ValidationError(text);
    }
    function validateLedgerRange(options) {
      if (options != null && options.minLedgerVersion != null && options.maxLedgerVersion != null) {
        if (Number(options.minLedgerVersion) > Number(options.maxLedgerVersion)) {
          throw error("minLedgerVersion must not be greater than maxLedgerVersion");
        }
      }
    }
    function validateOptions(schema, instance) {
      schema_validator_1.schemaValidate(schema, instance);
      validateLedgerRange(instance.options);
    }
    exports.getPaths = _.partial(schema_validator_1.schemaValidate, "getPathsParameters");
    exports.getTransactions = _.partial(validateOptions, "getTransactionsParameters");
    exports.getSettings = _.partial(validateOptions, "getSettingsParameters");
    exports.getAccountInfo = _.partial(validateOptions, "getAccountInfoParameters");
    exports.getTrustlines = _.partial(validateOptions, "getTrustlinesParameters");
    exports.getBalances = _.partial(validateOptions, "getBalancesParameters");
    exports.getBalanceSheet = _.partial(validateOptions, "getBalanceSheetParameters");
    exports.getOrders = _.partial(validateOptions, "getOrdersParameters");
    exports.getOrderbook = _.partial(validateOptions, "getOrderbookParameters");
    exports.getTransaction = _.partial(validateOptions, "getTransactionParameters");
    exports.getPaymentChannel = _.partial(validateOptions, "getPaymentChannelParameters");
    exports.getLedger = _.partial(validateOptions, "getLedgerParameters");
    exports.preparePayment = _.partial(schema_validator_1.schemaValidate, "preparePaymentParameters");
    exports.prepareOrder = _.partial(schema_validator_1.schemaValidate, "prepareOrderParameters");
    exports.prepareOrderCancellation = _.partial(schema_validator_1.schemaValidate, "prepareOrderCancellationParameters");
    exports.prepareTrustline = _.partial(schema_validator_1.schemaValidate, "prepareTrustlineParameters");
    exports.prepareSettings = _.partial(schema_validator_1.schemaValidate, "prepareSettingsParameters");
    exports.prepareEscrowCreation = _.partial(schema_validator_1.schemaValidate, "prepareEscrowCreationParameters");
    exports.prepareEscrowCancellation = _.partial(schema_validator_1.schemaValidate, "prepareEscrowCancellationParameters");
    exports.prepareEscrowExecution = _.partial(schema_validator_1.schemaValidate, "prepareEscrowExecutionParameters");
    exports.preparePaymentChannelCreate = _.partial(schema_validator_1.schemaValidate, "preparePaymentChannelCreateParameters");
    exports.preparePaymentChannelFund = _.partial(schema_validator_1.schemaValidate, "preparePaymentChannelFundParameters");
    exports.preparePaymentChannelClaim = _.partial(schema_validator_1.schemaValidate, "preparePaymentChannelClaimParameters");
    exports.prepareCheckCreate = _.partial(schema_validator_1.schemaValidate, "prepareCheckCreateParameters");
    exports.prepareCheckCash = _.partial(schema_validator_1.schemaValidate, "prepareCheckCashParameters");
    exports.prepareCheckCancel = _.partial(schema_validator_1.schemaValidate, "prepareCheckCancelParameters");
    exports.prepareTicketCreate = _.partial(schema_validator_1.schemaValidate, "prepareTicketParameters");
    exports.sign = _.partial(schema_validator_1.schemaValidate, "signParameters");
    exports.combine = _.partial(schema_validator_1.schemaValidate, "combineParameters");
    exports.submit = _.partial(schema_validator_1.schemaValidate, "submitParameters");
    exports.computeLedgerHash = _.partial(schema_validator_1.schemaValidate, "computeLedgerHashParameters");
    exports.generateAddress = _.partial(schema_validator_1.schemaValidate, "generateAddressParameters");
    exports.signPaymentChannelClaim = _.partial(schema_validator_1.schemaValidate, "signPaymentChannelClaimParameters");
    exports.verifyPaymentChannelClaim = _.partial(schema_validator_1.schemaValidate, "verifyPaymentChannelClaimParameters");
    exports.apiOptions = _.partial(schema_validator_1.schemaValidate, "api-options");
    exports.instructions = _.partial(schema_validator_1.schemaValidate, "instructions");
    exports.tx_json = _.partial(schema_validator_1.schemaValidate, "tx-json");
  }
});

// node_modules/ripple-lib/dist/npm/common/serverinfo.js
var require_serverinfo = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/serverinfo.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFee = exports.getServerInfo = void 0;
    var utils_1 = require_utils4();
    var bignumber_js_1 = __importDefault(require_bignumber());
    function renameKeys(object, mapping) {
      Object.entries(mapping).forEach((entry) => {
        const [from, to] = entry;
        object[to] = object[from];
        delete object[from];
      });
    }
    function getServerInfo() {
      return this.request("server_info").then((response) => {
        const info = utils_1.convertKeysFromSnakeCaseToCamelCase(response.info);
        renameKeys(info, { hostid: "hostID" });
        if (info.validatedLedger) {
          renameKeys(info.validatedLedger, {
            baseFeeXrp: "baseFeeXRP",
            reserveBaseXrp: "reserveBaseXRP",
            reserveIncXrp: "reserveIncrementXRP",
            seq: "ledgerVersion"
          });
          info.validatedLedger.baseFeeXRP = info.validatedLedger.baseFeeXRP.toString();
          info.validatedLedger.reserveBaseXRP = info.validatedLedger.reserveBaseXRP.toString();
          info.validatedLedger.reserveIncrementXRP = info.validatedLedger.reserveIncrementXRP.toString();
        }
        return info;
      });
    }
    exports.getServerInfo = getServerInfo;
    function getFee(cushion) {
      return __awaiter(this, void 0, void 0, function* () {
        if (cushion == null) {
          cushion = this._feeCushion;
        }
        if (cushion == null) {
          cushion = 1.2;
        }
        const serverInfo = (yield this.request("server_info")).info;
        const baseFeeXrp = new bignumber_js_1.default(serverInfo.validated_ledger.base_fee_xrp);
        if (serverInfo.load_factor == null) {
          serverInfo.load_factor = 1;
        }
        let fee = baseFeeXrp.times(serverInfo.load_factor).times(cushion);
        fee = bignumber_js_1.default.min(fee, this._maxFeeXRP);
        return new bignumber_js_1.default(fee.toFixed(6)).toString(10);
      });
    }
    exports.getFee = getFee;
  }
});

// node_modules/ripple-lib/dist/npm/common/wswrapper.js
var require_wswrapper = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/wswrapper.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var events_1 = require_events();
    var WSWrapper = class extends events_1.EventEmitter {
      constructor(url, _protocols, _websocketOptions) {
        super();
        this.setMaxListeners(Infinity);
        this._ws = new WebSocket(url);
        this._ws.onclose = () => {
          this.emit("close");
        };
        this._ws.onopen = () => {
          this.emit("open");
        };
        this._ws.onerror = (error) => {
          this.emit("error", error);
        };
        this._ws.onmessage = (message) => {
          this.emit("message", message.data);
        };
      }
      close() {
        if (this.readyState === 1) {
          this._ws.close();
        }
      }
      send(message) {
        this._ws.send(message);
      }
      get readyState() {
        return this._ws.readyState;
      }
    };
    WSWrapper.CONNECTING = 0;
    WSWrapper.OPEN = 1;
    WSWrapper.CLOSING = 2;
    WSWrapper.CLOSED = 3;
    module.exports = WSWrapper;
  }
});

// node_modules/ripple-lib/dist/npm/common/rangeset.js
var require_rangeset = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/rangeset.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var assert = __importStar(require_assert());
    function mergeIntervals(intervals) {
      const stack = [[-Infinity, -Infinity]];
      _.sortBy(intervals, (x) => x[0]).forEach((interval) => {
        const lastInterval = stack.pop();
        if (interval[0] <= lastInterval[1] + 1) {
          stack.push([lastInterval[0], Math.max(interval[1], lastInterval[1])]);
        } else {
          stack.push(lastInterval);
          stack.push(interval);
        }
      });
      return stack.slice(1);
    }
    var RangeSet = class {
      constructor() {
        this.reset();
      }
      reset() {
        this.ranges = [];
      }
      serialize() {
        return this.ranges.map((range) => range[0].toString() + "-" + range[1].toString()).join(",");
      }
      addRange(start, end) {
        assert.ok(start <= end, `invalid range ${start} <= ${end}`);
        this.ranges = mergeIntervals(this.ranges.concat([[start, end]]));
      }
      addValue(value) {
        this.addRange(value, value);
      }
      parseAndAddRanges(rangesString) {
        const rangeStrings = rangesString.split(",");
        rangeStrings.forEach((rangeString) => {
          const range = rangeString.split("-").map(Number);
          this.addRange(range[0], range.length === 1 ? range[0] : range[1]);
        });
      }
      containsRange(start, end) {
        return this.ranges.some((range) => range[0] <= start && range[1] >= end);
      }
      containsValue(value) {
        return this.containsRange(value, value);
      }
    };
    exports.default = RangeSet;
  }
});

// node_modules/ripple-lib/dist/npm/common/backoff.js
var require_backoff = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/backoff.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExponentialBackoff = void 0;
    var ExponentialBackoff = class {
      constructor(opts = {}) {
        this.factor = 2;
        this.jitter = 0;
        this.attempts = 0;
        this.ms = opts.min || 100;
        this.max = opts.max || 1e4;
      }
      duration() {
        var ms = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
          var rand = Math.random();
          var deviation = Math.floor(rand * this.jitter * ms);
          ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
        }
        return Math.min(ms, this.max) | 0;
      }
      reset() {
        this.attempts = 0;
      }
    };
    exports.ExponentialBackoff = ExponentialBackoff;
  }
});

// browser-external:https-proxy-agent
var require_https_proxy_agent = __commonJS({
  "browser-external:https-proxy-agent"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https-proxy-agent" has been externalized for browser compatibility. Cannot access "https-proxy-agent.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ripple-lib/dist/npm/common/connection.js
var require_connection = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/connection.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Connection = void 0;
    var _ = __importStar(require_lodash());
    var events_1 = require_events();
    var url_1 = (init_url(), __toCommonJS(url_exports));
    var ws_1 = __importDefault(require_wswrapper());
    var rangeset_1 = __importDefault(require_rangeset());
    var errors_1 = require_errors();
    var backoff_1 = require_backoff();
    var INTENTIONAL_DISCONNECT_CODE = 4e3;
    function createWebSocket(url, config) {
      const options = {};
      if (config.proxy != null) {
        const parsedURL = url_1.parse(url);
        const parsedProxyURL = url_1.parse(config.proxy);
        const proxyOverrides = _.omitBy({
          secureEndpoint: parsedURL.protocol === "wss:",
          secureProxy: parsedProxyURL.protocol === "https:",
          auth: config.proxyAuthorization,
          ca: config.trustedCertificates,
          key: config.key,
          passphrase: config.passphrase,
          cert: config.certificate
        }, (value) => value == null);
        const proxyOptions = Object.assign({}, parsedProxyURL, proxyOverrides);
        let HttpsProxyAgent;
        try {
          HttpsProxyAgent = require_https_proxy_agent();
        } catch (error) {
          throw new Error('"proxy" option is not supported in the browser');
        }
        options.agent = new HttpsProxyAgent(proxyOptions);
      }
      if (config.authorization != null) {
        const base64 = Buffer.from(config.authorization).toString("base64");
        options.headers = { Authorization: `Basic ${base64}` };
      }
      const optionsOverrides = _.omitBy({
        ca: config.trustedCertificates,
        key: config.key,
        passphrase: config.passphrase,
        cert: config.certificate
      }, (value) => value == null);
      const websocketOptions = Object.assign({}, options, optionsOverrides);
      const websocket = new ws_1.default(url, null, websocketOptions);
      if (typeof websocket.setMaxListeners === "function") {
        websocket.setMaxListeners(Infinity);
      }
      return websocket;
    }
    function websocketSendAsync(ws, message) {
      return new Promise((resolve2, reject) => {
        ws.send(message, void 0, (error) => {
          if (error) {
            reject(new errors_1.DisconnectedError(error.message, error));
          } else {
            resolve2();
          }
        });
      });
    }
    var LedgerHistory = class {
      constructor() {
        this.feeBase = null;
        this.feeRef = null;
        this.latestVersion = null;
        this.reserveBase = null;
        this.availableVersions = new rangeset_1.default();
      }
      hasVersion(version) {
        return this.availableVersions.containsValue(version);
      }
      hasVersions(lowVersion, highVersion) {
        return this.availableVersions.containsRange(lowVersion, highVersion);
      }
      update(ledgerMessage) {
        this.feeBase = ledgerMessage.fee_base;
        this.feeRef = ledgerMessage.fee_ref;
        this.latestVersion = ledgerMessage.ledger_index;
        this.reserveBase = ledgerMessage.reserve_base;
        if (ledgerMessage.validated_ledgers) {
          this.availableVersions.reset();
          this.availableVersions.parseAndAddRanges(ledgerMessage.validated_ledgers);
        } else {
          this.availableVersions.addValue(this.latestVersion);
        }
      }
    };
    var ConnectionManager = class {
      constructor() {
        this.promisesAwaitingConnection = [];
      }
      resolveAllAwaiting() {
        this.promisesAwaitingConnection.map(({ resolve: resolve2 }) => resolve2());
        this.promisesAwaitingConnection = [];
      }
      rejectAllAwaiting(error) {
        this.promisesAwaitingConnection.map(({ reject }) => reject(error));
        this.promisesAwaitingConnection = [];
      }
      awaitConnection() {
        return new Promise((resolve2, reject) => {
          this.promisesAwaitingConnection.push({ resolve: resolve2, reject });
        });
      }
    };
    var RequestManager = class {
      constructor() {
        this.nextId = 0;
        this.promisesAwaitingResponse = [];
      }
      cancel(id) {
        const { timer } = this.promisesAwaitingResponse[id];
        clearTimeout(timer);
        delete this.promisesAwaitingResponse[id];
      }
      resolve(id, data) {
        const { timer, resolve: resolve2 } = this.promisesAwaitingResponse[id];
        clearTimeout(timer);
        resolve2(data);
        delete this.promisesAwaitingResponse[id];
      }
      reject(id, error) {
        const { timer, reject } = this.promisesAwaitingResponse[id];
        clearTimeout(timer);
        reject(error);
        delete this.promisesAwaitingResponse[id];
      }
      rejectAll(error) {
        this.promisesAwaitingResponse.forEach((_2, id) => {
          this.reject(id, error);
        });
      }
      createRequest(data, timeout) {
        const newId = this.nextId++;
        const newData = JSON.stringify(Object.assign(Object.assign({}, data), { id: newId }));
        const timer = setTimeout(() => this.reject(newId, new errors_1.TimeoutError()), timeout);
        if (timer.unref) {
          timer.unref();
        }
        const newPromise = new Promise((resolve2, reject) => {
          this.promisesAwaitingResponse[newId] = { resolve: resolve2, reject, timer };
        });
        return [newId, newData, newPromise];
      }
      handleResponse(data) {
        if (!Number.isInteger(data.id) || data.id < 0) {
          throw new errors_1.ResponseFormatError("valid id not found in response", data);
        }
        if (!this.promisesAwaitingResponse[data.id]) {
          return;
        }
        if (data.status === "error") {
          const error = new errors_1.RippledError(data.error_message || data.error, data);
          this.reject(data.id, error);
          return;
        }
        if (data.status !== "success") {
          const error = new errors_1.ResponseFormatError(`unrecognized status: ${data.status}`, data);
          this.reject(data.id, error);
          return;
        }
        this.resolve(data.id, data.result);
      }
    };
    var Connection = class extends events_1.EventEmitter {
      constructor(url, options = {}) {
        super();
        this._ws = null;
        this._reconnectTimeoutID = null;
        this._heartbeatIntervalID = null;
        this._retryConnectionBackoff = new backoff_1.ExponentialBackoff({
          min: 100,
          max: 60 * 1e3
        });
        this._trace = () => {
        };
        this._ledger = new LedgerHistory();
        this._requestManager = new RequestManager();
        this._connectionManager = new ConnectionManager();
        this._clearHeartbeatInterval = () => {
          clearInterval(this._heartbeatIntervalID);
        };
        this._startHeartbeatInterval = () => {
          this._clearHeartbeatInterval();
          this._heartbeatIntervalID = setInterval(() => this._heartbeat(), this._config.timeout);
        };
        this._heartbeat = () => {
          return this.request({ command: "ping" }).catch(() => {
            return this.reconnect().catch((error) => {
              this.emit("error", "reconnect", error.message, error);
            });
          });
        };
        this._onConnectionFailed = (errorOrCode) => {
          if (this._ws) {
            this._ws.removeAllListeners();
            this._ws.on("error", () => {
            });
            this._ws.close();
            this._ws = null;
          }
          if (typeof errorOrCode === "number") {
            this._connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(`Connection failed with code ${errorOrCode}.`, {
              code: errorOrCode
            }));
          } else if (errorOrCode && errorOrCode.message) {
            this._connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(errorOrCode.message, errorOrCode));
          } else {
            this._connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError("Connection failed."));
          }
        };
        this.setMaxListeners(Infinity);
        this._url = url;
        this._config = Object.assign({ timeout: 20 * 1e3, connectionTimeout: 5 * 1e3 }, options);
        if (typeof options.trace === "function") {
          this._trace = options.trace;
        } else if (options.trace === true) {
          this._trace = console.log;
        }
      }
      _onMessage(message) {
        this._trace("receive", message);
        let data;
        try {
          data = JSON.parse(message);
        } catch (error) {
          this.emit("error", "badMessage", error.message, message);
          return;
        }
        if (data.type == null && data.error) {
          this.emit("error", data.error, data.error_message, data);
          return;
        }
        if (data.type) {
          this.emit(data.type, data);
        }
        if (data.type === "ledgerClosed") {
          this._ledger.update(data);
        }
        if (data.type === "response") {
          try {
            this._requestManager.handleResponse(data);
          } catch (error) {
            this.emit("error", "badMessage", error.message, message);
          }
        }
      }
      get _state() {
        return this._ws ? this._ws.readyState : ws_1.default.CLOSED;
      }
      get _shouldBeConnected() {
        return this._ws !== null;
      }
      _waitForReady() {
        return new Promise((resolve2, reject) => {
          if (!this._shouldBeConnected) {
            reject(new errors_1.NotConnectedError());
          } else if (this._state === ws_1.default.OPEN) {
            resolve2();
          } else {
            this.once("connected", () => resolve2());
          }
        });
      }
      _subscribeToLedger() {
        return __awaiter(this, void 0, void 0, function* () {
          const data = yield this.request({
            command: "subscribe",
            streams: ["ledger"]
          });
          if (_.isEmpty(data) || !data.ledger_index) {
            try {
              yield this.disconnect();
            } catch (error) {
            } finally {
              throw new errors_1.RippledNotInitializedError("Rippled not initialized");
            }
          }
          this._ledger.update(data);
        });
      }
      isConnected() {
        return this._state === ws_1.default.OPEN;
      }
      connect() {
        if (this.isConnected()) {
          return Promise.resolve();
        }
        if (this._state === ws_1.default.CONNECTING) {
          return this._connectionManager.awaitConnection();
        }
        if (!this._url) {
          return Promise.reject(new errors_1.ConnectionError("Cannot connect because no server was specified"));
        }
        if (this._ws) {
          return Promise.reject(new errors_1.RippleError("Websocket connection never cleaned up.", {
            state: this._state
          }));
        }
        const connectionTimeoutID = setTimeout(() => {
          this._onConnectionFailed(new errors_1.ConnectionError(`Error: connect() timed out after ${this._config.connectionTimeout} ms. If your internet connection is working, the rippled server may be blocked or inaccessible. You can also try setting the 'connectionTimeout' option in the RippleAPI constructor.`));
        }, this._config.connectionTimeout);
        this._ws = createWebSocket(this._url, this._config);
        this._ws.on("error", this._onConnectionFailed);
        this._ws.on("error", () => clearTimeout(connectionTimeoutID));
        this._ws.on("close", this._onConnectionFailed);
        this._ws.on("close", () => clearTimeout(connectionTimeoutID));
        this._ws.once("open", () => __awaiter(this, void 0, void 0, function* () {
          this._ws.removeAllListeners();
          clearTimeout(connectionTimeoutID);
          this._ws.on("message", (message) => this._onMessage(message));
          this._ws.on("error", (error) => this.emit("error", "websocket", error.message, error));
          this._ws.once("close", (code) => {
            this._clearHeartbeatInterval();
            this._requestManager.rejectAll(new errors_1.DisconnectedError("websocket was closed"));
            this._ws.removeAllListeners();
            this._ws = null;
            this.emit("disconnected", code);
            if (code !== INTENTIONAL_DISCONNECT_CODE) {
              const retryTimeout = this._retryConnectionBackoff.duration();
              this._trace("reconnect", `Retrying connection in ${retryTimeout}ms.`);
              this.emit("reconnecting", this._retryConnectionBackoff.attempts);
              this._reconnectTimeoutID = setTimeout(() => {
                this.reconnect().catch((error) => {
                  this.emit("error", "reconnect", error.message, error);
                });
              }, retryTimeout);
            }
          });
          try {
            this._retryConnectionBackoff.reset();
            yield this._subscribeToLedger();
            this._startHeartbeatInterval();
            this._connectionManager.resolveAllAwaiting();
            this.emit("connected");
          } catch (error) {
            this._connectionManager.rejectAllAwaiting(error);
            yield this.disconnect().catch(() => {
            });
          }
        }));
        return this._connectionManager.awaitConnection();
      }
      disconnect() {
        clearTimeout(this._reconnectTimeoutID);
        this._reconnectTimeoutID = null;
        if (this._state === ws_1.default.CLOSED || !this._ws) {
          return Promise.resolve(void 0);
        }
        return new Promise((resolve2) => {
          this._ws.once("close", (code) => resolve2(code));
          if (this._state !== ws_1.default.CLOSING) {
            this._ws.close(INTENTIONAL_DISCONNECT_CODE);
          }
        });
      }
      reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          this.emit("reconnect");
          yield this.disconnect();
          yield this.connect();
        });
      }
      getFeeBase() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this._waitForReady();
          return this._ledger.feeBase;
        });
      }
      getFeeRef() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this._waitForReady();
          return this._ledger.feeRef;
        });
      }
      getLedgerVersion() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this._waitForReady();
          return this._ledger.latestVersion;
        });
      }
      getReserveBase() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this._waitForReady();
          return this._ledger.reserveBase;
        });
      }
      hasLedgerVersions(lowLedgerVersion, highLedgerVersion) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!highLedgerVersion) {
            return this.hasLedgerVersion(lowLedgerVersion);
          }
          yield this._waitForReady();
          return this._ledger.hasVersions(lowLedgerVersion, highLedgerVersion);
        });
      }
      hasLedgerVersion(ledgerVersion) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this._waitForReady();
          return this._ledger.hasVersion(ledgerVersion);
        });
      }
      request(request, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this._shouldBeConnected) {
            throw new errors_1.NotConnectedError();
          }
          const [id, message, responsePromise] = this._requestManager.createRequest(request, timeout || this._config.timeout);
          this._trace("send", message);
          websocketSendAsync(this._ws, message).catch((error) => {
            this._requestManager.reject(id, error);
          });
          return responsePromise;
        });
      }
      getUrl() {
        return this._url;
      }
    };
    exports.Connection = Connection;
  }
});

// node_modules/ripple-lib/dist/npm/common/index.js
var require_common = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/index.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serverInfo = exports.validate = exports.errors = exports.constants = exports.ensureClassicAddress = void 0;
    var constants = __importStar(require_constants());
    exports.constants = constants;
    var errors = __importStar(require_errors());
    exports.errors = errors;
    var validate = __importStar(require_validate());
    exports.validate = validate;
    var serverInfo = __importStar(require_serverinfo());
    exports.serverInfo = serverInfo;
    var ripple_address_codec_1 = require_dist4();
    function ensureClassicAddress(account) {
      if (ripple_address_codec_1.isValidXAddress(account)) {
        const { classicAddress, tag } = ripple_address_codec_1.xAddressToClassicAddress(account);
        if (tag !== false) {
          throw new Error("This command does not support the use of a tag. Use an address without a tag.");
        }
        return classicAddress;
      } else {
        return account;
      }
    }
    exports.ensureClassicAddress = ensureClassicAddress;
    var utils_1 = require_utils4();
    Object.defineProperty(exports, "dropsToXrp", { enumerable: true, get: function() {
      return utils_1.dropsToXrp;
    } });
    Object.defineProperty(exports, "xrpToDrops", { enumerable: true, get: function() {
      return utils_1.xrpToDrops;
    } });
    Object.defineProperty(exports, "toRippledAmount", { enumerable: true, get: function() {
      return utils_1.toRippledAmount;
    } });
    Object.defineProperty(exports, "removeUndefined", { enumerable: true, get: function() {
      return utils_1.removeUndefined;
    } });
    Object.defineProperty(exports, "convertKeysFromSnakeCaseToCamelCase", { enumerable: true, get: function() {
      return utils_1.convertKeysFromSnakeCaseToCamelCase;
    } });
    Object.defineProperty(exports, "iso8601ToRippleTime", { enumerable: true, get: function() {
      return utils_1.iso8601ToRippleTime;
    } });
    Object.defineProperty(exports, "rippleTimeToISO8601", { enumerable: true, get: function() {
      return utils_1.rippleTimeToISO8601;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports, "Connection", { enumerable: true, get: function() {
      return connection_1.Connection;
    } });
    var txflags_1 = require_txflags();
    Object.defineProperty(exports, "txFlags", { enumerable: true, get: function() {
      return txflags_1.txFlags;
    } });
  }
});

// node_modules/ripple-lib/dist/npm/server/server.js
var require_server = __commonJS({
  "node_modules/ripple-lib/dist/npm/server/server.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLedgerClose = exports.getLedgerVersion = exports.isConnected = exports.disconnect = exports.connect = void 0;
    var common = __importStar(require_common());
    function isConnected() {
      return this.connection.isConnected();
    }
    exports.isConnected = isConnected;
    function getLedgerVersion() {
      return this.connection.getLedgerVersion();
    }
    exports.getLedgerVersion = getLedgerVersion;
    function connect() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.connection.connect();
      });
    }
    exports.connect = connect;
    function disconnect() {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.connection.disconnect();
      });
    }
    exports.disconnect = disconnect;
    function formatLedgerClose(ledgerClose) {
      return {
        baseFeeXRP: common.dropsToXrp(ledgerClose.fee_base),
        ledgerHash: ledgerClose.ledger_hash,
        ledgerVersion: ledgerClose.ledger_index,
        ledgerTimestamp: common.rippleTimeToISO8601(ledgerClose.ledger_time),
        reserveBaseXRP: common.dropsToXrp(ledgerClose.reserve_base),
        reserveIncrementXRP: common.dropsToXrp(ledgerClose.reserve_inc),
        transactionCount: ledgerClose.txn_count,
        validatedLedgerVersions: ledgerClose.validated_ledgers
      };
    }
    exports.formatLedgerClose = formatLedgerClose;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/utils.js
var require_utils5 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/utils.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.common = exports.clamp = exports.isPendingLedgerVersion = exports.hasCompleteLedgerRange = exports.getRecursive = exports.renameCounterpartyToIssuerInOrder = exports.renameCounterpartyToIssuer = exports.compareTransactions = exports.ensureLedgerVersion = exports.getXRPBalance = void 0;
    var _ = __importStar(require_lodash());
    var assert = __importStar(require_assert());
    var common = __importStar(require_common());
    exports.common = common;
    function clamp(value, min, max) {
      assert.ok(min <= max, "Illegal clamp bounds");
      return Math.min(Math.max(value, min), max);
    }
    exports.clamp = clamp;
    function getXRPBalance(connection, address, ledgerVersion) {
      const request = {
        command: "account_info",
        account: address,
        ledger_index: ledgerVersion
      };
      return connection.request(request).then((data) => common.dropsToXrp(data.account_data.Balance));
    }
    exports.getXRPBalance = getXRPBalance;
    function getRecursiveRecur(getter, marker, limit) {
      return getter(marker, limit).then((data) => {
        const remaining = limit - data.results.length;
        if (remaining > 0 && data.marker != null) {
          return getRecursiveRecur(getter, data.marker, remaining).then((results) => data.results.concat(results));
        }
        return data.results.slice(0, limit);
      });
    }
    function getRecursive(getter, limit) {
      return getRecursiveRecur(getter, void 0, limit || Infinity);
    }
    exports.getRecursive = getRecursive;
    function renameCounterpartyToIssuer(obj) {
      const issuer = obj.counterparty != null ? obj.counterparty : obj.issuer != null ? obj.issuer : void 0;
      const withIssuer = Object.assign({}, obj, { issuer });
      delete withIssuer.counterparty;
      return withIssuer;
    }
    exports.renameCounterpartyToIssuer = renameCounterpartyToIssuer;
    function renameCounterpartyToIssuerInOrder(order) {
      const taker_gets = renameCounterpartyToIssuer(order.taker_gets);
      const taker_pays = renameCounterpartyToIssuer(order.taker_pays);
      const changes = { taker_gets, taker_pays };
      return Object.assign({}, order, _.omitBy(changes, (value) => value == null));
    }
    exports.renameCounterpartyToIssuerInOrder = renameCounterpartyToIssuerInOrder;
    function signum(num) {
      return num === 0 ? 0 : num > 0 ? 1 : -1;
    }
    function compareTransactions(first, second) {
      if (!first.outcome || !second.outcome) {
        return 0;
      }
      if (first.outcome.ledgerVersion === second.outcome.ledgerVersion) {
        return signum(first.outcome.indexInLedger - second.outcome.indexInLedger);
      }
      return first.outcome.ledgerVersion < second.outcome.ledgerVersion ? -1 : 1;
    }
    exports.compareTransactions = compareTransactions;
    function hasCompleteLedgerRange(connection, minLedgerVersion, maxLedgerVersion) {
      const firstLedgerVersion = 32570;
      return connection.hasLedgerVersions(minLedgerVersion || firstLedgerVersion, maxLedgerVersion);
    }
    exports.hasCompleteLedgerRange = hasCompleteLedgerRange;
    function isPendingLedgerVersion(connection, maxLedgerVersion) {
      return connection.getLedgerVersion().then((ledgerVersion) => ledgerVersion < (maxLedgerVersion || 0));
    }
    exports.isPendingLedgerVersion = isPendingLedgerVersion;
    function ensureLedgerVersion(options) {
      if (Boolean(options) && options.ledgerVersion != null && options.ledgerVersion !== null) {
        return Promise.resolve(options);
      }
      return this.getLedgerVersion().then((ledgerVersion) => Object.assign({}, options, { ledgerVersion }));
    }
    exports.ensureLedgerVersion = ensureLedgerVersion;
  }
});

// node_modules/ripple-lib-transactionparser/src/utils.js
var require_utils6 = __commonJS({
  "node_modules/ripple-lib-transactionparser/src/utils.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var _ = require_lodash();
    var BigNumber = require_bignumber();
    function dropsToXRP(drops) {
      return drops.dividedBy(1e6);
    }
    function normalizeNode(affectedNode) {
      var diffType = Object.keys(affectedNode)[0];
      var node = affectedNode[diffType];
      return Object.assign({}, node, {
        diffType,
        entryType: node.LedgerEntryType,
        ledgerIndex: node.LedgerIndex,
        newFields: node.NewFields || {},
        finalFields: node.FinalFields || {},
        previousFields: node.PreviousFields || {}
      });
    }
    function normalizeNodes(metadata) {
      if (!metadata.AffectedNodes) {
        return [];
      }
      return metadata.AffectedNodes.map(normalizeNode);
    }
    function parseCurrencyAmount(currencyAmount) {
      if (currencyAmount === void 0) {
        return void 0;
      }
      if (typeof currencyAmount === "string") {
        return {
          currency: "XRP",
          value: dropsToXRP(new BigNumber(currencyAmount)).toString()
        };
      }
      return {
        currency: currencyAmount.currency,
        counterparty: currencyAmount.issuer,
        value: currencyAmount.value
      };
    }
    function isAccountField(fieldName) {
      var fieldNames = ["Account", "Owner", "Destination", "Issuer", "Target"];
      return _.includes(fieldNames, fieldName);
    }
    function isAmountFieldAffectingIssuer(fieldName) {
      var fieldNames = ["LowLimit", "HighLimit", "TakerPays", "TakerGets"];
      return _.includes(fieldNames, fieldName);
    }
    function getAffectedAccounts(metadata) {
      var accounts = [];
      _.forEach(normalizeNodes(metadata), function(node) {
        var fields = node.diffType === "CreatedNode" ? node.newFields : node.finalFields;
        _.forEach(fields, function(fieldValue, fieldName) {
          if (isAccountField(fieldName)) {
            accounts.push(fieldValue);
          } else if (isAmountFieldAffectingIssuer(fieldName) && fieldValue.issuer) {
            accounts.push(fieldValue.issuer);
          }
        });
      });
      return _.uniq(accounts);
    }
    module.exports = {
      dropsToXRP,
      normalizeNodes,
      parseCurrencyAmount,
      getAffectedAccounts
    };
  }
});

// node_modules/ripple-lib-transactionparser/src/balancechanges.js
var require_balancechanges = __commonJS({
  "node_modules/ripple-lib-transactionparser/src/balancechanges.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var _ = require_lodash();
    var BigNumber = require_bignumber();
    var normalizeNodes = require_utils6().normalizeNodes;
    var dropsToXRP = require_utils6().dropsToXRP;
    function groupByAddress(balanceChanges) {
      var grouped = _.groupBy(balanceChanges, function(node) {
        return node.address;
      });
      return _.mapValues(grouped, function(group) {
        return _.map(group, function(node) {
          return node.balance;
        });
      });
    }
    function parseValue(value) {
      return new BigNumber(value.value || value);
    }
    function computeBalanceChange(node) {
      var value = null;
      if (node.newFields.Balance) {
        value = parseValue(node.newFields.Balance);
      } else if (node.previousFields.Balance && node.finalFields.Balance) {
        value = parseValue(node.finalFields.Balance).minus(
          parseValue(node.previousFields.Balance)
        );
      }
      return value === null ? null : value.isZero() ? null : value;
    }
    function parseFinalBalance(node) {
      if (node.newFields.Balance) {
        return parseValue(node.newFields.Balance);
      } else if (node.finalFields.Balance) {
        return parseValue(node.finalFields.Balance);
      }
      return null;
    }
    function parseXRPQuantity(node, valueParser) {
      var value = valueParser(node);
      if (value === null) {
        return null;
      }
      return {
        address: node.finalFields.Account || node.newFields.Account,
        balance: {
          counterparty: "",
          currency: "XRP",
          value: dropsToXRP(value).toString()
        }
      };
    }
    function flipTrustlinePerspective(quantity) {
      var negatedBalance = new BigNumber(quantity.balance.value).negated();
      return {
        address: quantity.balance.counterparty,
        balance: {
          counterparty: quantity.address,
          currency: quantity.balance.currency,
          value: negatedBalance.toString()
        }
      };
    }
    function parseTrustlineQuantity(node, valueParser) {
      var value = valueParser(node);
      if (value === null) {
        return null;
      }
      var fields = _.isEmpty(node.newFields) ? node.finalFields : node.newFields;
      var result = {
        address: fields.LowLimit.issuer,
        balance: {
          counterparty: fields.HighLimit.issuer,
          currency: fields.Balance.currency,
          value: value.toString()
        }
      };
      return [result, flipTrustlinePerspective(result)];
    }
    function parseQuantities(metadata, valueParser) {
      var values = normalizeNodes(metadata).map(function(node) {
        if (node.entryType === "AccountRoot") {
          return [parseXRPQuantity(node, valueParser)];
        } else if (node.entryType === "RippleState") {
          return parseTrustlineQuantity(node, valueParser);
        }
        return [];
      });
      return groupByAddress(_.compact(_.flatten(values)));
    }
    function parseBalanceChanges(metadata) {
      return parseQuantities(metadata, computeBalanceChange);
    }
    function parseFinalBalances(metadata) {
      return parseQuantities(metadata, parseFinalBalance);
    }
    module.exports.parseBalanceChanges = parseBalanceChanges;
    module.exports.parseFinalBalances = parseFinalBalances;
  }
});

// node_modules/ripple-lib-transactionparser/src/quality.js
var require_quality2 = __commonJS({
  "node_modules/ripple-lib-transactionparser/src/quality.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var assert = require_assert();
    var BigNumber = require_bignumber();
    function adjustQualityForXRP(quality, takerGetsCurrency, takerPaysCurrency) {
      var numeratorShift = takerPaysCurrency === "XRP" ? -6 : 0;
      var denominatorShift = takerGetsCurrency === "XRP" ? -6 : 0;
      var shift = numeratorShift - denominatorShift;
      return shift === 0 ? new BigNumber(quality).toString() : new BigNumber(quality).shiftedBy(shift).toString();
    }
    function parseQuality(qualityHex, takerGetsCurrency, takerPaysCurrency) {
      assert(qualityHex.length === 16);
      var mantissa = new BigNumber(qualityHex.substring(2), 16);
      var offset = parseInt(qualityHex.substring(0, 2), 16) - 100;
      var quality = mantissa.toString() + "e" + offset.toString();
      return adjustQualityForXRP(quality, takerGetsCurrency, takerPaysCurrency);
    }
    module.exports = parseQuality;
  }
});

// node_modules/ripple-lib-transactionparser/src/orderbookchanges.js
var require_orderbookchanges = __commonJS({
  "node_modules/ripple-lib-transactionparser/src/orderbookchanges.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var _ = require_lodash();
    var utils = require_utils6();
    var GlobalBigNumber = require_bignumber();
    var BigNumber = GlobalBigNumber.clone({ DECIMAL_PLACES: 40 });
    var parseQuality = require_quality2();
    var lsfSell = 131072;
    function removeUndefined(obj) {
      return _.omitBy(obj, _.isUndefined);
    }
    function convertOrderChange(order) {
      var takerGets = order.taker_gets;
      var takerPays = order.taker_pays;
      var direction = order.sell ? "sell" : "buy";
      var quantity = direction === "buy" ? takerPays : takerGets;
      var totalPrice = direction === "buy" ? takerGets : takerPays;
      return removeUndefined({
        direction,
        quantity,
        totalPrice,
        sequence: order.sequence,
        status: order.status,
        makerExchangeRate: order.quality,
        expirationTime: order.expiration
      });
    }
    function rippleToUnixTimestamp(rpepoch) {
      return (rpepoch + 946684800) * 1e3;
    }
    function getExpirationTime(node) {
      var expirationTime = node.finalFields.Expiration || node.newFields.Expiration;
      if (expirationTime === void 0) {
        return void 0;
      }
      return new Date(rippleToUnixTimestamp(expirationTime)).toISOString();
    }
    function getQuality(node) {
      var takerGets = node.finalFields.TakerGets || node.newFields.TakerGets;
      var takerPays = node.finalFields.TakerPays || node.newFields.TakerPays;
      var takerGetsCurrency = takerGets.currency || "XRP";
      var takerPaysCurrency = takerPays.currency || "XRP";
      var bookDirectory = node.finalFields.BookDirectory || node.newFields.BookDirectory;
      var qualityHex = bookDirectory.substring(bookDirectory.length - 16);
      return parseQuality(qualityHex, takerGetsCurrency, takerPaysCurrency);
    }
    function parseOrderStatus(node) {
      if (node.diffType === "CreatedNode") {
        return "created";
      }
      if (node.diffType === "ModifiedNode") {
        return "partially-filled";
      }
      if (node.diffType === "DeletedNode") {
        if (node.previousFields.hasOwnProperty("TakerPays")) {
          return "filled";
        }
        return "cancelled";
      }
      return void 0;
    }
    function calculateDelta(finalAmount, previousAmount) {
      if (previousAmount) {
        var finalValue = new BigNumber(finalAmount.value);
        var previousValue = new BigNumber(previousAmount.value);
        return finalValue.minus(previousValue).abs().toString();
      }
      return "0";
    }
    function parseChangeAmount(node, type) {
      var status = parseOrderStatus(node);
      if (status === "cancelled") {
        return utils.parseCurrencyAmount(node.finalFields[type]);
      } else if (status === "created") {
        return utils.parseCurrencyAmount(node.newFields[type]);
      }
      var finalAmount = utils.parseCurrencyAmount(node.finalFields[type]);
      var previousAmount = utils.parseCurrencyAmount(node.previousFields[type]);
      var value = calculateDelta(finalAmount, previousAmount);
      return _.assign({}, finalAmount, { value });
    }
    function parseOrderChange(node) {
      var orderChange = convertOrderChange({
        taker_pays: parseChangeAmount(node, "TakerPays"),
        taker_gets: parseChangeAmount(node, "TakerGets"),
        sell: (node.finalFields.Flags & lsfSell) !== 0,
        sequence: node.finalFields.Sequence || node.newFields.Sequence,
        status: parseOrderStatus(node),
        quality: getQuality(node),
        expiration: getExpirationTime(node)
      });
      Object.defineProperty(orderChange, "account", {
        value: node.finalFields.Account || node.newFields.Account
      });
      return orderChange;
    }
    function groupByAddress(orderChanges) {
      return _.groupBy(orderChanges, function(change) {
        return change.account;
      });
    }
    exports.parseOrderbookChanges = function parseOrderbookChanges(metadata) {
      var nodes = utils.normalizeNodes(metadata);
      var orderChanges = _.map(_.filter(nodes, function(node) {
        return node.entryType === "Offer";
      }), parseOrderChange);
      return groupByAddress(orderChanges);
    };
  }
});

// node_modules/ripple-lib-transactionparser/src/channelchanges.js
var require_channelchanges = __commonJS({
  "node_modules/ripple-lib-transactionparser/src/channelchanges.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var normalizeNodes = require_utils6().normalizeNodes;
    var BigNumber = require_bignumber();
    function parsePaymentChannelStatus(node) {
      if (node.diffType === "CreatedNode") {
        return "created";
      }
      if (node.diffType === "ModifiedNode") {
        return "modified";
      }
      if (node.diffType === "DeletedNode") {
        return "deleted";
      }
      return void 0;
    }
    function summarizePaymentChannel(node) {
      const final = node.diffType === "CreatedNode" ? node.newFields : node.finalFields;
      const prev = node.previousFields || {};
      const summary = {
        // Status may be 'created', 'modified', or 'deleted'.
        status: parsePaymentChannelStatus(node),
        // The LedgerIndex indicates the Channel ID,
        // which is necessary to sign claims.
        channelId: node.ledgerIndex,
        // The source address that owns this payment channel.
        // This comes from the sending address of the
        // transaction that created the channel.
        source: final.Account,
        // The destination address for this payment channel.
        // While the payment channel is open, this address is the only one that can receive
        // XRP from the channel. This comes from the Destination field of the transaction
        // that created the channel.
        destination: final.Destination,
        // Total XRP, in drops, that has been allocated to this channel.
        // This includes XRP that has been paid to the destination address.
        // This is initially set by the transaction that created the channel and
        // can be increased if the source address sends a PaymentChannelFund transaction.
        channelAmountDrops: new BigNumber(final.Amount || 0).toString(10),
        // Total XRP, in drops, already paid out by the channel.
        // The difference between this value and the Amount field is how much XRP can still
        // be paid to the destination address with PaymentChannelClaim transactions.
        // If the channel closes, the remaining difference is returned to the source address.
        channelBalanceDrops: new BigNumber(final.Balance || 0).toString(10)
      };
      if (prev.Amount) {
        summary.channelAmountChangeDrops = new BigNumber(final.Amount).minus(new BigNumber(prev.Amount || 0)).toString(10);
      }
      if (prev.Balance) {
        summary.channelBalanceChangeDrops = new BigNumber(final.Balance).minus(new BigNumber(prev.Balance || 0)).toString(10);
      }
      if (node.PreviousTxnID) {
        summary.previousTxnId = node.PreviousTxnID;
      }
      return summary;
    }
    function parseChannelChanges(metadata) {
      const paymentChannels = normalizeNodes(metadata).filter((n) => {
        return n.entryType === "PayChannel";
      });
      return paymentChannels.length === 1 ? summarizePaymentChannel(paymentChannels[0]) : void 0;
    }
    module.exports.parseChannelChanges = parseChannelChanges;
  }
});

// node_modules/ripple-lib-transactionparser/src/index.js
var require_src2 = __commonJS({
  "node_modules/ripple-lib-transactionparser/src/index.js"(exports, module) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module.exports.parseBalanceChanges = require_balancechanges().parseBalanceChanges;
    module.exports.parseFinalBalances = require_balancechanges().parseFinalBalances;
    module.exports.parseOrderbookChanges = require_orderbookchanges().parseOrderbookChanges;
    module.exports.getAffectedAccounts = require_utils6().getAffectedAccounts;
    module.exports.parseChannelChanges = require_channelchanges().parseChannelChanges;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/amount.js
var require_amount2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/amount.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = __importStar(require_common());
    function parseAmount(amount) {
      if (typeof amount === "string") {
        return {
          currency: "XRP",
          value: common.dropsToXrp(amount)
        };
      }
      return {
        currency: amount.currency,
        value: amount.value,
        counterparty: amount.issuer
      };
    }
    exports.default = parseAmount;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/utils.js
var require_utils7 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/utils.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPartialPayment = exports.adjustQualityForXRP = exports.parseTimestamp = exports.hexToString = exports.parseMemos = exports.parseOutcome = exports.parseQuality = void 0;
    var ripple_lib_transactionparser_1 = __importDefault(require_src2());
    var bignumber_js_1 = __importDefault(require_bignumber());
    var common = __importStar(require_common());
    var amount_1 = __importDefault(require_amount2());
    function adjustQualityForXRP(quality, takerGetsCurrency, takerPaysCurrency) {
      const numeratorShift = takerPaysCurrency === "XRP" ? -6 : 0;
      const denominatorShift = takerGetsCurrency === "XRP" ? -6 : 0;
      const shift = numeratorShift - denominatorShift;
      return shift === 0 ? quality : new bignumber_js_1.default(quality).shiftedBy(shift).toString();
    }
    exports.adjustQualityForXRP = adjustQualityForXRP;
    function parseQuality(quality) {
      if (typeof quality !== "number") {
        return void 0;
      }
      return new bignumber_js_1.default(quality).shiftedBy(-9).toNumber();
    }
    exports.parseQuality = parseQuality;
    function parseTimestamp(rippleTime) {
      if (typeof rippleTime !== "number") {
        return void 0;
      }
      return common.rippleTimeToISO8601(rippleTime);
    }
    exports.parseTimestamp = parseTimestamp;
    function removeEmptyCounterparty(amount) {
      if (amount.counterparty === "") {
        delete amount.counterparty;
      }
    }
    function removeEmptyCounterpartyInBalanceChanges(balanceChanges) {
      Object.entries(balanceChanges).forEach(([_, changes]) => {
        changes.forEach(removeEmptyCounterparty);
      });
    }
    function removeEmptyCounterpartyInOrderbookChanges(orderbookChanges) {
      Object.entries(orderbookChanges).forEach(([_, changes]) => {
        changes.forEach((change) => {
          Object.entries(change).forEach(removeEmptyCounterparty);
        });
      });
    }
    function isPartialPayment(tx) {
      return (tx.Flags & common.txFlags.Payment.PartialPayment) !== 0;
    }
    exports.isPartialPayment = isPartialPayment;
    function parseDeliveredAmount(tx) {
      if (tx.TransactionType !== "Payment" || tx.meta.TransactionResult !== "tesSUCCESS") {
        return void 0;
      }
      if (tx.meta.delivered_amount && tx.meta.delivered_amount === "unavailable") {
        return void 0;
      }
      if (tx.meta.delivered_amount) {
        return amount_1.default(tx.meta.delivered_amount);
      }
      if (tx.meta.DeliveredAmount) {
        return amount_1.default(tx.meta.DeliveredAmount);
      }
      if (tx.Amount && !isPartialPayment(tx)) {
        return amount_1.default(tx.Amount);
      }
      if (tx.Amount && tx.ledger_index > 4594094) {
        return amount_1.default(tx.Amount);
      }
      return void 0;
    }
    function parseOutcome(tx) {
      const metadata = tx.meta || tx.metaData;
      if (!metadata) {
        return void 0;
      }
      const balanceChanges = ripple_lib_transactionparser_1.default.parseBalanceChanges(metadata);
      const orderbookChanges = ripple_lib_transactionparser_1.default.parseOrderbookChanges(metadata);
      const channelChanges = ripple_lib_transactionparser_1.default.parseChannelChanges(metadata);
      removeEmptyCounterpartyInBalanceChanges(balanceChanges);
      removeEmptyCounterpartyInOrderbookChanges(orderbookChanges);
      return common.removeUndefined({
        result: tx.meta.TransactionResult,
        timestamp: parseTimestamp(tx.date),
        fee: common.dropsToXrp(tx.Fee),
        balanceChanges,
        orderbookChanges,
        channelChanges,
        ledgerVersion: tx.ledger_index,
        indexInLedger: tx.meta.TransactionIndex,
        deliveredAmount: parseDeliveredAmount(tx)
      });
    }
    exports.parseOutcome = parseOutcome;
    function hexToString(hex) {
      return hex ? Buffer.from(hex, "hex").toString("utf-8") : void 0;
    }
    exports.hexToString = hexToString;
    function parseMemos(tx) {
      if (!Array.isArray(tx.Memos) || tx.Memos.length === 0) {
        return void 0;
      }
      return tx.Memos.map((m) => {
        return common.removeUndefined({
          type: m.Memo.parsed_memo_type || hexToString(m.Memo.MemoType),
          format: m.Memo.parsed_memo_format || hexToString(m.Memo.MemoFormat),
          data: m.Memo.parsed_memo_data || hexToString(m.Memo.MemoData)
        });
      });
    }
    exports.parseMemos = parseMemos;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/fields.js
var require_fields = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/fields.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_js_1 = __importDefault(require_bignumber());
    var common_1 = require_common();
    var AccountFields = common_1.constants.AccountFields;
    function parseField(info, value) {
      if (info.encoding === "hex" && !info.length) {
        return Buffer.from(value, "hex").toString("ascii");
      }
      if (info.shift) {
        return new bignumber_js_1.default(value).shiftedBy(-info.shift).toNumber();
      }
      return value;
    }
    function parseFields(data) {
      const settings = {};
      for (const fieldName in AccountFields) {
        const fieldValue = data[fieldName];
        if (fieldValue != null) {
          const info = AccountFields[fieldName];
          settings[info.name] = parseField(info, fieldValue);
        }
      }
      if (data.RegularKey) {
        settings.regularKey = data.RegularKey;
      }
      if (data.signer_lists && data.signer_lists.length === 1) {
        settings.signers = {};
        if (data.signer_lists[0].SignerQuorum) {
          settings.signers.threshold = data.signer_lists[0].SignerQuorum;
        }
        if (data.signer_lists[0].SignerEntries) {
          settings.signers.weights = data.signer_lists[0].SignerEntries.map((entry) => {
            return {
              address: entry.SignerEntry.Account,
              weight: entry.SignerEntry.SignerWeight
            };
          });
        }
      }
      return settings;
    }
    exports.default = parseFields;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/settings.js
var require_settings2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/settings.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var assert = __importStar(require_assert());
    var common_1 = require_common();
    var AccountFlags = common_1.constants.AccountFlags;
    var fields_1 = __importDefault(require_fields());
    function getAccountRootModifiedNode(tx) {
      const modifiedNodes = tx.meta.AffectedNodes.filter((node) => {
        var _a;
        return ((_a = node.ModifiedNode) === null || _a === void 0 ? void 0 : _a.LedgerEntryType) === "AccountRoot";
      });
      assert.ok(modifiedNodes.length === 1);
      return modifiedNodes[0].ModifiedNode;
    }
    function parseFlags(tx) {
      const settings = {};
      if (tx.TransactionType !== "AccountSet") {
        return settings;
      }
      const node = getAccountRootModifiedNode(tx);
      const oldFlags = _.get(node.PreviousFields, "Flags");
      const newFlags = _.get(node.FinalFields, "Flags");
      if (oldFlags != null && newFlags != null) {
        const changedFlags = oldFlags ^ newFlags;
        const setFlags = newFlags & changedFlags;
        const clearedFlags = oldFlags & changedFlags;
        Object.entries(AccountFlags).forEach((entry) => {
          const [flagName, flagValue] = entry;
          if (setFlags & flagValue) {
            settings[flagName] = true;
          } else if (clearedFlags & flagValue) {
            settings[flagName] = false;
          }
        });
      }
      const oldField = _.get(node.PreviousFields, "AccountTxnID");
      const newField = _.get(node.FinalFields, "AccountTxnID");
      if (newField && !oldField) {
        settings.enableTransactionIDTracking = true;
      } else if (oldField && !newField) {
        settings.enableTransactionIDTracking = false;
      }
      return settings;
    }
    function parseSettings(tx) {
      const txType = tx.TransactionType;
      assert.ok(txType === "AccountSet" || txType === "SetRegularKey" || txType === "SignerListSet");
      return Object.assign({}, parseFlags(tx), fields_1.default(tx));
    }
    exports.default = parseSettings;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/account-delete.js
var require_account_delete2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/account-delete.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var common_1 = require_common();
    var ripple_address_codec_1 = require_dist4();
    var utils_1 = require_utils7();
    function parseAccountDelete(tx) {
      assert.ok(tx.TransactionType === "AccountDelete");
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        destination: tx.Destination,
        destinationTag: tx.DestinationTag,
        destinationXAddress: ripple_address_codec_1.classicAddressToXAddress(tx.Destination, tx.DestinationTag == null ? false : tx.DestinationTag, false)
      });
    }
    exports.default = parseAccountDelete;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/check-cancel.js
var require_check_cancel2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/check-cancel.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var common_1 = require_common();
    var utils_1 = require_utils7();
    function parseCheckCancel(tx) {
      assert.ok(tx.TransactionType === "CheckCancel");
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        checkID: tx.CheckID
      });
    }
    exports.default = parseCheckCancel;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/check-cash.js
var require_check_cash2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/check-cash.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var common_1 = require_common();
    var amount_1 = __importDefault(require_amount2());
    var utils_1 = require_utils7();
    function parseCheckCash(tx) {
      assert.ok(tx.TransactionType === "CheckCash");
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        checkID: tx.CheckID,
        amount: tx.Amount && amount_1.default(tx.Amount),
        deliverMin: tx.DeliverMin && amount_1.default(tx.DeliverMin)
      });
    }
    exports.default = parseCheckCash;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/check-create.js
var require_check_create2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/check-create.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var utils_1 = require_utils7();
    var common_1 = require_common();
    var amount_1 = __importDefault(require_amount2());
    var utils_2 = require_utils7();
    function parseCheckCreate(tx) {
      assert.ok(tx.TransactionType === "CheckCreate");
      return common_1.removeUndefined({
        memos: utils_2.parseMemos(tx),
        destination: tx.Destination,
        sendMax: amount_1.default(tx.SendMax),
        destinationTag: tx.DestinationTag,
        expiration: tx.Expiration && utils_1.parseTimestamp(tx.Expiration),
        invoiceID: tx.InvoiceID
      });
    }
    exports.default = parseCheckCreate;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/deposit-preauth.js
var require_deposit_preauth2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/deposit-preauth.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var common_1 = require_common();
    var utils_1 = require_utils7();
    function parseDepositPreauth(tx) {
      assert.ok(tx.TransactionType === "DepositPreauth");
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        authorize: tx.Authorize,
        unauthorize: tx.Unauthorize
      });
    }
    exports.default = parseDepositPreauth;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/escrow-cancellation.js
var require_escrow_cancellation2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/escrow-cancellation.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var utils_1 = require_utils7();
    var common_1 = require_common();
    function parseEscrowCancellation(tx) {
      assert.ok(tx.TransactionType === "EscrowCancel");
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        owner: tx.Owner,
        escrowSequence: tx.OfferSequence
      });
    }
    exports.default = parseEscrowCancellation;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/escrow-creation.js
var require_escrow_creation2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/escrow-creation.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var amount_1 = __importDefault(require_amount2());
    var utils_1 = require_utils7();
    var common_1 = require_common();
    function parseEscrowCreation(tx) {
      assert.ok(tx.TransactionType === "EscrowCreate");
      return common_1.removeUndefined({
        amount: amount_1.default(tx.Amount).value,
        destination: tx.Destination,
        memos: utils_1.parseMemos(tx),
        condition: tx.Condition,
        allowCancelAfter: utils_1.parseTimestamp(tx.CancelAfter),
        allowExecuteAfter: utils_1.parseTimestamp(tx.FinishAfter),
        sourceTag: tx.SourceTag,
        destinationTag: tx.DestinationTag
      });
    }
    exports.default = parseEscrowCreation;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/escrow-execution.js
var require_escrow_execution2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/escrow-execution.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var utils_1 = require_utils7();
    var common_1 = require_common();
    function parseEscrowExecution(tx) {
      assert.ok(tx.TransactionType === "EscrowFinish");
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        owner: tx.Owner,
        escrowSequence: tx.OfferSequence,
        condition: tx.Condition,
        fulfillment: tx.Fulfillment
      });
    }
    exports.default = parseEscrowExecution;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/cancellation.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var utils_1 = require_utils7();
    function parseOrderCancellation(tx) {
      assert.ok(tx.TransactionType === "OfferCancel");
      return {
        memos: utils_1.parseMemos(tx),
        orderSequence: tx.OfferSequence
      };
    }
    exports.default = parseOrderCancellation;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/order.js
var require_order2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/order.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var utils_1 = require_utils7();
    var utils_2 = require_utils7();
    var amount_1 = __importDefault(require_amount2());
    var common_1 = require_common();
    var flags = common_1.txFlags.OfferCreate;
    function parseOrder(tx) {
      assert.ok(tx.TransactionType === "OfferCreate");
      const direction = (tx.Flags & flags.Sell) === 0 ? "buy" : "sell";
      const takerGetsAmount = amount_1.default(tx.TakerGets);
      const takerPaysAmount = amount_1.default(tx.TakerPays);
      const quantity = direction === "buy" ? takerPaysAmount : takerGetsAmount;
      const totalPrice = direction === "buy" ? takerGetsAmount : takerPaysAmount;
      return common_1.removeUndefined({
        memos: utils_2.parseMemos(tx),
        direction,
        quantity,
        totalPrice,
        passive: (tx.Flags & flags.Passive) !== 0 || void 0,
        immediateOrCancel: (tx.Flags & flags.ImmediateOrCancel) !== 0 || void 0,
        fillOrKill: (tx.Flags & flags.FillOrKill) !== 0 || void 0,
        expirationTime: utils_1.parseTimestamp(tx.Expiration)
      });
    }
    exports.default = parseOrder;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/payment.js
var require_payment2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/payment.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var assert = __importStar(require_assert());
    var utils = __importStar(require_utils7());
    var common_1 = require_common();
    var amount_1 = __importDefault(require_amount2());
    function isNoDirectRipple(tx) {
      return (tx.Flags & common_1.txFlags.Payment.NoRippleDirect) !== 0;
    }
    function isQualityLimited(tx) {
      return (tx.Flags & common_1.txFlags.Payment.LimitQuality) !== 0;
    }
    function removeGenericCounterparty(amount, address) {
      return amount.counterparty === address ? _.omit(amount, "counterparty") : amount;
    }
    function parsePayment(tx) {
      assert.ok(tx.TransactionType === "Payment");
      const source = {
        address: tx.Account,
        maxAmount: removeGenericCounterparty(amount_1.default(tx.SendMax || tx.Amount), tx.Account),
        tag: tx.SourceTag
      };
      const destination = {
        address: tx.Destination,
        tag: tx.DestinationTag
      };
      return common_1.removeUndefined({
        source: common_1.removeUndefined(source),
        destination: common_1.removeUndefined(destination),
        memos: utils.parseMemos(tx),
        invoiceID: tx.InvoiceID,
        paths: tx.Paths ? JSON.stringify(tx.Paths) : void 0,
        allowPartialPayment: utils.isPartialPayment(tx) || void 0,
        noDirectRipple: isNoDirectRipple(tx) || void 0,
        limitQuality: isQualityLimited(tx) || void 0
      });
    }
    exports.default = parsePayment;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/payment-channel-claim.js
var require_payment_channel_claim2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/payment-channel-claim.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var common_1 = require_common();
    var amount_1 = __importDefault(require_amount2());
    var utils_1 = require_utils7();
    var claimFlags = common_1.txFlags.PaymentChannelClaim;
    function parsePaymentChannelClaim(tx) {
      assert.ok(tx.TransactionType === "PaymentChannelClaim");
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        channel: tx.Channel,
        balance: tx.Balance && amount_1.default(tx.Balance).value,
        amount: tx.Amount && amount_1.default(tx.Amount).value,
        signature: tx.Signature,
        publicKey: tx.PublicKey,
        renew: Boolean(tx.Flags & claimFlags.Renew) || void 0,
        close: Boolean(tx.Flags & claimFlags.Close) || void 0
      });
    }
    exports.default = parsePaymentChannelClaim;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/payment-channel-create.js
var require_payment_channel_create2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/payment-channel-create.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var utils_1 = require_utils7();
    var common_1 = require_common();
    var amount_1 = __importDefault(require_amount2());
    function parsePaymentChannelCreate(tx) {
      assert.ok(tx.TransactionType === "PaymentChannelCreate");
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        amount: amount_1.default(tx.Amount).value,
        destination: tx.Destination,
        settleDelay: tx.SettleDelay,
        publicKey: tx.PublicKey,
        cancelAfter: tx.CancelAfter && utils_1.parseTimestamp(tx.CancelAfter),
        sourceTag: tx.SourceTag,
        destinationTag: tx.DestinationTag
      });
    }
    exports.default = parsePaymentChannelCreate;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/payment-channel-fund.js
var require_payment_channel_fund2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/payment-channel-fund.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var utils_1 = require_utils7();
    var common_1 = require_common();
    var amount_1 = __importDefault(require_amount2());
    function parsePaymentChannelFund(tx) {
      assert.ok(tx.TransactionType === "PaymentChannelFund");
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        channel: tx.Channel,
        amount: amount_1.default(tx.Amount).value,
        expiration: tx.Expiration && utils_1.parseTimestamp(tx.Expiration)
      });
    }
    exports.default = parsePaymentChannelFund;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/ticket-create.js
var require_ticket_create = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/ticket-create.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var common_1 = require_common();
    var utils_1 = require_utils7();
    function parseTicketCreate(tx) {
      assert.ok(tx.TransactionType === "TicketCreate");
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        ticketCount: tx.TicketCount
      });
    }
    exports.default = parseTicketCreate;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/trustline.js
var require_trustline2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/trustline.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var utils_1 = require_utils7();
    var common_1 = require_common();
    var flags = common_1.txFlags.TrustSet;
    function parseFlag(flagsValue, trueValue, falseValue) {
      if (flagsValue & trueValue) {
        return true;
      }
      if (flagsValue & falseValue) {
        return false;
      }
      return void 0;
    }
    function parseTrustline(tx) {
      assert.ok(tx.TransactionType === "TrustSet");
      return common_1.removeUndefined({
        limit: tx.LimitAmount.value,
        currency: tx.LimitAmount.currency,
        counterparty: tx.LimitAmount.issuer,
        memos: utils_1.parseMemos(tx),
        qualityIn: utils_1.parseQuality(tx.QualityIn),
        qualityOut: utils_1.parseQuality(tx.QualityOut),
        ripplingDisabled: parseFlag(tx.Flags, flags.SetNoRipple, flags.ClearNoRipple),
        frozen: parseFlag(tx.Flags, flags.SetFreeze, flags.ClearFreeze),
        authorized: parseFlag(tx.Flags, flags.SetAuth, 0)
      });
    }
    exports.default = parseTrustline;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/amendment.js
var require_amendment = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/amendment.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function parseAmendment(tx) {
      return {
        amendment: tx.Amendment
      };
    }
    exports.default = parseAmendment;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/fee-update.js
var require_fee_update = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/fee-update.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_js_1 = __importDefault(require_bignumber());
    var common_1 = require_common();
    var utils_1 = require_utils7();
    function parseFeeUpdate(tx) {
      const baseFeeDrops = new bignumber_js_1.default(tx.BaseFee, 16).toString();
      return {
        memos: utils_1.parseMemos(tx),
        baseFeeXRP: common_1.dropsToXrp(baseFeeDrops),
        referenceFeeUnits: tx.ReferenceFeeUnits,
        reserveBaseXRP: common_1.dropsToXrp(tx.ReserveBase),
        reserveIncrementXRP: common_1.dropsToXrp(tx.ReserveIncrement)
      };
    }
    exports.default = parseFeeUpdate;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/transaction.js
var require_transaction = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/transaction.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils7();
    var common_1 = require_common();
    var settings_1 = __importDefault(require_settings2());
    var account_delete_1 = __importDefault(require_account_delete2());
    var check_cancel_1 = __importDefault(require_check_cancel2());
    var check_cash_1 = __importDefault(require_check_cash2());
    var check_create_1 = __importDefault(require_check_create2());
    var deposit_preauth_1 = __importDefault(require_deposit_preauth2());
    var escrow_cancellation_1 = __importDefault(require_escrow_cancellation2());
    var escrow_creation_1 = __importDefault(require_escrow_creation2());
    var escrow_execution_1 = __importDefault(require_escrow_execution2());
    var cancellation_1 = __importDefault(require_cancellation());
    var order_1 = __importDefault(require_order2());
    var payment_1 = __importDefault(require_payment2());
    var payment_channel_claim_1 = __importDefault(require_payment_channel_claim2());
    var payment_channel_create_1 = __importDefault(require_payment_channel_create2());
    var payment_channel_fund_1 = __importDefault(require_payment_channel_fund2());
    var ticket_create_1 = __importDefault(require_ticket_create());
    var trustline_1 = __importDefault(require_trustline2());
    var amendment_1 = __importDefault(require_amendment());
    var fee_update_1 = __importDefault(require_fee_update());
    function parseTransactionType(type) {
      const mapping = {
        AccountSet: "settings",
        AccountDelete: "accountDelete",
        CheckCancel: "checkCancel",
        CheckCash: "checkCash",
        CheckCreate: "checkCreate",
        DepositPreauth: "depositPreauth",
        EscrowCancel: "escrowCancellation",
        EscrowCreate: "escrowCreation",
        EscrowFinish: "escrowExecution",
        OfferCancel: "orderCancellation",
        OfferCreate: "order",
        Payment: "payment",
        PaymentChannelClaim: "paymentChannelClaim",
        PaymentChannelCreate: "paymentChannelCreate",
        PaymentChannelFund: "paymentChannelFund",
        SetRegularKey: "settings",
        SignerListSet: "settings",
        TicketCreate: "ticketCreate",
        TrustSet: "trustline",
        EnableAmendment: "amendment",
        SetFee: "feeUpdate"
      };
      return mapping[type] || null;
    }
    function parseTransaction(tx, includeRawTransaction) {
      const type = parseTransactionType(tx.TransactionType);
      const mapping = {
        settings: settings_1.default,
        accountDelete: account_delete_1.default,
        checkCancel: check_cancel_1.default,
        checkCash: check_cash_1.default,
        checkCreate: check_create_1.default,
        depositPreauth: deposit_preauth_1.default,
        escrowCancellation: escrow_cancellation_1.default,
        escrowCreation: escrow_creation_1.default,
        escrowExecution: escrow_execution_1.default,
        orderCancellation: cancellation_1.default,
        order: order_1.default,
        payment: payment_1.default,
        paymentChannelClaim: payment_channel_claim_1.default,
        paymentChannelCreate: payment_channel_create_1.default,
        paymentChannelFund: payment_channel_fund_1.default,
        ticketCreate: ticket_create_1.default,
        trustline: trustline_1.default,
        amendment: amendment_1.default,
        feeUpdate: fee_update_1.default
      };
      const parser = mapping[type];
      const specification = parser ? parser(tx) : {
        UNAVAILABLE: "Unrecognized transaction type.",
        SEE_RAW_TRANSACTION: "Since this type is unrecognized, `rawTransaction` is included in this response."
      };
      if (!parser) {
        includeRawTransaction = true;
      }
      const outcome = utils_1.parseOutcome(tx);
      return common_1.removeUndefined({
        type,
        address: tx.Account,
        sequence: tx.Sequence,
        id: tx.hash,
        specification: common_1.removeUndefined(specification),
        outcome: outcome ? common_1.removeUndefined(outcome) : void 0,
        rawTransaction: includeRawTransaction ? JSON.stringify(tx) : void 0
      });
    }
    exports.default = parseTransaction;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/transaction.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils5());
    var transaction_1 = __importDefault(require_transaction());
    var common_1 = require_common();
    function attachTransactionDate(connection, tx) {
      if (tx.date) {
        return Promise.resolve(tx);
      }
      const ledgerVersion = tx.ledger_index || tx.LedgerSequence;
      if (!ledgerVersion) {
        return new Promise(() => {
          const error = new common_1.errors.NotFoundError("Transaction has not been validated yet; try again later");
          error.data = {
            details: "(ledger_index and LedgerSequence not found in tx)"
          };
          throw error;
        });
      }
      const request = {
        command: "ledger",
        ledger_index: ledgerVersion
      };
      return connection.request(request).then((data) => {
        if (typeof data.ledger.close_time === "number") {
          return Object.assign({ date: data.ledger.close_time }, tx);
        }
        throw new common_1.errors.UnexpectedError("Ledger missing close_time");
      }).catch((error) => {
        if (error instanceof common_1.errors.UnexpectedError) {
          throw error;
        }
        throw new common_1.errors.NotFoundError("Transaction ledger not found");
      });
    }
    function isTransactionInRange(tx, options) {
      return (!options.minLedgerVersion || tx.ledger_index >= options.minLedgerVersion) && (!options.maxLedgerVersion || tx.ledger_index <= options.maxLedgerVersion);
    }
    function convertError(connection, options, error) {
      let shouldUseNotFoundError = false;
      if (error.data && error.data.error === "txnNotFound" || error.message === "txnNotFound") {
        shouldUseNotFoundError = true;
      }
      const _error = shouldUseNotFoundError ? new common_1.errors.NotFoundError("Transaction not found") : error;
      if (_error instanceof common_1.errors.NotFoundError) {
        return utils.hasCompleteLedgerRange(connection, options.minLedgerVersion, options.maxLedgerVersion).then((hasCompleteLedgerRange) => {
          if (!hasCompleteLedgerRange) {
            return utils.isPendingLedgerVersion(connection, options.maxLedgerVersion).then((isPendingLedgerVersion) => {
              return isPendingLedgerVersion ? new common_1.errors.PendingLedgerVersionError() : new common_1.errors.MissingLedgerHistoryError();
            });
          }
          return _error;
        });
      }
      return Promise.resolve(_error);
    }
    function formatResponse(options, tx) {
      if (tx.validated !== true || !isTransactionInRange(tx, options)) {
        throw new common_1.errors.NotFoundError("Transaction not found");
      }
      return transaction_1.default(tx, options.includeRawTransaction);
    }
    function getTransaction(id, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getTransaction({ id, options });
        const _options = yield utils.ensureLedgerVersion.call(this, options);
        try {
          const tx = yield this.request("tx", {
            transaction: id,
            binary: false
          });
          const txWithDate = yield attachTransactionDate(this.connection, tx);
          return formatResponse(_options, txWithDate);
        } catch (error) {
          throw yield convertError(this.connection, _options, error);
        }
      });
    }
    exports.default = getTransaction;
  }
});

// node_modules/ripple-binary-codec/dist/enums/definitions.json
var require_definitions = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/definitions.json"(exports, module) {
    module.exports = {
      TYPES: {
        Done: -1,
        Unknown: -2,
        NotPresent: 0,
        UInt16: 1,
        UInt32: 2,
        UInt64: 3,
        Hash128: 4,
        Hash256: 5,
        Amount: 6,
        Blob: 7,
        AccountID: 8,
        STObject: 14,
        STArray: 15,
        UInt8: 16,
        Hash160: 17,
        PathSet: 18,
        Vector256: 19,
        UInt96: 20,
        UInt192: 21,
        UInt384: 22,
        UInt512: 23,
        Issue: 24,
        XChainBridge: 25,
        Transaction: 10001,
        LedgerEntry: 10002,
        Validation: 10003,
        Metadata: 10004
      },
      LEDGER_ENTRY_TYPES: {
        Invalid: -1,
        AccountRoot: 97,
        DirectoryNode: 100,
        RippleState: 114,
        Ticket: 84,
        SignerList: 83,
        Offer: 111,
        Bridge: 105,
        LedgerHashes: 104,
        Amendments: 102,
        XChainOwnedClaimID: 113,
        XChainOwnedCreateAccountClaimID: 116,
        FeeSettings: 115,
        Escrow: 117,
        PayChannel: 120,
        Check: 67,
        DepositPreauth: 112,
        NegativeUNL: 78,
        NFTokenPage: 80,
        NFTokenOffer: 55,
        AMM: 121,
        DID: 73,
        Any: -3,
        Child: -2,
        Nickname: 110,
        Contract: 99,
        GeneratorMap: 103
      },
      FIELDS: [
        [
          "Generic",
          {
            nth: 0,
            isVLEncoded: false,
            isSerialized: false,
            isSigningField: false,
            type: "Unknown"
          }
        ],
        [
          "Invalid",
          {
            nth: -1,
            isVLEncoded: false,
            isSerialized: false,
            isSigningField: false,
            type: "Unknown"
          }
        ],
        [
          "ObjectEndMarker",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "ArrayEndMarker",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "hash",
          {
            nth: 257,
            isVLEncoded: false,
            isSerialized: false,
            isSigningField: false,
            type: "Hash256"
          }
        ],
        [
          "index",
          {
            nth: 258,
            isVLEncoded: false,
            isSerialized: false,
            isSigningField: false,
            type: "Hash256"
          }
        ],
        [
          "taker_gets_funded",
          {
            nth: 258,
            isVLEncoded: false,
            isSerialized: false,
            isSigningField: false,
            type: "Amount"
          }
        ],
        [
          "taker_pays_funded",
          {
            nth: 259,
            isVLEncoded: false,
            isSerialized: false,
            isSigningField: false,
            type: "Amount"
          }
        ],
        [
          "LedgerEntry",
          {
            nth: 257,
            isVLEncoded: false,
            isSerialized: false,
            isSigningField: false,
            type: "LedgerEntry"
          }
        ],
        [
          "Transaction",
          {
            nth: 257,
            isVLEncoded: false,
            isSerialized: false,
            isSigningField: false,
            type: "Transaction"
          }
        ],
        [
          "Validation",
          {
            nth: 257,
            isVLEncoded: false,
            isSerialized: false,
            isSigningField: false,
            type: "Validation"
          }
        ],
        [
          "Metadata",
          {
            nth: 257,
            isVLEncoded: false,
            isSerialized: false,
            isSigningField: false,
            type: "Metadata"
          }
        ],
        [
          "CloseResolution",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt8"
          }
        ],
        [
          "Method",
          {
            nth: 2,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt8"
          }
        ],
        [
          "TransactionResult",
          {
            nth: 3,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt8"
          }
        ],
        [
          "TickSize",
          {
            nth: 16,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt8"
          }
        ],
        [
          "UNLModifyDisabling",
          {
            nth: 17,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt8"
          }
        ],
        [
          "HookResult",
          {
            nth: 18,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt8"
          }
        ],
        [
          "WasLockingChainSend",
          {
            nth: 19,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt8"
          }
        ],
        [
          "LedgerEntryType",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "TransactionType",
          {
            nth: 2,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "SignerWeight",
          {
            nth: 3,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "TransferFee",
          {
            nth: 4,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "TradingFee",
          {
            nth: 5,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "DiscountedFee",
          {
            nth: 6,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "Version",
          {
            nth: 16,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "HookStateChangeCount",
          {
            nth: 17,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "HookEmitCount",
          {
            nth: 18,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "HookExecutionIndex",
          {
            nth: 19,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "HookApiVersion",
          {
            nth: 20,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt16"
          }
        ],
        [
          "NetworkID",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "Flags",
          {
            nth: 2,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "SourceTag",
          {
            nth: 3,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "Sequence",
          {
            nth: 4,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "PreviousTxnLgrSeq",
          {
            nth: 5,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "LedgerSequence",
          {
            nth: 6,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "CloseTime",
          {
            nth: 7,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "ParentCloseTime",
          {
            nth: 8,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "SigningTime",
          {
            nth: 9,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "Expiration",
          {
            nth: 10,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "TransferRate",
          {
            nth: 11,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "WalletSize",
          {
            nth: 12,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "OwnerCount",
          {
            nth: 13,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "DestinationTag",
          {
            nth: 14,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "HighQualityIn",
          {
            nth: 16,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "HighQualityOut",
          {
            nth: 17,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "LowQualityIn",
          {
            nth: 18,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "LowQualityOut",
          {
            nth: 19,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "QualityIn",
          {
            nth: 20,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "QualityOut",
          {
            nth: 21,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "StampEscrow",
          {
            nth: 22,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "BondAmount",
          {
            nth: 23,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "LoadFee",
          {
            nth: 24,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "OfferSequence",
          {
            nth: 25,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "FirstLedgerSequence",
          {
            nth: 26,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "LastLedgerSequence",
          {
            nth: 27,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "TransactionIndex",
          {
            nth: 28,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "OperationLimit",
          {
            nth: 29,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "ReferenceFeeUnits",
          {
            nth: 30,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "ReserveBase",
          {
            nth: 31,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "ReserveIncrement",
          {
            nth: 32,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "SetFlag",
          {
            nth: 33,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "ClearFlag",
          {
            nth: 34,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "SignerQuorum",
          {
            nth: 35,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "CancelAfter",
          {
            nth: 36,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "FinishAfter",
          {
            nth: 37,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "SignerListID",
          {
            nth: 38,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "SettleDelay",
          {
            nth: 39,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "TicketCount",
          {
            nth: 40,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "TicketSequence",
          {
            nth: 41,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "NFTokenTaxon",
          {
            nth: 42,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "MintedNFTokens",
          {
            nth: 43,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "BurnedNFTokens",
          {
            nth: 44,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "HookStateCount",
          {
            nth: 45,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "EmitGeneration",
          {
            nth: 46,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "VoteWeight",
          {
            nth: 48,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "FirstNFTokenSequence",
          {
            nth: 50,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt32"
          }
        ],
        [
          "IndexNext",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "IndexPrevious",
          {
            nth: 2,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "BookNode",
          {
            nth: 3,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "OwnerNode",
          {
            nth: 4,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "BaseFee",
          {
            nth: 5,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "ExchangeRate",
          {
            nth: 6,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "LowNode",
          {
            nth: 7,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "HighNode",
          {
            nth: 8,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "DestinationNode",
          {
            nth: 9,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "Cookie",
          {
            nth: 10,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "ServerVersion",
          {
            nth: 11,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "NFTokenOfferNode",
          {
            nth: 12,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "EmitBurden",
          {
            nth: 13,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "HookOn",
          {
            nth: 16,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "HookInstructionCount",
          {
            nth: 17,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "HookReturnCode",
          {
            nth: 18,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "ReferenceCount",
          {
            nth: 19,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "XChainClaimID",
          {
            nth: 20,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "XChainAccountCreateCount",
          {
            nth: 21,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "XChainAccountClaimCount",
          {
            nth: 22,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "UInt64"
          }
        ],
        [
          "EmailHash",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash128"
          }
        ],
        [
          "TakerPaysCurrency",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash160"
          }
        ],
        [
          "TakerPaysIssuer",
          {
            nth: 2,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash160"
          }
        ],
        [
          "TakerGetsCurrency",
          {
            nth: 3,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash160"
          }
        ],
        [
          "TakerGetsIssuer",
          {
            nth: 4,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash160"
          }
        ],
        [
          "LedgerHash",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "ParentHash",
          {
            nth: 2,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "TransactionHash",
          {
            nth: 3,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "AccountHash",
          {
            nth: 4,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "PreviousTxnID",
          {
            nth: 5,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "LedgerIndex",
          {
            nth: 6,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "WalletLocator",
          {
            nth: 7,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "RootIndex",
          {
            nth: 8,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "AccountTxnID",
          {
            nth: 9,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "NFTokenID",
          {
            nth: 10,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "EmitParentTxnID",
          {
            nth: 11,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "EmitNonce",
          {
            nth: 12,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "EmitHookHash",
          {
            nth: 13,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "AMMID",
          {
            nth: 14,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "BookDirectory",
          {
            nth: 16,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "InvoiceID",
          {
            nth: 17,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "Nickname",
          {
            nth: 18,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "Amendment",
          {
            nth: 19,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "Digest",
          {
            nth: 21,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "Channel",
          {
            nth: 22,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "ConsensusHash",
          {
            nth: 23,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "CheckID",
          {
            nth: 24,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "ValidatedHash",
          {
            nth: 25,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "PreviousPageMin",
          {
            nth: 26,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "NextPageMin",
          {
            nth: 27,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "NFTokenBuyOffer",
          {
            nth: 28,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "NFTokenSellOffer",
          {
            nth: 29,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "HookStateKey",
          {
            nth: 30,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "HookHash",
          {
            nth: 31,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "HookNamespace",
          {
            nth: 32,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "HookSetTxnID",
          {
            nth: 33,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Hash256"
          }
        ],
        [
          "Amount",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "Balance",
          {
            nth: 2,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "LimitAmount",
          {
            nth: 3,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "TakerPays",
          {
            nth: 4,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "TakerGets",
          {
            nth: 5,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "LowLimit",
          {
            nth: 6,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "HighLimit",
          {
            nth: 7,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "Fee",
          {
            nth: 8,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "SendMax",
          {
            nth: 9,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "DeliverMin",
          {
            nth: 10,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "Amount2",
          {
            nth: 11,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "BidMin",
          {
            nth: 12,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "BidMax",
          {
            nth: 13,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "MinimumOffer",
          {
            nth: 16,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "RippleEscrow",
          {
            nth: 17,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "DeliveredAmount",
          {
            nth: 18,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "NFTokenBrokerFee",
          {
            nth: 19,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "BaseFeeDrops",
          {
            nth: 22,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "ReserveBaseDrops",
          {
            nth: 23,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "ReserveIncrementDrops",
          {
            nth: 24,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "LPTokenOut",
          {
            nth: 25,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "LPTokenIn",
          {
            nth: 26,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "EPrice",
          {
            nth: 27,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "Price",
          {
            nth: 28,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "SignatureReward",
          {
            nth: 29,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "MinAccountCreateAmount",
          {
            nth: 30,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "LPTokenBalance",
          {
            nth: 31,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Amount"
          }
        ],
        [
          "PublicKey",
          {
            nth: 1,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "MessageKey",
          {
            nth: 2,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "SigningPubKey",
          {
            nth: 3,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "TxnSignature",
          {
            nth: 4,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: false,
            type: "Blob"
          }
        ],
        [
          "URI",
          {
            nth: 5,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "Signature",
          {
            nth: 6,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: false,
            type: "Blob"
          }
        ],
        [
          "Domain",
          {
            nth: 7,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "FundCode",
          {
            nth: 8,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "RemoveCode",
          {
            nth: 9,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "ExpireCode",
          {
            nth: 10,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "CreateCode",
          {
            nth: 11,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "MemoType",
          {
            nth: 12,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "MemoData",
          {
            nth: 13,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "MemoFormat",
          {
            nth: 14,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "Fulfillment",
          {
            nth: 16,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "Condition",
          {
            nth: 17,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "MasterSignature",
          {
            nth: 18,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: false,
            type: "Blob"
          }
        ],
        [
          "UNLModifyValidator",
          {
            nth: 19,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "ValidatorToDisable",
          {
            nth: 20,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "ValidatorToReEnable",
          {
            nth: 21,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "HookStateData",
          {
            nth: 22,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "HookReturnString",
          {
            nth: 23,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "HookParameterName",
          {
            nth: 24,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "HookParameterValue",
          {
            nth: 25,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "DIDDocument",
          {
            nth: 26,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "Data",
          {
            nth: 27,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Blob"
          }
        ],
        [
          "Account",
          {
            nth: 1,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "Owner",
          {
            nth: 2,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "Destination",
          {
            nth: 3,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "Issuer",
          {
            nth: 4,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "Authorize",
          {
            nth: 5,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "Unauthorize",
          {
            nth: 6,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "RegularKey",
          {
            nth: 8,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "NFTokenMinter",
          {
            nth: 9,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "EmitCallback",
          {
            nth: 10,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "HookAccount",
          {
            nth: 16,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "OtherChainSource",
          {
            nth: 18,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "OtherChainDestination",
          {
            nth: 19,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "AttestationSignerAccount",
          {
            nth: 20,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "AttestationRewardAccount",
          {
            nth: 21,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "LockingChainDoor",
          {
            nth: 22,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "IssuingChainDoor",
          {
            nth: 23,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "AccountID"
          }
        ],
        [
          "Indexes",
          {
            nth: 1,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Vector256"
          }
        ],
        [
          "Hashes",
          {
            nth: 2,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Vector256"
          }
        ],
        [
          "Amendments",
          {
            nth: 3,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Vector256"
          }
        ],
        [
          "NFTokenOffers",
          {
            nth: 4,
            isVLEncoded: true,
            isSerialized: true,
            isSigningField: true,
            type: "Vector256"
          }
        ],
        [
          "Paths",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "PathSet"
          }
        ],
        [
          "LockingChainIssue",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Issue"
          }
        ],
        [
          "IssuingChainIssue",
          {
            nth: 2,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Issue"
          }
        ],
        [
          "Asset",
          {
            nth: 3,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Issue"
          }
        ],
        [
          "Asset2",
          {
            nth: 4,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "Issue"
          }
        ],
        [
          "XChainBridge",
          {
            nth: 1,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "XChainBridge"
          }
        ],
        [
          "TransactionMetaData",
          {
            nth: 2,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "CreatedNode",
          {
            nth: 3,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "DeletedNode",
          {
            nth: 4,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "ModifiedNode",
          {
            nth: 5,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "PreviousFields",
          {
            nth: 6,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "FinalFields",
          {
            nth: 7,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "NewFields",
          {
            nth: 8,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "TemplateEntry",
          {
            nth: 9,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "Memo",
          {
            nth: 10,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "SignerEntry",
          {
            nth: 11,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "NFToken",
          {
            nth: 12,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "EmitDetails",
          {
            nth: 13,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "Hook",
          {
            nth: 14,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "Signer",
          {
            nth: 16,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "Majority",
          {
            nth: 18,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "DisabledValidator",
          {
            nth: 19,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "EmittedTxn",
          {
            nth: 20,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "HookExecution",
          {
            nth: 21,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "HookDefinition",
          {
            nth: 22,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "HookParameter",
          {
            nth: 23,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "HookGrant",
          {
            nth: 24,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "VoteEntry",
          {
            nth: 25,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "AuctionSlot",
          {
            nth: 26,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "AuthAccount",
          {
            nth: 27,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "XChainClaimProofSig",
          {
            nth: 28,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "XChainCreateAccountProofSig",
          {
            nth: 29,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "XChainClaimAttestationCollectionElement",
          {
            nth: 30,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "XChainCreateAccountAttestationCollectionElement",
          {
            nth: 31,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STObject"
          }
        ],
        [
          "Signers",
          {
            nth: 3,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: false,
            type: "STArray"
          }
        ],
        [
          "SignerEntries",
          {
            nth: 4,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "Template",
          {
            nth: 5,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "Necessary",
          {
            nth: 6,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "Sufficient",
          {
            nth: 7,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "AffectedNodes",
          {
            nth: 8,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "Memos",
          {
            nth: 9,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "NFTokens",
          {
            nth: 10,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "Hooks",
          {
            nth: 11,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "VoteSlots",
          {
            nth: 12,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "Majorities",
          {
            nth: 16,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "DisabledValidators",
          {
            nth: 17,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "HookExecutions",
          {
            nth: 18,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "HookParameters",
          {
            nth: 19,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "HookGrants",
          {
            nth: 20,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "XChainClaimAttestations",
          {
            nth: 21,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "XChainCreateAccountAttestations",
          {
            nth: 22,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ],
        [
          "AuthAccounts",
          {
            nth: 25,
            isVLEncoded: false,
            isSerialized: true,
            isSigningField: true,
            type: "STArray"
          }
        ]
      ],
      TRANSACTION_RESULTS: {
        telLOCAL_ERROR: -399,
        telBAD_DOMAIN: -398,
        telBAD_PATH_COUNT: -397,
        telBAD_PUBLIC_KEY: -396,
        telFAILED_PROCESSING: -395,
        telINSUF_FEE_P: -394,
        telNO_DST_PARTIAL: -393,
        telCAN_NOT_QUEUE: -392,
        telCAN_NOT_QUEUE_BALANCE: -391,
        telCAN_NOT_QUEUE_BLOCKS: -390,
        telCAN_NOT_QUEUE_BLOCKED: -389,
        telCAN_NOT_QUEUE_FEE: -388,
        telCAN_NOT_QUEUE_FULL: -387,
        telWRONG_NETWORK: -386,
        telREQUIRES_NETWORK_ID: -385,
        telNETWORK_ID_MAKES_TX_NON_CANONICAL: -384,
        temMALFORMED: -299,
        temBAD_AMOUNT: -298,
        temBAD_CURRENCY: -297,
        temBAD_EXPIRATION: -296,
        temBAD_FEE: -295,
        temBAD_ISSUER: -294,
        temBAD_LIMIT: -293,
        temBAD_OFFER: -292,
        temBAD_PATH: -291,
        temBAD_PATH_LOOP: -290,
        temBAD_REGKEY: -289,
        temBAD_SEND_XRP_LIMIT: -288,
        temBAD_SEND_XRP_MAX: -287,
        temBAD_SEND_XRP_NO_DIRECT: -286,
        temBAD_SEND_XRP_PARTIAL: -285,
        temBAD_SEND_XRP_PATHS: -284,
        temBAD_SEQUENCE: -283,
        temBAD_SIGNATURE: -282,
        temBAD_SRC_ACCOUNT: -281,
        temBAD_TRANSFER_RATE: -280,
        temDST_IS_SRC: -279,
        temDST_NEEDED: -278,
        temINVALID: -277,
        temINVALID_FLAG: -276,
        temREDUNDANT: -275,
        temRIPPLE_EMPTY: -274,
        temDISABLED: -273,
        temBAD_SIGNER: -272,
        temBAD_QUORUM: -271,
        temBAD_WEIGHT: -270,
        temBAD_TICK_SIZE: -269,
        temINVALID_ACCOUNT_ID: -268,
        temCANNOT_PREAUTH_SELF: -267,
        temINVALID_COUNT: -266,
        temUNCERTAIN: -265,
        temUNKNOWN: -264,
        temSEQ_AND_TICKET: -263,
        temBAD_NFTOKEN_TRANSFER_FEE: -262,
        temBAD_AMM_TOKENS: -261,
        temXCHAIN_EQUAL_DOOR_ACCOUNTS: -260,
        temXCHAIN_BAD_PROOF: -259,
        temXCHAIN_BRIDGE_BAD_ISSUES: -258,
        temXCHAIN_BRIDGE_NONDOOR_OWNER: -257,
        temXCHAIN_BRIDGE_BAD_MIN_ACCOUNT_CREATE_AMOUNT: -256,
        temXCHAIN_BRIDGE_BAD_REWARD_AMOUNT: -255,
        temEMPTY_DID: -254,
        tefFAILURE: -199,
        tefALREADY: -198,
        tefBAD_ADD_AUTH: -197,
        tefBAD_AUTH: -196,
        tefBAD_LEDGER: -195,
        tefCREATED: -194,
        tefEXCEPTION: -193,
        tefINTERNAL: -192,
        tefNO_AUTH_REQUIRED: -191,
        tefPAST_SEQ: -190,
        tefWRONG_PRIOR: -189,
        tefMASTER_DISABLED: -188,
        tefMAX_LEDGER: -187,
        tefBAD_SIGNATURE: -186,
        tefBAD_QUORUM: -185,
        tefNOT_MULTI_SIGNING: -184,
        tefBAD_AUTH_MASTER: -183,
        tefINVARIANT_FAILED: -182,
        tefTOO_BIG: -181,
        tefNO_TICKET: -180,
        tefNFTOKEN_IS_NOT_TRANSFERABLE: -179,
        terRETRY: -99,
        terFUNDS_SPENT: -98,
        terINSUF_FEE_B: -97,
        terNO_ACCOUNT: -96,
        terNO_AUTH: -95,
        terNO_LINE: -94,
        terOWNERS: -93,
        terPRE_SEQ: -92,
        terLAST: -91,
        terNO_RIPPLE: -90,
        terQUEUED: -89,
        terPRE_TICKET: -88,
        terNO_AMM: -87,
        terSUBMITTED: -86,
        tesSUCCESS: 0,
        tecCLAIM: 100,
        tecPATH_PARTIAL: 101,
        tecUNFUNDED_ADD: 102,
        tecUNFUNDED_OFFER: 103,
        tecUNFUNDED_PAYMENT: 104,
        tecFAILED_PROCESSING: 105,
        tecDIR_FULL: 121,
        tecINSUF_RESERVE_LINE: 122,
        tecINSUF_RESERVE_OFFER: 123,
        tecNO_DST: 124,
        tecNO_DST_INSUF_XRP: 125,
        tecNO_LINE_INSUF_RESERVE: 126,
        tecNO_LINE_REDUNDANT: 127,
        tecPATH_DRY: 128,
        tecUNFUNDED: 129,
        tecNO_ALTERNATIVE_KEY: 130,
        tecNO_REGULAR_KEY: 131,
        tecOWNERS: 132,
        tecNO_ISSUER: 133,
        tecNO_AUTH: 134,
        tecNO_LINE: 135,
        tecINSUFF_FEE: 136,
        tecFROZEN: 137,
        tecNO_TARGET: 138,
        tecNO_PERMISSION: 139,
        tecNO_ENTRY: 140,
        tecINSUFFICIENT_RESERVE: 141,
        tecNEED_MASTER_KEY: 142,
        tecDST_TAG_NEEDED: 143,
        tecINTERNAL: 144,
        tecOVERSIZE: 145,
        tecCRYPTOCONDITION_ERROR: 146,
        tecINVARIANT_FAILED: 147,
        tecEXPIRED: 148,
        tecDUPLICATE: 149,
        tecKILLED: 150,
        tecHAS_OBLIGATIONS: 151,
        tecTOO_SOON: 152,
        tecHOOK_REJECTED: 153,
        tecMAX_SEQUENCE_REACHED: 154,
        tecNO_SUITABLE_NFTOKEN_PAGE: 155,
        tecNFTOKEN_BUY_SELL_MISMATCH: 156,
        tecNFTOKEN_OFFER_TYPE_MISMATCH: 157,
        tecCANT_ACCEPT_OWN_NFTOKEN_OFFER: 158,
        tecINSUFFICIENT_FUNDS: 159,
        tecOBJECT_NOT_FOUND: 160,
        tecINSUFFICIENT_PAYMENT: 161,
        tecUNFUNDED_AMM: 162,
        tecAMM_BALANCE: 163,
        tecAMM_FAILED: 164,
        tecAMM_INVALID_TOKENS: 165,
        tecAMM_EMPTY: 166,
        tecAMM_NOT_EMPTY: 167,
        tecAMM_ACCOUNT: 168,
        tecINCOMPLETE: 169,
        tecXCHAIN_BAD_TRANSFER_ISSUE: 170,
        tecXCHAIN_NO_CLAIM_ID: 171,
        tecXCHAIN_BAD_CLAIM_ID: 172,
        tecXCHAIN_CLAIM_NO_QUORUM: 173,
        tecXCHAIN_PROOF_UNKNOWN_KEY: 174,
        tecXCHAIN_CREATE_ACCOUNT_NONXRP_ISSUE: 175,
        tecXCHAIN_WRONG_CHAIN: 176,
        tecXCHAIN_REWARD_MISMATCH: 177,
        tecXCHAIN_NO_SIGNERS_LIST: 178,
        tecXCHAIN_SENDING_ACCOUNT_MISMATCH: 179,
        tecXCHAIN_INSUFF_CREATE_AMOUNT: 180,
        tecXCHAIN_ACCOUNT_CREATE_PAST: 181,
        tecXCHAIN_ACCOUNT_CREATE_TOO_MANY: 182,
        tecXCHAIN_PAYMENT_FAILED: 183,
        tecXCHAIN_SELF_COMMIT: 184,
        tecXCHAIN_BAD_PUBLIC_KEY_ACCOUNT_PAIR: 185,
        tecXCHAIN_CREATE_ACCOUNT_DISABLED: 186,
        tecEMPTY_DID: 187
      },
      TRANSACTION_TYPES: {
        Invalid: -1,
        Payment: 0,
        EscrowCreate: 1,
        EscrowFinish: 2,
        AccountSet: 3,
        EscrowCancel: 4,
        SetRegularKey: 5,
        NickNameSet: 6,
        OfferCreate: 7,
        OfferCancel: 8,
        Contract: 9,
        TicketCreate: 10,
        TicketCancel: 11,
        SignerListSet: 12,
        PaymentChannelCreate: 13,
        PaymentChannelFund: 14,
        PaymentChannelClaim: 15,
        CheckCreate: 16,
        CheckCash: 17,
        CheckCancel: 18,
        DepositPreauth: 19,
        TrustSet: 20,
        AccountDelete: 21,
        SetHook: 22,
        NFTokenMint: 25,
        NFTokenBurn: 26,
        NFTokenCreateOffer: 27,
        NFTokenCancelOffer: 28,
        NFTokenAcceptOffer: 29,
        Clawback: 30,
        AMMCreate: 35,
        AMMDeposit: 36,
        AMMWithdraw: 37,
        AMMVote: 38,
        AMMBid: 39,
        AMMDelete: 40,
        XChainCreateClaimID: 41,
        XChainCommit: 42,
        XChainClaim: 43,
        XChainAccountCreateCommit: 44,
        XChainAddClaimAttestation: 45,
        XChainAddAccountCreateAttestation: 46,
        XChainModifyBridge: 47,
        XChainCreateBridge: 48,
        DIDSet: 49,
        DIDDelete: 50,
        EnableAmendment: 100,
        SetFee: 101,
        UNLModify: 102
      }
    };
  }
});

// node_modules/ripple-binary-codec/dist/enums/bytes.js
var require_bytes = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/bytes.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BytesLookup = exports.Bytes = void 0;
    var buffer_1 = require_dist();
    var Bytes = class {
      constructor(name, ordinal, ordinalWidth) {
        this.name = name;
        this.ordinal = ordinal;
        this.ordinalWidth = ordinalWidth;
        this.bytes = buffer_1.Buffer.alloc(ordinalWidth);
        for (let i = 0; i < ordinalWidth; i++) {
          this.bytes[ordinalWidth - i - 1] = ordinal >>> i * 8 & 255;
        }
      }
      toJSON() {
        return this.name;
      }
      toBytesSink(sink) {
        sink.put(this.bytes);
      }
      toBytes() {
        return this.bytes;
      }
    };
    exports.Bytes = Bytes;
    var BytesLookup = class {
      constructor(types, ordinalWidth) {
        this.ordinalWidth = ordinalWidth;
        Object.entries(types).forEach(([k, v]) => {
          this.add(k, v);
        });
      }
      /**
       * Add a new name value pair to the BytesLookup.
       *
       * @param name - A human readable name for the field.
       * @param value - The numeric value for the field.
       * @throws if the name or value already exist in the lookup because it's unclear how to decode.
       */
      add(name, value) {
        if (this[name]) {
          throw new SyntaxError(`Attempted to add a value with a duplicate name "${name}". This is not allowed because it is unclear how to decode.`);
        }
        if (this[value.toString()]) {
          throw new SyntaxError(`Attempted to add a duplicate value under a different name (Given name: "${name}" and previous name: "${this[value.toString()]}. This is not allowed because it is unclear how to decode.
Given value: ${value.toString()}`);
        }
        this[name] = new Bytes(name, value, this.ordinalWidth);
        this[value.toString()] = this[name];
      }
      from(value) {
        return value instanceof Bytes ? value : this[value];
      }
      fromParser(parser) {
        return this.from(parser.readUIntN(this.ordinalWidth).toString());
      }
    };
    exports.BytesLookup = BytesLookup;
  }
});

// node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js
var require_binary_serializer = __commonJS({
  "node_modules/ripple-binary-codec/dist/serdes/binary-serializer.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BinarySerializer = exports.BytesList = void 0;
    var assert = __importStar(require_assert());
    var buffer_1 = require_dist();
    var BytesList = class {
      constructor() {
        this.bytesArray = [];
      }
      /**
       * Get the total number of bytes in the BytesList
       *
       * @return the number of bytes
       */
      getLength() {
        return buffer_1.Buffer.concat(this.bytesArray).byteLength;
      }
      /**
       * Put bytes in the BytesList
       *
       * @param bytesArg A Buffer
       * @return this BytesList
       */
      put(bytesArg) {
        const bytes = buffer_1.Buffer.from(bytesArg);
        this.bytesArray.push(bytes);
        return this;
      }
      /**
       * Write this BytesList to the back of another bytes list
       *
       *  @param list The BytesList to write to
       */
      toBytesSink(list) {
        list.put(this.toBytes());
      }
      toBytes() {
        return buffer_1.Buffer.concat(this.bytesArray);
      }
      toHex() {
        return this.toBytes().toString("hex").toUpperCase();
      }
    };
    exports.BytesList = BytesList;
    var BinarySerializer = class {
      constructor(sink) {
        this.sink = new BytesList();
        this.sink = sink;
      }
      /**
       * Write a value to this BinarySerializer
       *
       * @param value a SerializedType value
       */
      write(value) {
        value.toBytesSink(this.sink);
      }
      /**
       * Write bytes to this BinarySerializer
       *
       * @param bytes the bytes to write
       */
      put(bytes) {
        this.sink.put(bytes);
      }
      /**
       * Write a value of a given type to this BinarySerializer
       *
       * @param type the type to write
       * @param value a value of that type
       */
      writeType(type, value) {
        this.write(type.from(value));
      }
      /**
       * Write BytesList to this BinarySerializer
       *
       * @param bl BytesList to write to BinarySerializer
       */
      writeBytesList(bl) {
        bl.toBytesSink(this.sink);
      }
      /**
       * Calculate the header of Variable Length encoded bytes
       *
       * @param length the length of the bytes
       */
      encodeVariableLength(length) {
        const lenBytes = buffer_1.Buffer.alloc(3);
        if (length <= 192) {
          lenBytes[0] = length;
          return lenBytes.slice(0, 1);
        } else if (length <= 12480) {
          length -= 193;
          lenBytes[0] = 193 + (length >>> 8);
          lenBytes[1] = length & 255;
          return lenBytes.slice(0, 2);
        } else if (length <= 918744) {
          length -= 12481;
          lenBytes[0] = 241 + (length >>> 16);
          lenBytes[1] = length >> 8 & 255;
          lenBytes[2] = length & 255;
          return lenBytes.slice(0, 3);
        }
        throw new Error("Overflow error");
      }
      /**
       * Write field and value to BinarySerializer
       *
       * @param field field to write to BinarySerializer
       * @param value value to write to BinarySerializer
       */
      writeFieldAndValue(field, value, isUnlModifyWorkaround = false) {
        const associatedValue = field.associatedType.from(value);
        assert.ok(associatedValue.toBytesSink !== void 0);
        assert.ok(field.name !== void 0);
        this.sink.put(field.header);
        if (field.isVariableLengthEncoded) {
          this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
        } else {
          associatedValue.toBytesSink(this.sink);
        }
      }
      /**
       * Write a variable length encoded value to the BinarySerializer
       *
       * @param value length encoded value to write to BytesList
       */
      writeLengthEncoded(value, isUnlModifyWorkaround = false) {
        const bytes = new BytesList();
        if (!isUnlModifyWorkaround) {
          value.toBytesSink(bytes);
        }
        this.put(this.encodeVariableLength(bytes.getLength()));
        this.writeBytesList(bytes);
      }
    };
    exports.BinarySerializer = BinarySerializer;
  }
});

// node_modules/ripple-binary-codec/dist/types/serialized-type.js
var require_serialized_type = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/serialized-type.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Comparable = exports.SerializedType = void 0;
    var binary_serializer_1 = require_binary_serializer();
    var buffer_1 = require_dist();
    var SerializedType = class {
      constructor(bytes) {
        this.bytes = buffer_1.Buffer.alloc(0);
        this.bytes = bytes !== null && bytes !== void 0 ? bytes : buffer_1.Buffer.alloc(0);
      }
      static fromParser(parser, hint) {
        throw new Error("fromParser not implemented");
        return this.fromParser(parser, hint);
      }
      static from(value) {
        throw new Error("from not implemented");
        return this.from(value);
      }
      /**
       * Write the bytes representation of a SerializedType to a BytesList
       *
       * @param list The BytesList to write SerializedType bytes to
       */
      toBytesSink(list) {
        list.put(this.bytes);
      }
      /**
       * Get the hex representation of a SerializedType's bytes
       *
       * @returns hex String of this.bytes
       */
      toHex() {
        return this.toBytes().toString("hex").toUpperCase();
      }
      /**
       * Get the bytes representation of a SerializedType
       *
       * @returns A buffer of the bytes
       */
      toBytes() {
        if (this.bytes) {
          return this.bytes;
        }
        const bytes = new binary_serializer_1.BytesList();
        this.toBytesSink(bytes);
        return bytes.toBytes();
      }
      /**
       * Return the JSON representation of a SerializedType
       *
       * @param _definitions rippled definitions used to parse the values of transaction types and such.
       *                          Unused in default, but used in STObject, STArray
       *                          Can be customized for sidechains and amendments.
       * @returns any type, if not overloaded returns hexString representation of bytes
       */
      toJSON(_definitions) {
        return this.toHex();
      }
      /**
       * @returns hexString representation of this.bytes
       */
      toString() {
        return this.toHex();
      }
    };
    exports.SerializedType = SerializedType;
    var Comparable = class extends SerializedType {
      lt(other) {
        return this.compareTo(other) < 0;
      }
      eq(other) {
        return this.compareTo(other) === 0;
      }
      gt(other) {
        return this.compareTo(other) > 0;
      }
      gte(other) {
        return this.compareTo(other) > -1;
      }
      lte(other) {
        return this.compareTo(other) < 1;
      }
      /**
       * Overload this method to define how two Comparable SerializedTypes are compared
       *
       * @param other The comparable object to compare this to
       * @returns A number denoting the relationship of this and other
       */
      compareTo(other) {
        throw new Error(`cannot compare ${this.toString()} and ${other.toString()}`);
      }
    };
    exports.Comparable = Comparable;
  }
});

// node_modules/ripple-binary-codec/dist/enums/constants.js
var require_constants2 = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/constants.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TRANSACTION_RESULT_WIDTH = exports.TRANSACTION_TYPE_WIDTH = exports.LEDGER_ENTRY_WIDTH = exports.TYPE_WIDTH = void 0;
    exports.TYPE_WIDTH = 2;
    exports.LEDGER_ENTRY_WIDTH = 2;
    exports.TRANSACTION_TYPE_WIDTH = 2;
    exports.TRANSACTION_RESULT_WIDTH = 1;
  }
});

// node_modules/ripple-binary-codec/dist/enums/field.js
var require_field = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/field.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FieldLookup = void 0;
    var bytes_1 = require_bytes();
    var serialized_type_1 = require_serialized_type();
    var constants_1 = require_constants2();
    var buffer_1 = require_dist();
    function fieldHeader(type, nth) {
      const header = [];
      if (type < 16) {
        if (nth < 16) {
          header.push(type << 4 | nth);
        } else {
          header.push(type << 4, nth);
        }
      } else if (nth < 16) {
        header.push(nth, type);
      } else {
        header.push(0, type, nth);
      }
      return buffer_1.Buffer.from(header);
    }
    function buildField([name, info], typeOrdinal) {
      const field = fieldHeader(typeOrdinal, info.nth);
      return {
        name,
        nth: info.nth,
        isVariableLengthEncoded: info.isVLEncoded,
        isSerialized: info.isSerialized,
        isSigningField: info.isSigningField,
        ordinal: typeOrdinal << 16 | info.nth,
        type: new bytes_1.Bytes(info.type, typeOrdinal, constants_1.TYPE_WIDTH),
        header: field,
        associatedType: serialized_type_1.SerializedType
        // For later assignment in ./types/index.js or Definitions.updateAll(...)
      };
    }
    var FieldLookup = class {
      constructor(fields, types) {
        fields.forEach(([name, field_info]) => {
          const typeOrdinal = types[field_info.type];
          this[name] = buildField([name, field_info], typeOrdinal);
          this[this[name].ordinal.toString()] = this[name];
        });
      }
      fromString(value) {
        return this[value];
      }
    };
    exports.FieldLookup = FieldLookup;
  }
});

// node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js
var require_xrpl_definitions_base = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/xrpl-definitions-base.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BytesLookup = exports.Bytes = exports.FieldLookup = exports.XrplDefinitionsBase = void 0;
    var bytes_1 = require_bytes();
    Object.defineProperty(exports, "Bytes", { enumerable: true, get: function() {
      return bytes_1.Bytes;
    } });
    Object.defineProperty(exports, "BytesLookup", { enumerable: true, get: function() {
      return bytes_1.BytesLookup;
    } });
    var field_1 = require_field();
    Object.defineProperty(exports, "FieldLookup", { enumerable: true, get: function() {
      return field_1.FieldLookup;
    } });
    var constants_1 = require_constants2();
    var XrplDefinitionsBase = class {
      /**
       * Present rippled types in a typed and updatable format.
       * For an example of the input format see `definitions.json`
       * To generate a new definitions file from rippled source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen
       *
       * See the definitions.test.js file for examples of how to create your own updated definitions.json.
       *
       * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
       * @param types - A list of type objects with the same name as the fields defined.
       *              You can use the coreTypes object if you are not adding new types.
       */
      constructor(enums, types) {
        this.type = new bytes_1.BytesLookup(enums.TYPES, constants_1.TYPE_WIDTH);
        this.ledgerEntryType = new bytes_1.BytesLookup(enums.LEDGER_ENTRY_TYPES, constants_1.LEDGER_ENTRY_WIDTH);
        this.transactionType = new bytes_1.BytesLookup(enums.TRANSACTION_TYPES, constants_1.TRANSACTION_TYPE_WIDTH);
        this.transactionResult = new bytes_1.BytesLookup(enums.TRANSACTION_RESULTS, constants_1.TRANSACTION_RESULT_WIDTH);
        this.field = new field_1.FieldLookup(enums.FIELDS, enums.TYPES);
        this.transactionNames = Object.entries(enums.TRANSACTION_TYPES).filter(([_key, value]) => value >= 0).map(([key, _value]) => key);
        this.dataTypes = {};
        this.associateTypes(types);
      }
      /**
       * Associates each Field to a corresponding class that TypeScript can recognize.
       *
       * @param types a list of type objects with the same name as the fields defined.
       *              Defaults to xrpl.js's core type definitions.
       */
      associateTypes(types) {
        this.dataTypes = Object.assign({}, this.dataTypes, types);
        Object.values(this.field).forEach((field) => {
          field.associatedType = this.dataTypes[field.type.name];
        });
        this.field["TransactionType"].associatedType = this.transactionType;
        this.field["TransactionResult"].associatedType = this.transactionResult;
        this.field["LedgerEntryType"].associatedType = this.ledgerEntryType;
      }
      getAssociatedTypes() {
        return this.dataTypes;
      }
    };
    exports.XrplDefinitionsBase = XrplDefinitionsBase;
  }
});

// node_modules/ripple-binary-codec/dist/enums/index.js
var require_enums = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/index.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TRANSACTION_TYPES = exports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.Bytes = void 0;
    var enums = __importStar(require_definitions());
    var xrpl_definitions_base_1 = require_xrpl_definitions_base();
    Object.defineProperty(exports, "XrplDefinitionsBase", { enumerable: true, get: function() {
      return xrpl_definitions_base_1.XrplDefinitionsBase;
    } });
    Object.defineProperty(exports, "Bytes", { enumerable: true, get: function() {
      return xrpl_definitions_base_1.Bytes;
    } });
    var DEFAULT_DEFINITIONS = new xrpl_definitions_base_1.XrplDefinitionsBase(enums, {});
    exports.DEFAULT_DEFINITIONS = DEFAULT_DEFINITIONS;
    var Type = DEFAULT_DEFINITIONS.type;
    exports.Type = Type;
    var LedgerEntryType = DEFAULT_DEFINITIONS.ledgerEntryType;
    exports.LedgerEntryType = LedgerEntryType;
    var TransactionType = DEFAULT_DEFINITIONS.transactionType;
    exports.TransactionType = TransactionType;
    var TransactionResult = DEFAULT_DEFINITIONS.transactionResult;
    exports.TransactionResult = TransactionResult;
    var Field = DEFAULT_DEFINITIONS.field;
    exports.Field = Field;
    var TRANSACTION_TYPES = DEFAULT_DEFINITIONS.transactionNames;
    exports.TRANSACTION_TYPES = TRANSACTION_TYPES;
  }
});

// node_modules/ripple-binary-codec/dist/types/hash.js
var require_hash2 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/hash.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = void 0;
    var serialized_type_1 = require_serialized_type();
    var buffer_1 = require_dist();
    var Hash = class extends serialized_type_1.Comparable {
      constructor(bytes) {
        super(bytes);
        if (this.bytes.byteLength !== this.constructor.width) {
          throw new Error(`Invalid Hash length ${this.bytes.byteLength}`);
        }
      }
      /**
       * Construct a Hash object from an existing Hash object or a hex-string
       *
       * @param value A hash object or hex-string of a hash
       */
      static from(value) {
        if (value instanceof this) {
          return value;
        }
        if (typeof value === "string") {
          return new this(buffer_1.Buffer.from(value, "hex"));
        }
        throw new Error("Cannot construct Hash from given value");
      }
      /**
       * Read a Hash object from a BinaryParser
       *
       * @param parser BinaryParser to read the hash from
       * @param hint length of the bytes to read, optional
       */
      static fromParser(parser, hint) {
        return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));
      }
      /**
       * Overloaded operator for comparing two hash objects
       *
       * @param other The Hash to compare this to
       */
      compareTo(other) {
        return this.bytes.compare(this.constructor.from(other).bytes);
      }
      /**
       * @returns the hex-string representation of this Hash
       */
      toString() {
        return this.toHex();
      }
      /**
       * Returns four bits at the specified depth within a hash
       *
       * @param depth The depth of the four bits
       * @returns The number represented by the four bits
       */
      nibblet(depth) {
        const byteIx = depth > 0 ? depth / 2 | 0 : 0;
        let b = this.bytes[byteIx];
        if (depth % 2 === 0) {
          b = (b & 240) >>> 4;
        } else {
          b = b & 15;
        }
        return b;
      }
    };
    exports.Hash = Hash;
  }
});

// node_modules/ripple-binary-codec/dist/types/hash-160.js
var require_hash_160 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/hash-160.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash160 = void 0;
    var hash_1 = require_hash2();
    var buffer_1 = require_dist();
    var Hash160 = class _Hash160 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash160.ZERO_160.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash160.ZERO_160.bytes);
      }
    };
    exports.Hash160 = Hash160;
    Hash160.width = 20;
    Hash160.ZERO_160 = new Hash160(buffer_1.Buffer.alloc(Hash160.width));
  }
});

// node_modules/ripple-binary-codec/dist/types/account-id.js
var require_account_id = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/account-id.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountID = void 0;
    var ripple_address_codec_1 = require_dist4();
    var hash_160_1 = require_hash_160();
    var buffer_1 = require_dist();
    var HEX_REGEX = /^[A-F0-9]{40}$/;
    var AccountID = class _AccountID extends hash_160_1.Hash160 {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _AccountID.defaultAccountID.bytes);
      }
      /**
       * Defines how to construct an AccountID
       *
       * @param value either an existing AccountID, a hex-string, or a base58 r-Address
       * @returns an AccountID object
       */
      static from(value) {
        if (value instanceof _AccountID) {
          return value;
        }
        if (typeof value === "string") {
          if (value === "") {
            return new _AccountID();
          }
          return HEX_REGEX.test(value) ? new _AccountID(buffer_1.Buffer.from(value, "hex")) : this.fromBase58(value);
        }
        throw new Error("Cannot construct AccountID from value given");
      }
      /**
       * Defines how to build an AccountID from a base58 r-Address
       *
       * @param value a base58 r-Address
       * @returns an AccountID object
       */
      static fromBase58(value) {
        if ((0, ripple_address_codec_1.isValidXAddress)(value)) {
          const classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(value);
          if (classic.tag !== false)
            throw new Error("Only allowed to have tag on Account or Destination");
          value = classic.classicAddress;
        }
        return new _AccountID(buffer_1.Buffer.from((0, ripple_address_codec_1.decodeAccountID)(value)));
      }
      /**
       * Overload of toJSON
       *
       * @returns the base58 string for this AccountID
       */
      toJSON() {
        return this.toBase58();
      }
      /**
       * Defines how to encode AccountID into a base58 address
       *
       * @returns the base58 string defined by this.bytes
       */
      toBase58() {
        return (0, ripple_address_codec_1.encodeAccountID)(this.bytes);
      }
    };
    exports.AccountID = AccountID;
    AccountID.defaultAccountID = new AccountID(buffer_1.Buffer.alloc(20));
  }
});

// node_modules/decimal.js/decimal.js
var require_decimal = __commonJS({
  "node_modules/decimal.js/decimal.js"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    (function(globalScope) {
      "use strict";
      var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.
        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,
        // 1 to MAX_DIGITS
        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,
        // 0 to 8
        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,
        // 0 to 9
        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,
        // 0 to -EXP_LIMIT
        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos: 21,
        // 0 to EXP_LIMIT
        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT,
        // -1 to -EXP_LIMIT
        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT,
        // 1 to EXP_LIMIT
        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false
        // true/false
      }, Decimal, inexact, noConflict, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = { toStringTag: tag };
      P.absoluteValue = P.abs = function() {
        var x = new this.constructor(this);
        if (x.s < 0) x.s = 1;
        return finalise(x);
      };
      P.ceil = function() {
        return finalise(new this.constructor(this), this.e + 1, 2);
      };
      P.clampedTo = P.clamp = function(min2, max2) {
        var k, x = this, Ctor = x.constructor;
        min2 = new Ctor(min2);
        max2 = new Ctor(max2);
        if (!min2.s || !max2.s) return new Ctor(NaN);
        if (min2.gt(max2)) throw Error(invalidArgument + max2);
        k = x.cmp(min2);
        return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
      };
      P.comparedTo = P.cmp = function(y) {
        var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        }
        if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
        if (xs !== ys) return xs;
        if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
        xdL = xd.length;
        ydL = yd.length;
        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };
      P.cosine = P.cos = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.d) return new Ctor(NaN);
        if (!x.d[0]) return new Ctor(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
      };
      P.cubeRoot = P.cbrt = function() {
        var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        external = false;
        s = x.s * mathpow(x.s * x, 1 / 3);
        if (!s || Math.abs(s) == 1 / 0) {
          n = digitsToString(x.d);
          e = x.e;
          if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
          s = mathpow(n, 1 / 3);
          e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
          r.s = x.s;
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          t3 = t.times(t).times(t);
          t3plusx = t3.plus(x);
          r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e + 1, 0);
                if (t.times(t).times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e + 1, 1);
                m = !r.times(r).times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e, Ctor.rounding, m);
      };
      P.decimalPlaces = P.dp = function() {
        var w, d = this.d, n = NaN;
        if (d) {
          w = d.length - 1;
          n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
          w = d[w];
          if (w) for (; w % 10 == 0; w /= 10) n--;
          if (n < 0) n = 0;
        }
        return n;
      };
      P.dividedBy = P.div = function(y) {
        return divide(this, new this.constructor(y));
      };
      P.dividedToIntegerBy = P.divToInt = function(y) {
        var x = this, Ctor = x.constructor;
        return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };
      P.equals = P.eq = function(y) {
        return this.cmp(y) === 0;
      };
      P.floor = function() {
        return finalise(new this.constructor(this), this.e + 1, 3);
      };
      P.greaterThan = P.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P.greaterThanOrEqualTo = P.gte = function(y) {
        var k = this.cmp(y);
        return k == 1 || k === 0;
      };
      P.hyperbolicCosine = P.cosh = function() {
        var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
        if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
        if (x.isZero()) return one;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          n = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          n = "2.3283064365386962890625e-10";
        }
        x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
        var cosh2_x, i = k, d8 = new Ctor(8);
        for (; i--; ) {
          cosh2_x = x.times(x);
          x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }
        return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P.hyperbolicSine = P.sinh = function() {
        var k, pr, rm, len, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 3) {
          x = taylorSeries(Ctor, 2, x, x, true);
        } else {
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;
          x = x.times(1 / tinyPow(5, k));
          x = taylorSeries(Ctor, 2, x, x, true);
          var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k--; ) {
            sinh2_x = x.times(x);
            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(x, pr, rm, true);
      };
      P.hyperbolicTangent = P.tanh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(x.s);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;
        return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };
      P.inverseCosine = P.acos = function() {
        var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
        if (k !== -1) {
          return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
        }
        if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P.inverseHyperbolicCosine = P.acosh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
        if (!x.isFinite()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).minus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P.inverseHyperbolicSine = P.asinh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).plus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P.inverseHyperbolicTangent = P.atanh = function() {
        var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x.sd();
        if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
        Ctor.precision = wpr = xsd - x.e;
        x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
        Ctor.precision = pr + 4;
        Ctor.rounding = 1;
        x = x.ln();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(0.5);
      };
      P.inverseSine = P.asin = function() {
        var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
        if (x.isZero()) return new Ctor(x);
        k = x.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (k !== -1) {
          if (k === 0) {
            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x.s;
            return halfPi;
          }
          return new Ctor(NaN);
        }
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P.inverseTangent = P.atan = function() {
        var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
        if (!x.isFinite()) {
          if (!x.s) return new Ctor(NaN);
          if (pr + 4 <= PI_PRECISION) {
            r = getPi(Ctor, pr + 4, rm).times(0.5);
            r.s = x.s;
            return r;
          }
        } else if (x.isZero()) {
          return new Ctor(x);
        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.25);
          r.s = x.s;
          return r;
        }
        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1;
        k = Math.min(28, wpr / LOG_BASE + 2 | 0);
        for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
        external = false;
        j = Math.ceil(wpr / LOG_BASE);
        n = 1;
        x2 = x.times(x);
        r = new Ctor(x);
        px = x;
        for (; i !== -1; ) {
          px = px.times(x2);
          t = r.minus(px.div(n += 2));
          px = px.times(x2);
          r = t.plus(px.div(n += 2));
          if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;
        }
        if (k) r = r.times(2 << k - 1);
        external = true;
        return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P.isFinite = function() {
        return !!this.d;
      };
      P.isInteger = P.isInt = function() {
        return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = P.isNeg = function() {
        return this.s < 0;
      };
      P.isPositive = P.isPos = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.d && this.d[0] === 0;
      };
      P.lessThan = P.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P.lessThanOrEqualTo = P.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P.logarithm = P.log = function(base) {
        var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d = base.d;
          if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
          isBase10 = base.eq(10);
        }
        d = arg.d;
        if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
          return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
        }
        if (isBase10) {
          if (d.length > 1) {
            inf = true;
          } else {
            for (k = d[0]; k % 10 === 0; ) k /= 10;
            inf = k !== 1;
          }
        }
        external = false;
        sd = pr + guard;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);
        if (checkRoundingDigits(r.d, k = pr, rm)) {
          do {
            sd += 10;
            num = naturalLogarithm(arg, sd);
            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
            r = divide(num, denominator, sd, 1);
            if (!inf) {
              if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                r = finalise(r, pr + 1, 0);
              }
              break;
            }
          } while (checkRoundingDigits(r.d, k += 10, rm));
        }
        external = true;
        return finalise(r, pr, rm);
      };
      P.minus = P.sub = function(y) {
        var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s) y = new Ctor(NaN);
          else if (x.d) y.s = -y.s;
          else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.plus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (yd[0]) y.s = -y.s;
          else if (xd[0]) y = new Ctor(x);
          else return new Ctor(rm === 3 ? -0 : 0);
          return external ? finalise(y, pr, rm) : y;
        }
        e = mathfloor(y.e / LOG_BASE);
        xe = mathfloor(x.e / LOG_BASE);
        xd = xd.slice();
        k = xe - e;
        if (k) {
          xLTy = k < 0;
          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e = xe;
            len = xd.length;
          }
          i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
          if (k > i) {
            k = i;
            d.length = 1;
          }
          d.reverse();
          for (i = k; i--; ) d.push(0);
          d.reverse();
        } else {
          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy) len = i;
          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }
          k = 0;
        }
        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }
        len = xd.length;
        for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
        for (i = yd.length; i > k; ) {
          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
            --xd[j];
            xd[i] += BASE;
          }
          xd[i] -= yd[i];
        }
        for (; xd[--len] === 0; ) xd.pop();
        for (; xd[0] === 0; xd.shift()) --e;
        if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
        y.d = xd;
        y.e = getBase10Exponent(xd, e);
        return external ? finalise(y, pr, rm) : y;
      };
      P.modulo = P.mod = function(y) {
        var q, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
        if (!y.d || x.d && !x.d[0]) {
          return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
        }
        external = false;
        if (Ctor.modulo == 9) {
          q = divide(x, y.abs(), 0, 3, 1);
          q.s *= y.s;
        } else {
          q = divide(x, y, 0, Ctor.modulo, 1);
        }
        q = q.times(y);
        external = true;
        return x.minus(q);
      };
      P.naturalExponential = P.exp = function() {
        return naturalExponential(this);
      };
      P.naturalLogarithm = P.ln = function() {
        return naturalLogarithm(this);
      };
      P.negated = P.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s;
        return finalise(x);
      };
      P.plus = P.add = function(y) {
        var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s) y = new Ctor(NaN);
          else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (!yd[0]) y = new Ctor(x);
          return external ? finalise(y, pr, rm) : y;
        }
        k = mathfloor(x.e / LOG_BASE);
        e = mathfloor(y.e / LOG_BASE);
        xd = xd.slice();
        i = k - e;
        if (i) {
          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e = k;
            len = xd.length;
          }
          k = Math.ceil(pr / LOG_BASE);
          len = k > len ? k + 1 : len + 1;
          if (i > len) {
            i = len;
            d.length = 1;
          }
          d.reverse();
          for (; i--; ) d.push(0);
          d.reverse();
        }
        len = xd.length;
        i = yd.length;
        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        }
        for (carry = 0; i; ) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
          xd[i] %= BASE;
        }
        if (carry) {
          xd.unshift(carry);
          ++e;
        }
        for (len = xd.length; xd[--len] == 0; ) xd.pop();
        y.d = xd;
        y.e = getBase10Exponent(xd, e);
        return external ? finalise(y, pr, rm) : y;
      };
      P.precision = P.sd = function(z) {
        var k, x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
        if (x.d) {
          k = getPrecision(x.d);
          if (z && x.e + 1 > k) k = x.e + 1;
        } else {
          k = NaN;
        }
        return k;
      };
      P.round = function() {
        var x = this, Ctor = x.constructor;
        return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
      };
      P.sine = P.sin = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = sine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
        if (s !== 1 || !d || !d[0]) {
          return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
        }
        external = false;
        s = Math.sqrt(+x);
        if (s == 0 || s == 1 / 0) {
          n = digitsToString(d);
          if ((n.length + e) % 2 == 0) n += "0";
          s = Math.sqrt(n);
          e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e + 1, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e + 1, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e, Ctor.rounding, m);
      };
      P.tangent = P.tan = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;
        x = x.sin();
        x.s = 1;
        x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
      };
      P.times = P.mul = function(y) {
        var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
        y.s *= x.s;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
        }
        e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r = [];
        rL = xdL + ydL;
        for (i = rL; i--; ) r.push(0);
        for (i = ydL; --i >= 0; ) {
          carry = 0;
          for (k = xdL + i; k > i; ) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE | 0;
            carry = t / BASE | 0;
          }
          r[k] = (r[k] + carry) % BASE | 0;
        }
        for (; !r[--rL]; ) r.pop();
        if (carry) ++e;
        else r.shift();
        y.d = r;
        y.e = getBase10Exponent(r, e);
        return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
      };
      P.toBinary = function(sd, rm) {
        return toStringBinary(this, 2, sd, rm);
      };
      P.toDecimalPlaces = P.toDP = function(dp, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0) return x;
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        return finalise(x, dp + x.e + 1, rm);
      };
      P.toExponential = function(dp, rm) {
        var str, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x, true);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), dp + 1, rm);
          str = finiteToString(x, true, dp + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toFixed = function(dp, rm) {
        var str, y, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          y = finalise(new Ctor(x), dp + x.e + 1, rm);
          str = finiteToString(y, false, dp + y.e + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toFraction = function(maxD) {
        var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
        if (!xd) return new Ctor(x);
        n1 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);
        d = new Ctor(d1);
        e = d.e = getPrecision(xd) - x.e - 1;
        k = e % LOG_BASE;
        d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
        if (maxD == null) {
          maxD = e > 0 ? d : n1;
        } else {
          n = new Ctor(maxD);
          if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
          maxD = n.gt(d) ? e > 0 ? d : n1 : n;
        }
        external = false;
        n = new Ctor(digitsToString(xd));
        pr = Ctor.precision;
        Ctor.precision = e = xd.length * LOG_BASE * 2;
        for (; ; ) {
          q = divide(n, d, 0, 1, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.cmp(maxD) == 1) break;
          d0 = d1;
          d1 = d2;
          d2 = n1;
          n1 = n0.plus(q.times(d2));
          n0 = d2;
          d2 = d;
          d = n.minus(q.times(d2));
          n = d2;
        }
        d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        Ctor.precision = pr;
        external = true;
        return r;
      };
      P.toHexadecimal = P.toHex = function(sd, rm) {
        return toStringBinary(this, 16, sd, rm);
      };
      P.toNearest = function(y, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (y == null) {
          if (!x.d) return x;
          y = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y = new Ctor(y);
          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt32(rm, 0, 8);
          }
          if (!x.d) return y.s ? x : y;
          if (!y.d) {
            if (y.s) y.s = x.s;
            return y;
          }
        }
        if (y.d[0]) {
          external = false;
          x = divide(x, y, 0, rm, 1).times(y);
          external = true;
          finalise(x);
        } else {
          y.s = x.s;
          x = y;
        }
        return x;
      };
      P.toNumber = function() {
        return +this;
      };
      P.toOctal = function(sd, rm) {
        return toStringBinary(this, 8, sd, rm);
      };
      P.toPower = P.pow = function(y) {
        var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
        if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
        x = new Ctor(x);
        if (x.eq(1)) return x;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (y.eq(1)) return finalise(x, pr, rm);
        e = mathfloor(y.e / LOG_BASE);
        if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
          r = intPow(Ctor, x, k, pr);
          return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
        }
        s = x.s;
        if (s < 0) {
          if (e < y.d.length - 1) return new Ctor(NaN);
          if ((y.d[e] & 1) == 0) s = 1;
          if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
            x.s = s;
            return x;
          }
        }
        k = mathpow(+x, yn);
        e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
        if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
        external = false;
        Ctor.rounding = x.s = 1;
        k = Math.min(12, (e + "").length);
        r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
        if (r.d) {
          r = finalise(r, pr + 5, 1);
          if (checkRoundingDigits(r.d, pr, rm)) {
            e = pr + 10;
            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
          }
        }
        r.s = s;
        external = true;
        Ctor.rounding = rm;
        return finalise(r, pr, rm);
      };
      P.toPrecision = function(sd, rm) {
        var str, x = this, Ctor = x.constructor;
        if (sd === void 0) {
          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), sd, rm);
          str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toSignificantDigits = P.toSD = function(sd, rm) {
        var x = this, Ctor = x.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
        }
        return finalise(new Ctor(x), sd, rm);
      };
      P.toString = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.truncated = P.trunc = function() {
        return finalise(new this.constructor(this), this.e + 1, 1);
      };
      P.valueOf = P.toJSON = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() ? "-" + str : str;
      };
      function digitsToString(d) {
        var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
        if (indexOfLastWord > 0) {
          str += w;
          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + "";
            k = LOG_BASE - ws.length;
            if (k) str += getZeroString(k);
            str += ws;
          }
          w = d[i];
          ws = w + "";
          k = LOG_BASE - ws.length;
          if (k) str += getZeroString(k);
        } else if (w === 0) {
          return "0";
        }
        for (; w % 10 === 0; ) w /= 10;
        return str + w;
      }
      function checkInt32(i, min2, max2) {
        if (i !== ~~i || i < min2 || i > max2) {
          throw Error(invalidArgument + i);
        }
      }
      function checkRoundingDigits(d, i, rm, repeating) {
        var di, k, r, rd;
        for (k = d[0]; k >= 10; k /= 10) --i;
        if (--i < 0) {
          i += LOG_BASE;
          di = 0;
        } else {
          di = Math.ceil((i + 1) / LOG_BASE);
          i %= LOG_BASE;
        }
        k = mathpow(10, LOG_BASE - i);
        rd = d[di] % k | 0;
        if (repeating == null) {
          if (i < 3) {
            if (i == 0) rd = rd / 100 | 0;
            else if (i == 1) rd = rd / 10 | 0;
            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
          } else {
            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
          }
        } else {
          if (i < 4) {
            if (i == 0) rd = rd / 1e3 | 0;
            else if (i == 1) rd = rd / 100 | 0;
            else if (i == 2) rd = rd / 10 | 0;
            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
          } else {
            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
          }
        }
        return r;
      }
      function convertBase(str, baseIn, baseOut) {
        var j, arr = [0], arrL, i = 0, strL = str.length;
        for (; i < strL; ) {
          for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
          arr[0] += NUMERALS.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] === void 0) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      function cosine(Ctor, x) {
        var k, len, y;
        if (x.isZero()) return x;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          y = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          y = "2.3283064365386962890625e-10";
        }
        Ctor.precision += k;
        x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
        for (var i = k; i--; ) {
          var cos2x = x.times(x);
          x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
        }
        Ctor.precision -= k;
        return x;
      }
      var divide = /* @__PURE__ */ function() {
        function multiplyInteger(x, k, base) {
          var temp, carry = 0, i = x.length;
          for (x = x.slice(); i--; ) {
            temp = x[i] * k + carry;
            x[i] = temp % base | 0;
            carry = temp / base | 0;
          }
          if (carry) x.unshift(carry);
          return x;
        }
        function compare(a, b, aL, bL) {
          var i, r;
          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return r;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; ) a.shift();
        }
        return function(x, y, pr, rm, dp, base) {
          var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(
              // Return NaN if either NaN, or both Infinity or 0.
              !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
              )
            );
          }
          if (base) {
            logBase = 1;
            e = x.e - y.e;
          } else {
            base = BASE;
            logBase = LOG_BASE;
            e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
          }
          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign2);
          qd = q.d = [];
          for (i = 0; yd[i] == (xd[i] || 0); i++) ;
          if (yd[i] > (xd[i] || 0)) e--;
          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x.e - y.e) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {
            sd = sd / logBase + 2 | 0;
            i = 0;
            if (yL == 1) {
              k = 0;
              yd = yd[0];
              sd++;
              for (; (i < xL || k) && sd--; i++) {
                t = k * base + (xd[i] || 0);
                qd[i] = t / yd | 0;
                k = t % yd | 0;
              }
              more = k || i < xL;
            } else {
              k = base / (yd[0] + 1) | 0;
              if (k > 1) {
                yd = multiplyInteger(yd, k, base);
                xd = multiplyInteger(xd, k, base);
                yL = yd.length;
                xL = xd.length;
              }
              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; ) rem[remL++] = 0;
              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];
              if (yd[1] >= base / 2) ++yd0;
              do {
                k = 0;
                cmp = compare(yd, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  k = rem0 / yd0 | 0;
                  if (k > 1) {
                    if (k >= base) k = base - 1;
                    prod = multiplyInteger(yd, k, base);
                    prodL = prod.length;
                    remL = rem.length;
                    cmp = compare(prod, rem, prodL, remL);
                    if (cmp == 1) {
                      k--;
                      subtract(prod, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {
                    if (k == 0) cmp = k = 1;
                    prod = yd.slice();
                  }
                  prodL = prod.length;
                  if (prodL < remL) prod.unshift(0);
                  subtract(rem, prod, remL, base);
                  if (cmp == -1) {
                    remL = rem.length;
                    cmp = compare(yd, rem, yL, remL);
                    if (cmp < 1) {
                      k++;
                      subtract(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }
                  remL = rem.length;
                } else if (cmp === 0) {
                  k++;
                  rem = [0];
                }
                qd[i++] = k;
                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] !== void 0) && sd--);
              more = rem[0] !== void 0;
            }
            if (!qd[0]) qd.shift();
          }
          if (logBase == 1) {
            q.e = e;
            inexact = more;
          } else {
            for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
            q.e = i + e * logBase - 1;
            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
          }
          return q;
        };
      }();
      function finalise(x, sd, rm, isTruncated) {
        var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
        out: if (sd != null) {
          xd = x.d;
          if (!xd) return x;
          for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
          i = sd - digits;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            w = xd[xdi = 0];
            rd = w / mathpow(10, digits - j - 1) % 10 | 0;
          } else {
            xdi = Math.ceil((i + 1) / LOG_BASE);
            k = xd.length;
            if (xdi >= k) {
              if (isTruncated) {
                for (; k++ <= xdi; ) xd.push(0);
                w = rd = 0;
                digits = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              w = k = xd[xdi];
              for (digits = 1; k >= 10; k /= 10) digits++;
              i %= LOG_BASE;
              j = i - LOG_BASE + digits;
              rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
            }
          }
          isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
          roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xd[0]) {
            xd.length = 0;
            if (roundUp) {
              sd -= x.e + 1;
              xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
              x.e = -sd || 0;
            } else {
              xd[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xd.length = xdi;
            k = 1;
            xdi--;
          } else {
            xd.length = xdi + 1;
            k = mathpow(10, LOG_BASE - i);
            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
          }
          if (roundUp) {
            for (; ; ) {
              if (xdi == 0) {
                for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
                j = xd[0] += k;
                for (k = 1; j >= 10; j /= 10) k++;
                if (i != k) {
                  x.e++;
                  if (xd[0] == BASE) xd[0] = 1;
                }
                break;
              } else {
                xd[xdi] += k;
                if (xd[xdi] != BASE) break;
                xd[xdi--] = 0;
                k = 1;
              }
            }
          }
          for (i = xd.length; xd[--i] === 0; ) xd.pop();
        }
        if (external) {
          if (x.e > Ctor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < Ctor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
        return x;
      }
      function finiteToString(x, isExp, sd) {
        if (!x.isFinite()) return nonFiniteToString(x);
        var k, e = x.e, str = digitsToString(x.d), len = str.length;
        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
          } else if (len > 1) {
            str = str.charAt(0) + "." + str.slice(1);
          }
          str = str + (x.e < 0 ? "e" : "e+") + x.e;
        } else if (e < 0) {
          str = "0." + getZeroString(-e - 1) + str;
          if (sd && (k = sd - len) > 0) str += getZeroString(k);
        } else if (e >= len) {
          str += getZeroString(e + 1 - len);
          if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
        } else {
          if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e + 1 === len) str += ".";
            str += getZeroString(k);
          }
        }
        return str;
      }
      function getBase10Exponent(digits, e) {
        var w = digits[0];
        for (e *= LOG_BASE; w >= 10; w /= 10) e++;
        return e;
      }
      function getLn10(Ctor, sd, pr) {
        if (sd > LN10_PRECISION) {
          external = true;
          if (pr) Ctor.precision = pr;
          throw Error(precisionLimitExceeded);
        }
        return finalise(new Ctor(LN10), sd, 1, true);
      }
      function getPi(Ctor, sd, rm) {
        if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
        return finalise(new Ctor(PI), sd, rm, true);
      }
      function getPrecision(digits) {
        var w = digits.length - 1, len = w * LOG_BASE + 1;
        w = digits[w];
        if (w) {
          for (; w % 10 == 0; w /= 10) len--;
          for (w = digits[0]; w >= 10; w /= 10) len++;
        }
        return len;
      }
      function getZeroString(k) {
        var zs = "";
        for (; k--; ) zs += "0";
        return zs;
      }
      function intPow(Ctor, x, n, pr) {
        var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
        external = false;
        for (; ; ) {
          if (n % 2) {
            r = r.times(x);
            if (truncate(r.d, k)) isTruncated = true;
          }
          n = mathfloor(n / 2);
          if (n === 0) {
            n = r.d.length - 1;
            if (isTruncated && r.d[n] === 0) ++r.d[n];
            break;
          }
          x = x.times(x);
          truncate(x.d, k);
        }
        external = true;
        return r;
      }
      function isOdd(n) {
        return n.d[n.d.length - 1] & 1;
      }
      function maxOrMin(Ctor, args, n) {
        var k, y, x = new Ctor(args[0]), i = 0;
        for (; ++i < args.length; ) {
          y = new Ctor(args[i]);
          if (!y.s) {
            x = y;
            break;
          }
          k = x.cmp(y);
          if (k === n || k === 0 && x.s === n) {
            x = y;
          }
        }
        return x;
      }
      function naturalExponential(x, sd) {
        var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (!x.d || !x.d[0] || x.e > 17) {
          return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        t = new Ctor(0.03125);
        while (x.e > -2) {
          x = x.times(t);
          k += 5;
        }
        guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow2 = sum2 = new Ctor(1);
        Ctor.precision = wpr;
        for (; ; ) {
          pow2 = finalise(pow2.times(x), wpr, 1);
          denominator = denominator.times(++i);
          t = sum2.plus(divide(pow2, denominator, wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
            j = k;
            while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);
            if (sd == null) {
              if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += 10;
                denominator = pow2 = t = new Ctor(1);
                i = 0;
                rep++;
              } else {
                return finalise(sum2, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum2;
            }
          }
          sum2 = t;
        }
      }
      function naturalLogarithm(y, sd) {
        var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
          return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        Ctor.precision = wpr += guard;
        c = digitsToString(xd);
        c0 = c.charAt(0);
        if (Math.abs(e = x.e) < 15e14) {
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString(x.d);
            c0 = c.charAt(0);
            n++;
          }
          e = x.e;
          if (c0 > 1) {
            x = new Ctor("0." + c);
            e++;
          } else {
            x = new Ctor(c0 + "." + c.slice(1));
          }
        } else {
          t = getLn10(Ctor, wpr + 2, pr).times(e + "");
          x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? finalise(x, pr, rm, external = true) : x;
        }
        x1 = x;
        sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
        x2 = finalise(x.times(x), wpr, 1);
        denominator = 3;
        for (; ; ) {
          numerator = finalise(numerator.times(x2), wpr, 1);
          t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
            sum2 = sum2.times(2);
            if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
            sum2 = divide(sum2, new Ctor(n), wpr, 1);
            if (sd == null) {
              if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += guard;
                t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
                x2 = finalise(x.times(x), wpr, 1);
                denominator = rep = 1;
              } else {
                return finalise(sum2, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum2;
            }
          }
          sum2 = t;
          denominator += 2;
        }
      }
      function nonFiniteToString(x) {
        return String(x.s * x.s / 0);
      }
      function parseDecimal(x, str) {
        var e, i, len;
        if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++) ;
        for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
        str = str.slice(i, len);
        if (str) {
          len -= i;
          x.e = e = e - i - 1;
          x.d = [];
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;
          if (i < len) {
            if (i) x.d.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
            str = str.slice(i);
            i = LOG_BASE - str.length;
          } else {
            i -= len;
          }
          for (; i--; ) str += "0";
          x.d.push(+str);
          if (external) {
            if (x.e > x.constructor.maxE) {
              x.d = null;
              x.e = NaN;
            } else if (x.e < x.constructor.minE) {
              x.e = 0;
              x.d = [0];
            }
          }
        } else {
          x.e = 0;
          x.d = [0];
        }
        return x;
      }
      function parseOther(x, str) {
        var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
        if (str.indexOf("_") > -1) {
          str = str.replace(/(\d)_(?=\d)/g, "$1");
          if (isDecimal.test(str)) return parseDecimal(x, str);
        } else if (str === "Infinity" || str === "NaN") {
          if (!+str) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return x;
        }
        if (isHex.test(str)) {
          base = 16;
          str = str.toLowerCase();
        } else if (isBinary.test(str)) {
          base = 2;
        } else if (isOctal.test(str)) {
          base = 8;
        } else {
          throw Error(invalidArgument + str);
        }
        i = str.search(/p/i);
        if (i > 0) {
          p = +str.slice(i + 1);
          str = str.substring(2, i);
        } else {
          str = str.slice(2);
        }
        i = str.indexOf(".");
        isFloat = i >= 0;
        Ctor = x.constructor;
        if (isFloat) {
          str = str.replace(".", "");
          len = str.length;
          i = len - i;
          divisor = intPow(Ctor, new Ctor(base), i, i * 2);
        }
        xd = convertBase(str, base, BASE);
        xe = xd.length - 1;
        for (i = xe; xd[i] === 0; --i) xd.pop();
        if (i < 0) return new Ctor(x.s * 0);
        x.e = getBase10Exponent(xd, xe);
        x.d = xd;
        external = false;
        if (isFloat) x = divide(x, divisor, len * 4);
        if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
        external = true;
        return x;
      }
      function sine(Ctor, x) {
        var k, len = x.d.length;
        if (len < 3) {
          return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
        }
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x);
        var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sin2_x = x.times(x);
          x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
        }
        return x;
      }
      function taylorSeries(Ctor, n, x, y, isHyperbolic) {
        var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
        external = false;
        x2 = x.times(x);
        u = new Ctor(y);
        for (; ; ) {
          t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
          u = isHyperbolic ? y.plus(t) : y.minus(t);
          y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
          t = u.plus(y);
          if (t.d[k] !== void 0) {
            for (j = k; t.d[j] === u.d[j] && j--; ) ;
            if (j == -1) break;
          }
          j = u;
          u = y;
          y = t;
          t = j;
          i++;
        }
        external = true;
        t.d.length = k + 1;
        return t;
      }
      function tinyPow(b, e) {
        var n = b;
        while (--e) n *= b;
        return n;
      }
      function toLessThanHalfPi(Ctor, x) {
        var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
        x = x.abs();
        if (x.lte(halfPi)) {
          quadrant = isNeg ? 4 : 1;
          return x;
        }
        t = x.divToInt(pi);
        if (t.isZero()) {
          quadrant = isNeg ? 3 : 2;
        } else {
          x = x.minus(t.times(pi));
          if (x.lte(halfPi)) {
            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
            return x;
          }
          quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
        }
        return x.minus(pi).abs();
      }
      function toStringBinary(x, baseOut, sd, rm) {
        var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
        if (isExp) {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
        } else {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        }
        if (!x.isFinite()) {
          str = nonFiniteToString(x);
        } else {
          str = finiteToString(x);
          i = str.indexOf(".");
          if (isExp) {
            base = 2;
            if (baseOut == 16) {
              sd = sd * 4 - 3;
            } else if (baseOut == 8) {
              sd = sd * 3 - 2;
            }
          } else {
            base = baseOut;
          }
          if (i >= 0) {
            str = str.replace(".", "");
            y = new Ctor(1);
            y.e = str.length - i;
            y.d = convertBase(finiteToString(y), 10, base);
            y.e = y.d.length;
          }
          xd = convertBase(str, 10, base);
          e = len = xd.length;
          for (; xd[--len] == 0; ) xd.pop();
          if (!xd[0]) {
            str = isExp ? "0p+0" : "0";
          } else {
            if (i < 0) {
              e--;
            } else {
              x = new Ctor(x);
              x.d = xd;
              x.e = e;
              x = divide(x, y, sd, rm, 0, base);
              xd = x.d;
              e = x.e;
              roundUp = inexact;
            }
            i = xd[sd];
            k = base / 2;
            roundUp = roundUp || xd[sd + 1] !== void 0;
            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
            xd.length = sd;
            if (roundUp) {
              for (; ++xd[--sd] > base - 1; ) {
                xd[sd] = 0;
                if (!sd) {
                  ++e;
                  xd.unshift(1);
                }
              }
            }
            for (len = xd.length; !xd[len - 1]; --len) ;
            for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
            if (isExp) {
              if (len > 1) {
                if (baseOut == 16 || baseOut == 8) {
                  i = baseOut == 16 ? 4 : 3;
                  for (--len; len % i; len++) str += "0";
                  xd = convertBase(str, base, baseOut);
                  for (len = xd.length; !xd[len - 1]; --len) ;
                  for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
                } else {
                  str = str.charAt(0) + "." + str.slice(1);
                }
              }
              str = str + (e < 0 ? "p" : "p+") + e;
            } else if (e < 0) {
              for (; ++e; ) str = "0" + str;
              str = "0." + str;
            } else {
              if (++e > len) for (e -= len; e--; ) str += "0";
              else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
            }
          }
          str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
        }
        return x.s < 0 ? "-" + str : str;
      }
      function truncate(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }
      function abs(x) {
        return new this(x).abs();
      }
      function acos(x) {
        return new this(x).acos();
      }
      function acosh(x) {
        return new this(x).acosh();
      }
      function add(x, y) {
        return new this(x).plus(y);
      }
      function asin(x) {
        return new this(x).asin();
      }
      function asinh(x) {
        return new this(x).asinh();
      }
      function atan(x) {
        return new this(x).atan();
      }
      function atanh(x) {
        return new this(x).atanh();
      }
      function atan2(y, x) {
        y = new this(y);
        x = new this(x);
        var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
        if (!y.s || !x.s) {
          r = new this(NaN);
        } else if (!y.d && !x.d) {
          r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
          r.s = y.s;
        } else if (!x.d || y.isZero()) {
          r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
          r.s = y.s;
        } else if (!y.d || x.isZero()) {
          r = getPi(this, wpr, 1).times(0.5);
          r.s = y.s;
        } else if (x.s < 0) {
          this.precision = wpr;
          this.rounding = 1;
          r = this.atan(divide(y, x, wpr, 1));
          x = getPi(this, wpr, 1);
          this.precision = pr;
          this.rounding = rm;
          r = y.s < 0 ? r.minus(x) : r.plus(x);
        } else {
          r = this.atan(divide(y, x, wpr, 1));
        }
        return r;
      }
      function cbrt(x) {
        return new this(x).cbrt();
      }
      function ceil(x) {
        return finalise(x = new this(x), x.e + 1, 2);
      }
      function clamp(x, min2, max2) {
        return new this(x).clamp(min2, max2);
      }
      function config(obj) {
        if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
        var i, p, v, useDefaults = obj.defaults === true, ps = [
          "precision",
          1,
          MAX_DIGITS,
          "rounding",
          0,
          8,
          "toExpNeg",
          -EXP_LIMIT,
          0,
          "toExpPos",
          0,
          EXP_LIMIT,
          "maxE",
          0,
          EXP_LIMIT,
          "minE",
          -EXP_LIMIT,
          0,
          "modulo",
          0,
          9
        ];
        for (i = 0; i < ps.length; i += 3) {
          if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
          if ((v = obj[p]) !== void 0) {
            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
            else throw Error(invalidArgument + p + ": " + v);
          }
        }
        if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (v === true || v === false || v === 0 || v === 1) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                this[p] = true;
              } else {
                throw Error(cryptoUnavailable);
              }
            } else {
              this[p] = false;
            }
          } else {
            throw Error(invalidArgument + p + ": " + v);
          }
        }
        return this;
      }
      function cos(x) {
        return new this(x).cos();
      }
      function cosh(x) {
        return new this(x).cosh();
      }
      function clone(obj) {
        var i, p, ps;
        function Decimal2(v) {
          var e, i2, t, x = this;
          if (!(x instanceof Decimal2)) return new Decimal2(v);
          x.constructor = Decimal2;
          if (isDecimalInstance(v)) {
            x.s = v.s;
            if (external) {
              if (!v.d || v.e > Decimal2.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (v.e < Decimal2.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = v.e;
                x.d = v.d.slice();
              }
            } else {
              x.e = v.e;
              x.d = v.d ? v.d.slice() : v.d;
            }
            return;
          }
          t = typeof v;
          if (t === "number") {
            if (v === 0) {
              x.s = 1 / v < 0 ? -1 : 1;
              x.e = 0;
              x.d = [0];
              return;
            }
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            if (v === ~~v && v < 1e7) {
              for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
              if (external) {
                if (e > Decimal2.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (e < Decimal2.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = e;
                  x.d = [v];
                }
              } else {
                x.e = e;
                x.d = [v];
              }
              return;
            }
            if (v * 0 !== 0) {
              if (!v) x.s = NaN;
              x.e = NaN;
              x.d = null;
              return;
            }
            return parseDecimal(x, v.toString());
          }
          if (t === "string") {
            if ((i2 = v.charCodeAt(0)) === 45) {
              v = v.slice(1);
              x.s = -1;
            } else {
              if (i2 === 43) v = v.slice(1);
              x.s = 1;
            }
            return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
          }
          if (t === "bigint") {
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            return parseDecimal(x, v.toString());
          }
          throw Error(invalidArgument + v);
        }
        Decimal2.prototype = P;
        Decimal2.ROUND_UP = 0;
        Decimal2.ROUND_DOWN = 1;
        Decimal2.ROUND_CEIL = 2;
        Decimal2.ROUND_FLOOR = 3;
        Decimal2.ROUND_HALF_UP = 4;
        Decimal2.ROUND_HALF_DOWN = 5;
        Decimal2.ROUND_HALF_EVEN = 6;
        Decimal2.ROUND_HALF_CEIL = 7;
        Decimal2.ROUND_HALF_FLOOR = 8;
        Decimal2.EUCLID = 9;
        Decimal2.config = Decimal2.set = config;
        Decimal2.clone = clone;
        Decimal2.isDecimal = isDecimalInstance;
        Decimal2.abs = abs;
        Decimal2.acos = acos;
        Decimal2.acosh = acosh;
        Decimal2.add = add;
        Decimal2.asin = asin;
        Decimal2.asinh = asinh;
        Decimal2.atan = atan;
        Decimal2.atanh = atanh;
        Decimal2.atan2 = atan2;
        Decimal2.cbrt = cbrt;
        Decimal2.ceil = ceil;
        Decimal2.clamp = clamp;
        Decimal2.cos = cos;
        Decimal2.cosh = cosh;
        Decimal2.div = div;
        Decimal2.exp = exp;
        Decimal2.floor = floor;
        Decimal2.hypot = hypot;
        Decimal2.ln = ln;
        Decimal2.log = log;
        Decimal2.log10 = log10;
        Decimal2.log2 = log2;
        Decimal2.max = max;
        Decimal2.min = min;
        Decimal2.mod = mod;
        Decimal2.mul = mul;
        Decimal2.pow = pow;
        Decimal2.random = random;
        Decimal2.round = round;
        Decimal2.sign = sign;
        Decimal2.sin = sin;
        Decimal2.sinh = sinh;
        Decimal2.sqrt = sqrt;
        Decimal2.sub = sub;
        Decimal2.sum = sum;
        Decimal2.tan = tan;
        Decimal2.tanh = tanh;
        Decimal2.trunc = trunc;
        if (obj === void 0) obj = {};
        if (obj) {
          if (obj.defaults !== true) {
            ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
            for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
          }
        }
        Decimal2.config(obj);
        return Decimal2;
      }
      function div(x, y) {
        return new this(x).div(y);
      }
      function exp(x) {
        return new this(x).exp();
      }
      function floor(x) {
        return finalise(x = new this(x), x.e + 1, 3);
      }
      function hypot() {
        var i, n, t = new this(0);
        external = false;
        for (i = 0; i < arguments.length; ) {
          n = new this(arguments[i++]);
          if (!n.d) {
            if (n.s) {
              external = true;
              return new this(1 / 0);
            }
            t = n;
          } else if (t.d) {
            t = t.plus(n.times(n));
          }
        }
        external = true;
        return t.sqrt();
      }
      function isDecimalInstance(obj) {
        return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
      }
      function ln(x) {
        return new this(x).ln();
      }
      function log(x, y) {
        return new this(x).log(y);
      }
      function log2(x) {
        return new this(x).log(2);
      }
      function log10(x) {
        return new this(x).log(10);
      }
      function max() {
        return maxOrMin(this, arguments, -1);
      }
      function min() {
        return maxOrMin(this, arguments, 1);
      }
      function mod(x, y) {
        return new this(x).mod(y);
      }
      function mul(x, y) {
        return new this(x).mul(y);
      }
      function pow(x, y) {
        return new this(x).pow(y);
      }
      function random(sd) {
        var d, e, k, n, i = 0, r = new this(1), rd = [];
        if (sd === void 0) sd = this.precision;
        else checkInt32(sd, 1, MAX_DIGITS);
        k = Math.ceil(sd / LOG_BASE);
        if (!this.crypto) {
          for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
        } else if (crypto.getRandomValues) {
          d = crypto.getRandomValues(new Uint32Array(k));
          for (; i < k; ) {
            n = d[i];
            if (n >= 429e7) {
              d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
            } else {
              rd[i++] = n % 1e7;
            }
          }
        } else if (crypto.randomBytes) {
          d = crypto.randomBytes(k *= 4);
          for (; i < k; ) {
            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
            if (n >= 214e7) {
              crypto.randomBytes(4).copy(d, i);
            } else {
              rd.push(n % 1e7);
              i += 4;
            }
          }
          i = k / 4;
        } else {
          throw Error(cryptoUnavailable);
        }
        k = rd[--i];
        sd %= LOG_BASE;
        if (k && sd) {
          n = mathpow(10, LOG_BASE - sd);
          rd[i] = (k / n | 0) * n;
        }
        for (; rd[i] === 0; i--) rd.pop();
        if (i < 0) {
          e = 0;
          rd = [0];
        } else {
          e = -1;
          for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
          for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
          if (k < LOG_BASE) e -= LOG_BASE - k;
        }
        r.e = e;
        r.d = rd;
        return r;
      }
      function round(x) {
        return finalise(x = new this(x), x.e + 1, this.rounding);
      }
      function sign(x) {
        x = new this(x);
        return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
      }
      function sin(x) {
        return new this(x).sin();
      }
      function sinh(x) {
        return new this(x).sinh();
      }
      function sqrt(x) {
        return new this(x).sqrt();
      }
      function sub(x, y) {
        return new this(x).sub(y);
      }
      function sum() {
        var i = 0, args = arguments, x = new this(args[i]);
        external = false;
        for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
        external = true;
        return finalise(x, this.precision, this.rounding);
      }
      function tan(x) {
        return new this(x).tan();
      }
      function tanh(x) {
        return new this(x).tanh();
      }
      function trunc(x) {
        return finalise(x = new this(x), x.e + 1, 1);
      }
      Decimal = clone(DEFAULTS);
      Decimal.prototype.constructor = Decimal;
      Decimal["default"] = Decimal.Decimal = Decimal;
      LN10 = new Decimal(LN10);
      PI = new Decimal(PI);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Decimal;
        });
      } else if (typeof module != "undefined" && module.exports) {
        if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
          P[Symbol["for"]("nodejs.util.inspect.custom")] = P.toString;
          P[Symbol.toStringTag] = "Decimal";
        }
        module.exports = Decimal;
      } else {
        if (!globalScope) {
          globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
        }
        noConflict = globalScope.Decimal;
        Decimal.noConflict = function() {
          globalScope.Decimal = noConflict;
          return Decimal;
        };
        globalScope.Decimal = Decimal;
      }
    })(exports);
  }
});

// node_modules/ripple-binary-codec/dist/serdes/binary-parser.js
var require_binary_parser = __commonJS({
  "node_modules/ripple-binary-codec/dist/serdes/binary-parser.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BinaryParser = void 0;
    var assert = __importStar(require_assert());
    var enums_1 = require_enums();
    var buffer_1 = require_dist();
    var BinaryParser = class {
      /**
       * Initialize bytes to a hex string
       *
       * @param hexBytes a hex string
       * @param definitions Rippled definitions used to parse the values of transaction types and such.
       *                          Can be customized for sidechains and amendments.
       */
      constructor(hexBytes, definitions = enums_1.DEFAULT_DEFINITIONS) {
        this.bytes = buffer_1.Buffer.from(hexBytes, "hex");
        this.definitions = definitions;
      }
      /**
       * Peek the first byte of the BinaryParser
       *
       * @returns The first byte of the BinaryParser
       */
      peek() {
        assert.ok(this.bytes.byteLength !== 0);
        return this.bytes[0];
      }
      /**
       * Consume the first n bytes of the BinaryParser
       *
       * @param n the number of bytes to skip
       */
      skip(n) {
        assert.ok(n <= this.bytes.byteLength);
        this.bytes = this.bytes.slice(n);
      }
      /**
       * read the first n bytes from the BinaryParser
       *
       * @param n The number of bytes to read
       * @return The bytes
       */
      read(n) {
        assert.ok(n <= this.bytes.byteLength);
        const slice = this.bytes.slice(0, n);
        this.skip(n);
        return slice;
      }
      /**
       * Read an integer of given size
       *
       * @param n The number of bytes to read
       * @return The number represented by those bytes
       */
      readUIntN(n) {
        assert.ok(0 < n && n <= 4, "invalid n");
        return this.read(n).reduce((a, b) => a << 8 | b) >>> 0;
      }
      readUInt8() {
        return this.readUIntN(1);
      }
      readUInt16() {
        return this.readUIntN(2);
      }
      readUInt32() {
        return this.readUIntN(4);
      }
      size() {
        return this.bytes.byteLength;
      }
      end(customEnd) {
        const length = this.bytes.byteLength;
        return length === 0 || customEnd !== void 0 && length <= customEnd;
      }
      /**
       * Reads variable length encoded bytes
       *
       * @return The variable length bytes
       */
      readVariableLength() {
        return this.read(this.readVariableLengthLength());
      }
      /**
       * Reads the length of the variable length encoded bytes
       *
       * @return The length of the variable length encoded bytes
       */
      readVariableLengthLength() {
        const b1 = this.readUInt8();
        if (b1 <= 192) {
          return b1;
        } else if (b1 <= 240) {
          const b2 = this.readUInt8();
          return 193 + (b1 - 193) * 256 + b2;
        } else if (b1 <= 254) {
          const b2 = this.readUInt8();
          const b3 = this.readUInt8();
          return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;
        }
        throw new Error("Invalid variable length indicator");
      }
      /**
       * Reads the field ordinal from the BinaryParser
       *
       * @return Field ordinal
       */
      readFieldOrdinal() {
        let type = this.readUInt8();
        let nth = type & 15;
        type >>= 4;
        if (type === 0) {
          type = this.readUInt8();
          if (type === 0 || type < 16) {
            throw new Error("Cannot read FieldOrdinal, type_code out of range");
          }
        }
        if (nth === 0) {
          nth = this.readUInt8();
          if (nth === 0 || nth < 16) {
            throw new Error("Cannot read FieldOrdinal, field_code out of range");
          }
        }
        return type << 16 | nth;
      }
      /**
       * Read the field from the BinaryParser
       *
       * @return The field represented by the bytes at the head of the BinaryParser
       */
      readField() {
        return this.definitions.field.fromString(this.readFieldOrdinal().toString());
      }
      /**
       * Read a given type from the BinaryParser
       *
       * @param type The type that you want to read from the BinaryParser
       * @return The instance of that type read from the BinaryParser
       */
      readType(type) {
        return type.fromParser(this);
      }
      /**
       * Get the type associated with a given field
       *
       * @param field The field that you wan to get the type of
       * @return The type associated with the given field
       */
      typeForField(field) {
        return field.associatedType;
      }
      /**
       * Read value of the type specified by field from the BinaryParser
       *
       * @param field The field that you want to get the associated value for
       * @return The value associated with the given field
       */
      readFieldValue(field) {
        const type = this.typeForField(field);
        if (!type) {
          throw new Error(`unsupported: (${field.name}, ${field.type.name})`);
        }
        const sizeHint = field.isVariableLengthEncoded ? this.readVariableLengthLength() : void 0;
        const value = type.fromParser(this, sizeHint);
        if (value === void 0) {
          throw new Error(`fromParser for (${field.name}, ${field.type.name}) -> undefined `);
        }
        return value;
      }
      /**
       * Get the next field and value from the BinaryParser
       *
       * @return The field and value
       */
      readFieldAndValue() {
        const field = this.readField();
        return [field, this.readFieldValue(field)];
      }
    };
    exports.BinaryParser = BinaryParser;
  }
});

// node_modules/ripple-binary-codec/dist/types/currency.js
var require_currency2 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/currency.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Currency = void 0;
    var hash_160_1 = require_hash_160();
    var buffer_1 = require_dist();
    var XRP_HEX_REGEX = /^0{40}$/;
    var ISO_REGEX = /^[A-Z0-9a-z?!@#$%^&*(){}[\]|]{3}$/;
    var HEX_REGEX = /^[A-F0-9]{40}$/;
    var STANDARD_FORMAT_HEX_REGEX = /^0{24}[\x00-\x7F]{6}0{10}$/;
    function isoToBytes(iso) {
      const bytes = buffer_1.Buffer.alloc(20);
      if (iso !== "XRP") {
        const isoBytes = iso.split("").map((c) => c.charCodeAt(0));
        bytes.set(isoBytes, 12);
      }
      return bytes;
    }
    function isIsoCode(iso) {
      return ISO_REGEX.test(iso);
    }
    function isoCodeFromHex(code) {
      const iso = code.toString();
      if (iso === "XRP") {
        return null;
      }
      if (isIsoCode(iso)) {
        return iso;
      }
      return null;
    }
    function isHex(hex) {
      return HEX_REGEX.test(hex);
    }
    function isStringRepresentation(input) {
      return input.length === 3 || isHex(input);
    }
    function isBytesArray(bytes) {
      return bytes.byteLength === 20;
    }
    function isValidRepresentation(input) {
      return input instanceof buffer_1.Buffer ? isBytesArray(input) : isStringRepresentation(input);
    }
    function bytesFromRepresentation(input) {
      if (!isValidRepresentation(input)) {
        throw new Error(`Unsupported Currency representation: ${input}`);
      }
      return input.length === 3 ? isoToBytes(input) : buffer_1.Buffer.from(input, "hex");
    }
    var Currency = class _Currency extends hash_160_1.Hash160 {
      constructor(byteBuf) {
        super(byteBuf !== null && byteBuf !== void 0 ? byteBuf : _Currency.XRP.bytes);
        const hex = this.bytes.toString("hex");
        if (XRP_HEX_REGEX.test(hex)) {
          this._iso = "XRP";
        } else if (STANDARD_FORMAT_HEX_REGEX.test(hex)) {
          this._iso = isoCodeFromHex(this.bytes.slice(12, 15));
        } else {
          this._iso = null;
        }
      }
      /**
       * Return the ISO code of this currency
       *
       * @returns ISO code if it exists, else null
       */
      iso() {
        return this._iso;
      }
      /**
       * Constructs a Currency object
       *
       * @param val Currency object or a string representation of a currency
       */
      static from(value) {
        if (value instanceof _Currency) {
          return value;
        }
        if (typeof value === "string") {
          return new _Currency(bytesFromRepresentation(value));
        }
        throw new Error("Cannot construct Currency from value given");
      }
      /**
       * Gets the JSON representation of a currency
       *
       * @returns JSON representation
       */
      toJSON() {
        const iso = this.iso();
        if (iso !== null) {
          return iso;
        }
        return this.bytes.toString("hex").toUpperCase();
      }
    };
    exports.Currency = Currency;
    Currency.XRP = new Currency(buffer_1.Buffer.alloc(20));
  }
});

// node_modules/big-integer/BigInteger.js
var require_BigInteger = __commonJS({
  "node_modules/big-integer/BigInteger.js"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var bigInt = function(undefined2) {
      "use strict";
      var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
      var supportsNativeBigInt = typeof BigInt === "function";
      function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
      }
      function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
      }
      BigInteger.prototype = Object.create(Integer.prototype);
      function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
      }
      SmallInteger.prototype = Object.create(Integer.prototype);
      function NativeBigInt(value) {
        this.value = value;
      }
      NativeBigInt.prototype = Object.create(Integer.prototype);
      function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
      }
      function smallToArray(n) {
        if (n < 1e7)
          return [n];
        if (n < 1e14)
          return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
      }
      function arrayToSmall(arr) {
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
          switch (length) {
            case 0:
              return 0;
            case 1:
              return arr[0];
            case 2:
              return arr[0] + arr[1] * BASE;
            default:
              return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
          }
        }
        return arr;
      }
      function trim(v) {
        var i2 = v.length;
        while (v[--i2] === 0) ;
        v.length = i2 + 1;
      }
      function createArray(length) {
        var x = new Array(length);
        var i2 = -1;
        while (++i2 < length) {
          x[i2] = 0;
        }
        return x;
      }
      function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
      }
      function add(a, b) {
        var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i2;
        for (i2 = 0; i2 < l_b; i2++) {
          sum = a[i2] + b[i2] + carry;
          carry = sum >= base ? 1 : 0;
          r[i2] = sum - carry * base;
        }
        while (i2 < l_a) {
          sum = a[i2] + carry;
          carry = sum === base ? 1 : 0;
          r[i2++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
      }
      function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
      }
      function addSmall(a, carry) {
        var l = a.length, r = new Array(l), base = BASE, sum, i2;
        for (i2 = 0; i2 < l; i2++) {
          sum = a[i2] - base + carry;
          carry = Math.floor(sum / base);
          r[i2] = sum - carry * base;
          carry += 1;
        }
        while (carry > 0) {
          r[i2++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r;
      }
      BigInteger.prototype.add = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
          return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
          return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
      };
      BigInteger.prototype.plus = BigInteger.prototype.add;
      SmallInteger.prototype.add = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
          return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
          if (isPrecise(a + b)) return new SmallInteger(a + b);
          b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
      };
      SmallInteger.prototype.plus = SmallInteger.prototype.add;
      NativeBigInt.prototype.add = function(v) {
        return new NativeBigInt(this.value + parseValue(v).value);
      };
      NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
      function subtract(a, b) {
        var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i2, difference;
        for (i2 = 0; i2 < b_l; i2++) {
          difference = a[i2] - borrow - b[i2];
          if (difference < 0) {
            difference += base;
            borrow = 1;
          } else borrow = 0;
          r[i2] = difference;
        }
        for (i2 = b_l; i2 < a_l; i2++) {
          difference = a[i2] - borrow;
          if (difference < 0) difference += base;
          else {
            r[i2++] = difference;
            break;
          }
          r[i2] = difference;
        }
        for (; i2 < a_l; i2++) {
          r[i2] = a[i2];
        }
        trim(r);
        return r;
      }
      function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
          value = subtract(a, b);
        } else {
          value = subtract(b, a);
          sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
          if (sign) value = -value;
          return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
      }
      function subtractSmall(a, b, sign) {
        var l = a.length, r = new Array(l), carry = -b, base = BASE, i2, difference;
        for (i2 = 0; i2 < l; i2++) {
          difference = a[i2] + carry;
          carry = Math.floor(difference / base);
          difference %= base;
          r[i2] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
          if (sign) r = -r;
          return new SmallInteger(r);
        }
        return new BigInteger(r, sign);
      }
      BigInteger.prototype.subtract = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
          return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
          return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
      };
      BigInteger.prototype.minus = BigInteger.prototype.subtract;
      SmallInteger.prototype.subtract = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
          return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
          return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
      };
      SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
      NativeBigInt.prototype.subtract = function(v) {
        return new NativeBigInt(this.value - parseValue(v).value);
      };
      NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
      BigInteger.prototype.negate = function() {
        return new BigInteger(this.value, !this.sign);
      };
      SmallInteger.prototype.negate = function() {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
      };
      NativeBigInt.prototype.negate = function() {
        return new NativeBigInt(-this.value);
      };
      BigInteger.prototype.abs = function() {
        return new BigInteger(this.value, false);
      };
      SmallInteger.prototype.abs = function() {
        return new SmallInteger(Math.abs(this.value));
      };
      NativeBigInt.prototype.abs = function() {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
      };
      function multiplyLong(a, b) {
        var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product, carry, i2, a_i, b_j;
        for (i2 = 0; i2 < a_l; ++i2) {
          a_i = a[i2];
          for (var j = 0; j < b_l; ++j) {
            b_j = b[j];
            product = a_i * b_j + r[i2 + j];
            carry = Math.floor(product / base);
            r[i2 + j] = product - carry * base;
            r[i2 + j + 1] += carry;
          }
        }
        trim(r);
        return r;
      }
      function multiplySmall(a, b) {
        var l = a.length, r = new Array(l), base = BASE, carry = 0, product, i2;
        for (i2 = 0; i2 < l; i2++) {
          product = a[i2] * b + carry;
          carry = Math.floor(product / base);
          r[i2] = product - carry * base;
        }
        while (carry > 0) {
          r[i2++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r;
      }
      function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
      }
      function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);
        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);
        var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
        var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
      }
      function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;
      }
      BigInteger.prototype.multiply = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;
        if (n.isSmall) {
          if (b === 0) return Integer[0];
          if (b === 1) return this;
          if (b === -1) return this.negate();
          abs = Math.abs(b);
          if (abs < BASE) {
            return new BigInteger(multiplySmall(a, abs), sign);
          }
          b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length))
          return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
      };
      BigInteger.prototype.times = BigInteger.prototype.multiply;
      function multiplySmallAndArray(a, b, sign) {
        if (a < BASE) {
          return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
      }
      SmallInteger.prototype._multiplyBySmall = function(a) {
        if (isPrecise(a.value * this.value)) {
          return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
      };
      BigInteger.prototype._multiplyBySmall = function(a) {
        if (a.value === 0) return Integer[0];
        if (a.value === 1) return this;
        if (a.value === -1) return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
      };
      SmallInteger.prototype.multiply = function(v) {
        return parseValue(v)._multiplyBySmall(this);
      };
      SmallInteger.prototype.times = SmallInteger.prototype.multiply;
      NativeBigInt.prototype.multiply = function(v) {
        return new NativeBigInt(this.value * parseValue(v).value);
      };
      NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
      function square(a) {
        var l = a.length, r = createArray(l + l), base = BASE, product, carry, i2, a_i, a_j;
        for (i2 = 0; i2 < l; i2++) {
          a_i = a[i2];
          carry = 0 - a_i * a_i;
          for (var j = i2; j < l; j++) {
            a_j = a[j];
            product = 2 * (a_i * a_j) + r[i2 + j] + carry;
            carry = Math.floor(product / base);
            r[i2 + j] = product - carry * base;
          }
          r[i2 + l] = carry;
        }
        trim(r);
        return r;
      }
      BigInteger.prototype.square = function() {
        return new BigInteger(square(this.value), false);
      };
      SmallInteger.prototype.square = function() {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
      };
      NativeBigInt.prototype.square = function(v) {
        return new NativeBigInt(this.value * this.value);
      };
      function divMod1(a, b) {
        var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
          quotientDigit = base - 1;
          if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
            quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
          }
          carry = 0;
          borrow = 0;
          l = divisor.length;
          for (i2 = 0; i2 < l; i2++) {
            carry += quotientDigit * divisor[i2];
            q = Math.floor(carry / base);
            borrow += remainder[shift + i2] - (carry - q * base);
            carry = q;
            if (borrow < 0) {
              remainder[shift + i2] = borrow + base;
              borrow = -1;
            } else {
              remainder[shift + i2] = borrow;
              borrow = 0;
            }
          }
          while (borrow !== 0) {
            quotientDigit -= 1;
            carry = 0;
            for (i2 = 0; i2 < l; i2++) {
              carry += remainder[shift + i2] - base + divisor[i2];
              if (carry < 0) {
                remainder[shift + i2] = carry + base;
                carry = 0;
              } else {
                remainder[shift + i2] = carry;
                carry = 1;
              }
            }
            borrow += carry;
          }
          result[shift] = quotientDigit;
        }
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
      }
      function divMod2(a, b) {
        var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;
        while (a_l) {
          part.unshift(a[--a_l]);
          trim(part);
          if (compareAbs(part, b) < 0) {
            result.push(0);
            continue;
          }
          xlen = part.length;
          highx = part[xlen - 1] * base + part[xlen - 2];
          highy = b[b_l - 1] * base + b[b_l - 2];
          if (xlen > b_l) {
            highx = (highx + 1) * base;
          }
          guess = Math.ceil(highx / highy);
          do {
            check = multiplySmall(b, guess);
            if (compareAbs(check, part) <= 0) break;
            guess--;
          } while (guess);
          result.push(guess);
          part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
      }
      function divModSmall(value, lambda) {
        var length = value.length, quotient = createArray(length), base = BASE, i2, q, remainder, divisor;
        remainder = 0;
        for (i2 = length - 1; i2 >= 0; --i2) {
          divisor = remainder * base + value[i2];
          q = truncate(divisor / lambda);
          remainder = divisor - q * lambda;
          quotient[i2] = q | 0;
        }
        return [quotient, remainder | 0];
      }
      function divModAny(self2, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
          return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];
        }
        var a = self2.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self2.isSmall) {
          if (n.isSmall) {
            return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
          }
          return [Integer[0], self2];
        }
        if (n.isSmall) {
          if (b === 1) return [self2, Integer[0]];
          if (b == -1) return [self2.negate(), Integer[0]];
          var abs = Math.abs(b);
          if (abs < BASE) {
            value = divModSmall(a, abs);
            quotient = arrayToSmall(value[0]);
            var remainder = value[1];
            if (self2.sign) remainder = -remainder;
            if (typeof quotient === "number") {
              if (self2.sign !== n.sign) quotient = -quotient;
              return [new SmallInteger(quotient), new SmallInteger(remainder)];
            }
            return [new BigInteger(quotient, self2.sign !== n.sign), new SmallInteger(remainder)];
          }
          b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self2];
        if (comparison === 0) return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];
        if (a.length + b.length <= 200)
          value = divMod1(a, b);
        else value = divMod2(a, b);
        quotient = value[0];
        var qSign = self2.sign !== n.sign, mod = value[1], mSign = self2.sign;
        if (typeof quotient === "number") {
          if (qSign) quotient = -quotient;
          quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
          if (mSign) mod = -mod;
          mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [quotient, mod];
      }
      BigInteger.prototype.divmod = function(v) {
        var result = divModAny(this, v);
        return {
          quotient: result[0],
          remainder: result[1]
        };
      };
      NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
      BigInteger.prototype.divide = function(v) {
        return divModAny(this, v)[0];
      };
      NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
        return new NativeBigInt(this.value / parseValue(v).value);
      };
      SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
      BigInteger.prototype.mod = function(v) {
        return divModAny(this, v)[1];
      };
      NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
        return new NativeBigInt(this.value % parseValue(v).value);
      };
      SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
      BigInteger.prototype.pow = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
          return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
          if (isPrecise(value = Math.pow(a, b)))
            return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
          if (b & true) {
            y = y.times(x);
            --b;
          }
          if (b === 0) break;
          b /= 2;
          x = x.square();
        }
        return y;
      };
      SmallInteger.prototype.pow = BigInteger.prototype.pow;
      NativeBigInt.prototype.pow = function(v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
        if (b === _0) return Integer[1];
        if (a === _0) return Integer[0];
        if (a === _1) return Integer[1];
        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative()) return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];
        while (true) {
          if ((b & _1) === _1) {
            y = y.times(x);
            --b;
          }
          if (b === _0) break;
          b /= _2;
          x = x.square();
        }
        return y;
      };
      BigInteger.prototype.modPow = function(exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1], base = this.mod(mod);
        if (exp.isNegative()) {
          exp = exp.multiply(Integer[-1]);
          base = base.modInv(mod);
        }
        while (exp.isPositive()) {
          if (base.isZero()) return Integer[0];
          if (exp.isOdd()) r = r.multiply(base).mod(mod);
          exp = exp.divide(2);
          base = base.square().mod(mod);
        }
        return r;
      };
      NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
      function compareAbs(a, b) {
        if (a.length !== b.length) {
          return a.length > b.length ? 1 : -1;
        }
        for (var i2 = a.length - 1; i2 >= 0; i2--) {
          if (a[i2] !== b[i2]) return a[i2] > b[i2] ? 1 : -1;
        }
        return 0;
      }
      BigInteger.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
      };
      SmallInteger.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = Math.abs(this.value), b = n.value;
        if (n.isSmall) {
          b = Math.abs(b);
          return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
      };
      NativeBigInt.prototype.compareAbs = function(v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
      };
      BigInteger.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (this.sign !== n.sign) {
          return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
          return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
      };
      BigInteger.prototype.compareTo = BigInteger.prototype.compare;
      SmallInteger.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall) {
          return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
          return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
      };
      SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
      NativeBigInt.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
      };
      NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
      BigInteger.prototype.equals = function(v) {
        return this.compare(v) === 0;
      };
      NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
      BigInteger.prototype.notEquals = function(v) {
        return this.compare(v) !== 0;
      };
      NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
      BigInteger.prototype.greater = function(v) {
        return this.compare(v) > 0;
      };
      NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
      BigInteger.prototype.lesser = function(v) {
        return this.compare(v) < 0;
      };
      NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
      BigInteger.prototype.greaterOrEquals = function(v) {
        return this.compare(v) >= 0;
      };
      NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
      BigInteger.prototype.lesserOrEquals = function(v) {
        return this.compare(v) <= 0;
      };
      NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
      BigInteger.prototype.isEven = function() {
        return (this.value[0] & 1) === 0;
      };
      SmallInteger.prototype.isEven = function() {
        return (this.value & 1) === 0;
      };
      NativeBigInt.prototype.isEven = function() {
        return (this.value & BigInt(1)) === BigInt(0);
      };
      BigInteger.prototype.isOdd = function() {
        return (this.value[0] & 1) === 1;
      };
      SmallInteger.prototype.isOdd = function() {
        return (this.value & 1) === 1;
      };
      NativeBigInt.prototype.isOdd = function() {
        return (this.value & BigInt(1)) === BigInt(1);
      };
      BigInteger.prototype.isPositive = function() {
        return !this.sign;
      };
      SmallInteger.prototype.isPositive = function() {
        return this.value > 0;
      };
      NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
      BigInteger.prototype.isNegative = function() {
        return this.sign;
      };
      SmallInteger.prototype.isNegative = function() {
        return this.value < 0;
      };
      NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
      BigInteger.prototype.isUnit = function() {
        return false;
      };
      SmallInteger.prototype.isUnit = function() {
        return Math.abs(this.value) === 1;
      };
      NativeBigInt.prototype.isUnit = function() {
        return this.abs().value === BigInt(1);
      };
      BigInteger.prototype.isZero = function() {
        return false;
      };
      SmallInteger.prototype.isZero = function() {
        return this.value === 0;
      };
      NativeBigInt.prototype.isZero = function() {
        return this.value === BigInt(0);
      };
      BigInteger.prototype.isDivisibleBy = function(v) {
        var n = parseValue(v);
        if (n.isZero()) return false;
        if (n.isUnit()) return true;
        if (n.compareAbs(2) === 0) return this.isEven();
        return this.mod(n).isZero();
      };
      NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
      function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(49)) return true;
      }
      function millerRabinTest(n, a) {
        var nPrev = n.prev(), b = nPrev, r = 0, d, t, i2, x;
        while (b.isEven()) b = b.divide(2), r++;
        next: for (i2 = 0; i2 < a.length; i2++) {
          if (n.lesser(a[i2])) continue;
          x = bigInt(a[i2]).modPow(b, n);
          if (x.isUnit() || x.equals(nPrev)) continue;
          for (d = r - 1; d != 0; d--) {
            x = x.square().mod(n);
            if (x.isUnit()) return false;
            if (x.equals(nPrev)) continue next;
          }
          return false;
        }
        return true;
      }
      BigInteger.prototype.isPrime = function(strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined2) return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64)
          return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
        for (var a = [], i2 = 0; i2 < t; i2++) {
          a.push(bigInt(i2 + 2));
        }
        return millerRabinTest(n, a);
      };
      NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
      BigInteger.prototype.isProbablePrime = function(iterations, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined2) return isPrime;
        var n = this.abs();
        var t = iterations === undefined2 ? 5 : iterations;
        for (var a = [], i2 = 0; i2 < t; i2++) {
          a.push(bigInt.randBetween(2, n.minus(2), rng));
        }
        return millerRabinTest(n, a);
      };
      NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
      BigInteger.prototype.modInv = function(n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
          q = r.divide(newR);
          lastT = t;
          lastR = r;
          t = newT;
          r = newR;
          newT = lastT.subtract(q.multiply(newT));
          newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
          t = t.add(n);
        }
        if (this.isNegative()) {
          return t.negate();
        }
        return t;
      };
      NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
      BigInteger.prototype.next = function() {
        var value = this.value;
        if (this.sign) {
          return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
      };
      SmallInteger.prototype.next = function() {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
      };
      NativeBigInt.prototype.next = function() {
        return new NativeBigInt(this.value + BigInt(1));
      };
      BigInteger.prototype.prev = function() {
        var value = this.value;
        if (this.sign) {
          return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
      };
      SmallInteger.prototype.prev = function() {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
      };
      NativeBigInt.prototype.prev = function() {
        return new NativeBigInt(this.value - BigInt(1));
      };
      var powersOfTwo = [1];
      while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
      var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
      function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
      }
      BigInteger.prototype.shiftLeft = function(v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        if (result.isZero()) return result;
        while (n >= powers2Length) {
          result = result.multiply(highestPower2);
          n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
      };
      NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
      BigInteger.prototype.shiftRight = function(v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
          if (result.isZero() || result.isNegative() && result.isUnit()) return result;
          remQuo = divModAny(result, highestPower2);
          result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
          n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
      };
      NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
      function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
          xDivMod = divModAny(xRem, highestPower2);
          xDigit = xDivMod[1].toJSNumber();
          if (xSign) {
            xDigit = highestPower2 - 1 - xDigit;
          }
          yDivMod = divModAny(yRem, highestPower2);
          yDigit = yDivMod[1].toJSNumber();
          if (ySign) {
            yDigit = highestPower2 - 1 - yDigit;
          }
          xRem = xDivMod[0];
          yRem = yDivMod[0];
          result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i2 = result.length - 1; i2 >= 0; i2 -= 1) {
          sum = sum.multiply(highestPower2).add(bigInt(result[i2]));
        }
        return sum;
      }
      BigInteger.prototype.not = function() {
        return this.negate().prev();
      };
      NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
      BigInteger.prototype.and = function(n) {
        return bitwise(this, n, function(a, b) {
          return a & b;
        });
      };
      NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
      BigInteger.prototype.or = function(n) {
        return bitwise(this, n, function(a, b) {
          return a | b;
        });
      };
      NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
      BigInteger.prototype.xor = function(n) {
        return bitwise(this, n, function(a, b) {
          return a ^ b;
        });
      };
      NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
      var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
      function roughLOB(n) {
        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
      }
      function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
          var tmp = integerLogarithm(value, base.square(base));
          var p = tmp.p;
          var e = tmp.e;
          var t = p.multiply(base);
          return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };
        }
        return { p: bigInt(1), e: 0 };
      }
      BigInteger.prototype.bitLength = function() {
        var n = this;
        if (n.compareTo(bigInt(0)) < 0) {
          n = n.negate().subtract(bigInt(1));
        }
        if (n.compareTo(bigInt(0)) === 0) {
          return bigInt(0);
        }
        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
      };
      NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
      function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
      }
      function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
      }
      function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
          d = min(roughLOB(a), roughLOB(b));
          a = a.divide(d);
          b = b.divide(d);
          c = c.multiply(d);
        }
        while (a.isEven()) {
          a = a.divide(roughLOB(a));
        }
        do {
          while (b.isEven()) {
            b = b.divide(roughLOB(b));
          }
          if (a.greater(b)) {
            t = b;
            b = a;
            a = t;
          }
          b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
      }
      function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
      }
      function randBetween(a, b, rng) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng || Math.random;
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result = [], restricted = true;
        for (var i2 = 0; i2 < digits.length; i2++) {
          var top = restricted ? digits[i2] + (i2 + 1 < digits.length ? digits[i2 + 1] / BASE : 0) : BASE;
          var digit = truncate(usedRNG() * top);
          result.push(digit);
          if (digit < digits[i2]) restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
      }
      var parseBase = function(text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
          text = text.toLowerCase();
          alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i2;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i2 = 0; i2 < alphabet.length; i2++) {
          alphabetValues[alphabet[i2]] = i2;
        }
        for (i2 = 0; i2 < length; i2++) {
          var c = text[i2];
          if (c === "-") continue;
          if (c in alphabetValues) {
            if (alphabetValues[c] >= absBase) {
              if (c === "1" && absBase === 1) continue;
              throw new Error(c + " is not a valid digit in base " + base + ".");
            }
          }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i2 = isNegative ? 1 : 0; i2 < text.length; i2++) {
          var c = text[i2];
          if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
          else if (c === "<") {
            var start = i2;
            do {
              i2++;
            } while (text[i2] !== ">" && i2 < text.length);
            digits.push(parseValue(text.slice(start + 1, i2)));
          } else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
      };
      function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i2;
        for (i2 = digits.length - 1; i2 >= 0; i2--) {
          val = val.add(digits[i2].times(pow));
          pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
      }
      function stringify(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
          return alphabet[digit];
        }
        return "<" + digit + ">";
      }
      function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
          if (n.isZero()) return { value: [0], isNegative: false };
          throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
          if (n.isZero()) return { value: [0], isNegative: false };
          if (n.isNegative())
            return {
              value: [].concat.apply(
                [],
                Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
              ),
              isNegative: false
            };
          var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
          arr.unshift([1]);
          return {
            value: [].concat.apply([], arr),
            isNegative: false
          };
        }
        var neg = false;
        if (n.isNegative() && base.isPositive()) {
          neg = true;
          n = n.abs();
        }
        if (base.isUnit()) {
          if (n.isZero()) return { value: [0], isNegative: false };
          return {
            value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
            isNegative: neg
          };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
          divmod = left.divmod(base);
          left = divmod.quotient;
          var digit = divmod.remainder;
          if (digit.isNegative()) {
            digit = base.minus(digit).abs();
            left = left.next();
          }
          out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
      }
      function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
          return stringify(x, alphabet);
        }).join("");
      }
      BigInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      SmallInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      NativeBigInt.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      BigInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined2) radix = 10;
        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
          digit = String(v[l]);
          str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
      };
      SmallInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined2) radix = 10;
        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);
        return String(this.value);
      };
      NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
      NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
        return this.toString();
      };
      BigInteger.prototype.valueOf = function() {
        return parseInt(this.toString(), 10);
      };
      BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
      SmallInteger.prototype.valueOf = function() {
        return this.value;
      };
      SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
      NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
        return parseInt(this.toString(), 10);
      };
      function parseStringValue(v) {
        if (isPrecise(+v)) {
          var x = +v;
          if (x === truncate(x))
            return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
          throw new Error("Invalid integer: " + v);
        }
        var sign = v[0] === "-";
        if (sign) v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
          var exp = split[1];
          if (exp[0] === "+") exp = exp.slice(1);
          exp = +exp;
          if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
          var text = split[0];
          var decimalPlace = text.indexOf(".");
          if (decimalPlace >= 0) {
            exp -= text.length - decimalPlace - 1;
            text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
          }
          if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
          text += new Array(exp + 1).join("0");
          v = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid) throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }
        var r = [], max2 = v.length, l = LOG_BASE, min2 = max2 - l;
        while (max2 > 0) {
          r.push(+v.slice(min2, max2));
          min2 -= l;
          if (min2 < 0) min2 = 0;
          max2 -= l;
        }
        trim(r);
        return new BigInteger(r, sign);
      }
      function parseNumberValue(v) {
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
          if (v !== truncate(v)) throw new Error(v + " is not an integer.");
          return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
      }
      function parseValue(v) {
        if (typeof v === "number") {
          return parseNumberValue(v);
        }
        if (typeof v === "string") {
          return parseStringValue(v);
        }
        if (typeof v === "bigint") {
          return new NativeBigInt(v);
        }
        return v;
      }
      for (var i = 0; i < 1e3; i++) {
        Integer[i] = parseValue(i);
        if (i > 0) Integer[-i] = parseValue(-i);
      }
      Integer.one = Integer[1];
      Integer.zero = Integer[0];
      Integer.minusOne = Integer[-1];
      Integer.max = max;
      Integer.min = min;
      Integer.gcd = gcd;
      Integer.lcm = lcm;
      Integer.isInstance = function(x) {
        return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
      };
      Integer.randBetween = randBetween;
      Integer.fromArray = function(digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
      };
      return Integer;
    }();
    if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
      module.exports = bigInt;
    }
    if (typeof define === "function" && define.amd) {
      define(function() {
        return bigInt;
      });
    }
  }
});

// node_modules/ripple-binary-codec/dist/types/amount.js
var require_amount3 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/amount.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Amount = void 0;
    var decimal_js_1 = require_decimal();
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var currency_1 = require_currency2();
    var serialized_type_1 = require_serialized_type();
    var bigInt = require_BigInteger();
    var buffer_1 = require_dist();
    var MIN_IOU_EXPONENT = -96;
    var MAX_IOU_EXPONENT = 80;
    var MAX_IOU_PRECISION = 16;
    var MAX_DROPS = new decimal_js_1.Decimal("1e17");
    var MIN_XRP = new decimal_js_1.Decimal("1e-6");
    var mask = bigInt(4294967295);
    decimal_js_1.Decimal.config({
      toExpPos: MAX_IOU_EXPONENT + MAX_IOU_PRECISION,
      toExpNeg: MIN_IOU_EXPONENT - MAX_IOU_PRECISION
    });
    function isAmountObject(arg) {
      const keys = Object.keys(arg).sort();
      return keys.length === 3 && keys[0] === "currency" && keys[1] === "issuer" && keys[2] === "value";
    }
    var Amount = class _Amount extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _Amount.defaultAmount.bytes);
      }
      /**
       * Construct an amount from an IOU or string amount
       *
       * @param value An Amount, object representing an IOU, or a string
       *     representing an integer amount
       * @returns An Amount object
       */
      static from(value) {
        if (value instanceof _Amount) {
          return value;
        }
        let amount = buffer_1.Buffer.alloc(8);
        if (typeof value === "string") {
          _Amount.assertXrpIsValid(value);
          const number = bigInt(value);
          const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
          intBuf[0].writeUInt32BE(Number(number.shiftRight(32)), 0);
          intBuf[1].writeUInt32BE(Number(number.and(mask)), 0);
          amount = buffer_1.Buffer.concat(intBuf);
          amount[0] |= 64;
          return new _Amount(amount);
        }
        if (isAmountObject(value)) {
          const number = new decimal_js_1.Decimal(value.value);
          _Amount.assertIouIsValid(number);
          if (number.isZero()) {
            amount[0] |= 128;
          } else {
            const integerNumberString = number.times(`1e${-(number.e - 15)}`).abs().toString();
            const num = bigInt(integerNumberString);
            const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
            intBuf[0].writeUInt32BE(Number(num.shiftRight(32)), 0);
            intBuf[1].writeUInt32BE(Number(num.and(mask)), 0);
            amount = buffer_1.Buffer.concat(intBuf);
            amount[0] |= 128;
            if (number.gt(new decimal_js_1.Decimal(0))) {
              amount[0] |= 64;
            }
            const exponent = number.e - 15;
            const exponentByte = 97 + exponent;
            amount[0] |= exponentByte >>> 2;
            amount[1] |= (exponentByte & 3) << 6;
          }
          const currency = currency_1.Currency.from(value.currency).toBytes();
          const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
          return new _Amount(buffer_1.Buffer.concat([amount, currency, issuer]));
        }
        throw new Error("Invalid type to construct an Amount");
      }
      /**
       * Read an amount from a BinaryParser
       *
       * @param parser BinaryParser to read the Amount from
       * @returns An Amount object
       */
      static fromParser(parser) {
        const isXRP = parser.peek() & 128;
        const numBytes = isXRP ? 48 : 8;
        return new _Amount(parser.read(numBytes));
      }
      /**
       * Get the JSON representation of this Amount
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        if (this.isNative()) {
          const bytes = this.bytes;
          const isPositive = bytes[0] & 64;
          const sign = isPositive ? "" : "-";
          bytes[0] &= 63;
          const msb = bigInt(bytes.slice(0, 4).readUInt32BE(0));
          const lsb = bigInt(bytes.slice(4).readUInt32BE(0));
          const num = msb.shiftLeft(32).or(lsb);
          return `${sign}${num.toString()}`;
        } else {
          const parser = new binary_parser_1.BinaryParser(this.toString());
          const mantissa = parser.read(8);
          const currency = currency_1.Currency.fromParser(parser);
          const issuer = account_id_1.AccountID.fromParser(parser);
          const b1 = mantissa[0];
          const b2 = mantissa[1];
          const isPositive = b1 & 64;
          const sign = isPositive ? "" : "-";
          const exponent = ((b1 & 63) << 2) + ((b2 & 255) >> 6) - 97;
          mantissa[0] = 0;
          mantissa[1] &= 63;
          const value = new decimal_js_1.Decimal(`${sign}0x${mantissa.toString("hex")}`).times(`1e${exponent}`);
          _Amount.assertIouIsValid(value);
          return {
            value: value.toString(),
            currency: currency.toJSON(),
            issuer: issuer.toJSON()
          };
        }
      }
      /**
       * Validate XRP amount
       *
       * @param amount String representing XRP amount
       * @returns void, but will throw if invalid amount
       */
      static assertXrpIsValid(amount) {
        if (amount.indexOf(".") !== -1) {
          throw new Error(`${amount.toString()} is an illegal amount`);
        }
        const decimal = new decimal_js_1.Decimal(amount);
        if (!decimal.isZero()) {
          if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {
            throw new Error(`${amount.toString()} is an illegal amount`);
          }
        }
      }
      /**
       * Validate IOU.value amount
       *
       * @param decimal Decimal.js object representing IOU.value
       * @returns void, but will throw if invalid amount
       */
      static assertIouIsValid(decimal) {
        if (!decimal.isZero()) {
          const p = decimal.precision();
          const e = decimal.e - 15;
          if (p > MAX_IOU_PRECISION || e > MAX_IOU_EXPONENT || e < MIN_IOU_EXPONENT) {
            throw new Error("Decimal precision out of range");
          }
          this.verifyNoDecimal(decimal);
        }
      }
      /**
       * Ensure that the value after being multiplied by the exponent does not
       * contain a decimal.
       *
       * @param decimal a Decimal object
       * @returns a string of the object without a decimal
       */
      static verifyNoDecimal(decimal) {
        const integerNumberString = decimal.times(`1e${-(decimal.e - 15)}`).abs().toString();
        if (integerNumberString.indexOf(".") !== -1) {
          throw new Error("Decimal place found in integerNumberString");
        }
      }
      /**
       * Test if this amount is in units of Native Currency(XRP)
       *
       * @returns true if Native (XRP)
       */
      isNative() {
        return (this.bytes[0] & 128) === 0;
      }
    };
    exports.Amount = Amount;
    Amount.defaultAmount = new Amount(buffer_1.Buffer.from("4000000000000000", "hex"));
  }
});

// node_modules/ripple-binary-codec/dist/types/blob.js
var require_blob2 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/blob.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Blob = void 0;
    var serialized_type_1 = require_serialized_type();
    var buffer_1 = require_dist();
    var Blob2 = class _Blob extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Defines how to read a Blob from a BinaryParser
       *
       * @param parser The binary parser to read the Blob from
       * @param hint The length of the blob, computed by readVariableLengthLength() and passed in
       * @returns A Blob object
       */
      static fromParser(parser, hint) {
        return new _Blob(parser.read(hint));
      }
      /**
       * Create a Blob object from a hex-string
       *
       * @param value existing Blob object or a hex-string
       * @returns A Blob object
       */
      static from(value) {
        if (value instanceof _Blob) {
          return value;
        }
        if (typeof value === "string") {
          return new _Blob(buffer_1.Buffer.from(value, "hex"));
        }
        throw new Error("Cannot construct Blob from value given");
      }
    };
    exports.Blob = Blob2;
  }
});

// node_modules/ripple-binary-codec/dist/types/hash-128.js
var require_hash_128 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/hash-128.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash128 = void 0;
    var hash_1 = require_hash2();
    var buffer_1 = require_dist();
    var Hash128 = class _Hash128 extends hash_1.Hash {
      constructor(bytes) {
        if (bytes && bytes.byteLength === 0) {
          bytes = _Hash128.ZERO_128.bytes;
        }
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash128.ZERO_128.bytes);
      }
      /**
       * Get the hex representation of a hash-128 bytes, allowing unset
       *
       * @returns hex String of this.bytes
       */
      toHex() {
        const hex = this.toBytes().toString("hex").toUpperCase();
        if (/^0+$/.exec(hex)) {
          return "";
        }
        return hex;
      }
    };
    exports.Hash128 = Hash128;
    Hash128.width = 16;
    Hash128.ZERO_128 = new Hash128(buffer_1.Buffer.alloc(Hash128.width));
  }
});

// node_modules/ripple-binary-codec/dist/types/hash-256.js
var require_hash_256 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/hash-256.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash256 = void 0;
    var hash_1 = require_hash2();
    var buffer_1 = require_dist();
    var Hash256 = class _Hash256 extends hash_1.Hash {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _Hash256.ZERO_256.bytes);
      }
    };
    exports.Hash256 = Hash256;
    Hash256.width = 32;
    Hash256.ZERO_256 = new Hash256(buffer_1.Buffer.alloc(Hash256.width));
  }
});

// node_modules/ripple-binary-codec/dist/types/issue.js
var require_issue2 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/issue.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Issue = void 0;
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var currency_1 = require_currency2();
    var serialized_type_1 = require_serialized_type();
    var buffer_1 = require_dist();
    function isIssueObject(arg) {
      const keys = Object.keys(arg).sort();
      if (keys.length === 1) {
        return keys[0] === "currency";
      }
      return keys.length === 2 && keys[0] === "currency" && keys[1] === "issuer";
    }
    var Issue = class _Issue extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _Issue.ZERO_ISSUED_CURRENCY.bytes);
      }
      /**
       * Construct an amount from an IOU or string amount
       *
       * @param value An Amount, object representing an IOU, or a string
       *     representing an integer amount
       * @returns An Amount object
       */
      static from(value) {
        if (value instanceof _Issue) {
          return value;
        }
        if (isIssueObject(value)) {
          const currency = currency_1.Currency.from(value.currency).toBytes();
          if (value.issuer == null) {
            return new _Issue(currency);
          }
          const issuer = account_id_1.AccountID.from(value.issuer).toBytes();
          return new _Issue(buffer_1.Buffer.concat([currency, issuer]));
        }
        throw new Error("Invalid type to construct an Amount");
      }
      /**
       * Read an amount from a BinaryParser
       *
       * @param parser BinaryParser to read the Amount from
       * @returns An Amount object
       */
      static fromParser(parser) {
        const currency = parser.read(20);
        if (new currency_1.Currency(currency).toJSON() === "XRP") {
          return new _Issue(currency);
        }
        const currencyAndIssuer = [currency, parser.read(20)];
        return new _Issue(buffer_1.Buffer.concat(currencyAndIssuer));
      }
      /**
       * Get the JSON representation of this Amount
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const currency = currency_1.Currency.fromParser(parser);
        if (currency.toJSON() === "XRP") {
          return { currency: currency.toJSON() };
        }
        const issuer = account_id_1.AccountID.fromParser(parser);
        return {
          currency: currency.toJSON(),
          issuer: issuer.toJSON()
        };
      }
    };
    exports.Issue = Issue;
    Issue.ZERO_ISSUED_CURRENCY = new Issue(buffer_1.Buffer.alloc(20));
  }
});

// node_modules/ripple-binary-codec/dist/types/path-set.js
var require_path_set = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/path-set.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PathSet = void 0;
    var account_id_1 = require_account_id();
    var currency_1 = require_currency2();
    var binary_parser_1 = require_binary_parser();
    var serialized_type_1 = require_serialized_type();
    var buffer_1 = require_dist();
    var PATHSET_END_BYTE = 0;
    var PATH_SEPARATOR_BYTE = 255;
    var TYPE_ACCOUNT = 1;
    var TYPE_CURRENCY = 16;
    var TYPE_ISSUER = 32;
    function isHopObject(arg) {
      return arg.issuer !== void 0 || arg.account !== void 0 || arg.currency !== void 0;
    }
    function isPathSet(arg) {
      return Array.isArray(arg) && arg.length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0 || Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0]);
    }
    var Hop = class _Hop extends serialized_type_1.SerializedType {
      /**
       * Create a Hop from a HopObject
       *
       * @param value Either a hop or HopObject to create a hop with
       * @returns a Hop
       */
      static from(value) {
        if (value instanceof _Hop) {
          return value;
        }
        const bytes = [buffer_1.Buffer.from([0])];
        if (value.account) {
          bytes.push(account_id_1.AccountID.from(value.account).toBytes());
          bytes[0][0] |= TYPE_ACCOUNT;
        }
        if (value.currency) {
          bytes.push(currency_1.Currency.from(value.currency).toBytes());
          bytes[0][0] |= TYPE_CURRENCY;
        }
        if (value.issuer) {
          bytes.push(account_id_1.AccountID.from(value.issuer).toBytes());
          bytes[0][0] |= TYPE_ISSUER;
        }
        return new _Hop(buffer_1.Buffer.concat(bytes));
      }
      /**
       * Construct a Hop from a BinaryParser
       *
       * @param parser BinaryParser to read the Hop from
       * @returns a Hop
       */
      static fromParser(parser) {
        const type = parser.readUInt8();
        const bytes = [buffer_1.Buffer.from([type])];
        if (type & TYPE_ACCOUNT) {
          bytes.push(parser.read(account_id_1.AccountID.width));
        }
        if (type & TYPE_CURRENCY) {
          bytes.push(parser.read(currency_1.Currency.width));
        }
        if (type & TYPE_ISSUER) {
          bytes.push(parser.read(account_id_1.AccountID.width));
        }
        return new _Hop(buffer_1.Buffer.concat(bytes));
      }
      /**
       * Get the JSON interpretation of this hop
       *
       * @returns a HopObject, an JS object with optional account, issuer, and currency
       */
      toJSON() {
        const hopParser = new binary_parser_1.BinaryParser(this.bytes.toString("hex"));
        const type = hopParser.readUInt8();
        let account, currency, issuer;
        if (type & TYPE_ACCOUNT) {
          account = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_CURRENCY) {
          currency = currency_1.Currency.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_ISSUER) {
          issuer = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        const result = {};
        if (account) {
          result.account = account;
        }
        if (issuer) {
          result.issuer = issuer;
        }
        if (currency) {
          result.currency = currency;
        }
        return result;
      }
      /**
       * get a number representing the type of this hop
       *
       * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop
       */
      type() {
        return this.bytes[0];
      }
    };
    var Path = class _Path extends serialized_type_1.SerializedType {
      /**
       * construct a Path from an array of Hops
       *
       * @param value Path or array of HopObjects to construct a Path
       * @returns the Path
       */
      static from(value) {
        if (value instanceof _Path) {
          return value;
        }
        const bytes = [];
        value.forEach((hop) => {
          bytes.push(Hop.from(hop).toBytes());
        });
        return new _Path(buffer_1.Buffer.concat(bytes));
      }
      /**
       * Read a Path from a BinaryParser
       *
       * @param parser BinaryParser to read Path from
       * @returns the Path represented by the bytes read from the BinaryParser
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          bytes.push(Hop.fromParser(parser).toBytes());
          if (parser.peek() === PATHSET_END_BYTE || parser.peek() === PATH_SEPARATOR_BYTE) {
            break;
          }
        }
        return new _Path(buffer_1.Buffer.concat(bytes));
      }
      /**
       * Get the JSON representation of this Path
       *
       * @returns an Array of HopObject constructed from this.bytes
       */
      toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
          json.push(Hop.fromParser(pathParser).toJSON());
        }
        return json;
      }
    };
    var PathSet = class _PathSet extends serialized_type_1.SerializedType {
      /**
       * Construct a PathSet from an Array of Arrays representing paths
       *
       * @param value A PathSet or Array of Array of HopObjects
       * @returns the PathSet constructed from value
       */
      static from(value) {
        if (value instanceof _PathSet) {
          return value;
        }
        if (isPathSet(value)) {
          const bytes = [];
          value.forEach((path) => {
            bytes.push(Path.from(path).toBytes());
            bytes.push(buffer_1.Buffer.from([PATH_SEPARATOR_BYTE]));
          });
          bytes[bytes.length - 1] = buffer_1.Buffer.from([PATHSET_END_BYTE]);
          return new _PathSet(buffer_1.Buffer.concat(bytes));
        }
        throw new Error("Cannot construct PathSet from given value");
      }
      /**
       * Construct a PathSet from a BinaryParser
       *
       * @param parser A BinaryParser to read PathSet from
       * @returns the PathSet read from parser
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          bytes.push(Path.fromParser(parser).toBytes());
          bytes.push(parser.read(1));
          if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {
            break;
          }
        }
        return new _PathSet(buffer_1.Buffer.concat(bytes));
      }
      /**
       * Get the JSON representation of this PathSet
       *
       * @returns an Array of Array of HopObjects, representing this PathSet
       */
      toJSON() {
        const json = [];
        const pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
          json.push(Path.fromParser(pathParser).toJSON());
          pathParser.skip(1);
        }
        return json;
      }
    };
    exports.PathSet = PathSet;
  }
});

// node_modules/ripple-binary-codec/dist/types/st-object.js
var require_st_object = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/st-object.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STObject = void 0;
    var enums_1 = require_enums();
    var serialized_type_1 = require_serialized_type();
    var ripple_address_codec_1 = require_dist4();
    var binary_parser_1 = require_binary_parser();
    var binary_serializer_1 = require_binary_serializer();
    var buffer_1 = require_dist();
    var st_array_1 = require_st_array();
    var OBJECT_END_MARKER_BYTE = buffer_1.Buffer.from([225]);
    var OBJECT_END_MARKER = "ObjectEndMarker";
    var ST_OBJECT = "STObject";
    var DESTINATION = "Destination";
    var ACCOUNT = "Account";
    var SOURCE_TAG = "SourceTag";
    var DEST_TAG = "DestinationTag";
    function handleXAddress(field, xAddress) {
      const decoded = (0, ripple_address_codec_1.xAddressToClassicAddress)(xAddress);
      let tagName;
      if (field === DESTINATION)
        tagName = DEST_TAG;
      else if (field === ACCOUNT)
        tagName = SOURCE_TAG;
      else if (decoded.tag !== false)
        throw new Error(`${field} cannot have an associated tag`);
      return decoded.tag !== false ? { [field]: decoded.classicAddress, [tagName]: decoded.tag } : { [field]: decoded.classicAddress };
    }
    function checkForDuplicateTags(obj1, obj2) {
      if (!(obj1[SOURCE_TAG] === void 0 || obj2[SOURCE_TAG] === void 0))
        throw new Error("Cannot have Account X-Address and SourceTag");
      if (!(obj1[DEST_TAG] === void 0 || obj2[DEST_TAG] === void 0))
        throw new Error("Cannot have Destination X-Address and DestinationTag");
    }
    var STObject = class _STObject extends serialized_type_1.SerializedType {
      /**
       * Construct a STObject from a BinaryParser
       *
       * @param parser BinaryParser to read STObject from
       * @returns A STObject object
       */
      static fromParser(parser) {
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        while (!parser.end()) {
          const field = parser.readField();
          if (field.name === OBJECT_END_MARKER) {
            break;
          }
          const associatedValue = parser.readFieldValue(field);
          bytes.writeFieldAndValue(field, associatedValue);
          if (field.type.name === ST_OBJECT) {
            bytes.put(OBJECT_END_MARKER_BYTE);
          }
        }
        return new _STObject(list.toBytes());
      }
      /**
       * Construct a STObject from a JSON object
       *
       * @param value An object to include
       * @param filter optional, denote which field to include in serialized object
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns a STObject object
       */
      static from(value, filter2, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof _STObject) {
          return value;
        }
        const list = new binary_serializer_1.BytesList();
        const bytes = new binary_serializer_1.BinarySerializer(list);
        let isUnlModify = false;
        const xAddressDecoded = Object.entries(value).reduce((acc, [key, val]) => {
          let handled = void 0;
          if (val && (0, ripple_address_codec_1.isValidXAddress)(val.toString())) {
            handled = handleXAddress(key, val.toString());
            checkForDuplicateTags(handled, value);
          }
          return Object.assign(acc, handled !== null && handled !== void 0 ? handled : { [key]: val });
        }, {});
        let sorted = Object.keys(xAddressDecoded).map((f) => definitions.field[f]).filter((f) => f !== void 0 && xAddressDecoded[f.name] !== void 0 && f.isSerialized).sort((a, b) => {
          return a.ordinal - b.ordinal;
        });
        if (filter2 !== void 0) {
          sorted = sorted.filter(filter2);
        }
        sorted.forEach((field) => {
          const associatedValue = field.type.name === ST_OBJECT ? this.from(xAddressDecoded[field.name], void 0, definitions) : field.type.name === "STArray" ? st_array_1.STArray.from(xAddressDecoded[field.name], definitions) : field.associatedType.from(xAddressDecoded[field.name]);
          if (associatedValue == void 0) {
            throw new TypeError(`Unable to interpret "${field.name}: ${xAddressDecoded[field.name]}".`);
          }
          if (associatedValue.name === "UNLModify") {
            isUnlModify = true;
          }
          const isUnlModifyWorkaround = field.name == "Account" && isUnlModify;
          bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);
          if (field.type.name === ST_OBJECT) {
            bytes.put(OBJECT_END_MARKER_BYTE);
          }
        });
        return new _STObject(list.toBytes());
      }
      /**
       * Get the JSON interpretation of this.bytes
       * @param definitions rippled definitions used to parse the values of transaction types and such.
       *                          Can be customized for sidechains and amendments.
       * @returns a JSON object
       */
      toJSON(definitions) {
        const objectParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        const accumulator = {};
        while (!objectParser.end()) {
          const field = objectParser.readField();
          if (field.name === OBJECT_END_MARKER) {
            break;
          }
          accumulator[field.name] = objectParser.readFieldValue(field).toJSON(definitions);
        }
        return accumulator;
      }
    };
    exports.STObject = STObject;
  }
});

// node_modules/ripple-binary-codec/dist/types/st-array.js
var require_st_array = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/st-array.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STArray = void 0;
    var enums_1 = require_enums();
    var serialized_type_1 = require_serialized_type();
    var st_object_1 = require_st_object();
    var binary_parser_1 = require_binary_parser();
    var buffer_1 = require_dist();
    var ARRAY_END_MARKER = buffer_1.Buffer.from([241]);
    var ARRAY_END_MARKER_NAME = "ArrayEndMarker";
    var OBJECT_END_MARKER = buffer_1.Buffer.from([225]);
    function isObjects(args) {
      return Array.isArray(args) && (args.length === 0 || typeof args[0] === "object");
    }
    var STArray = class _STArray extends serialized_type_1.SerializedType {
      /**
       * Construct an STArray from a BinaryParser
       *
       * @param parser BinaryParser to parse an STArray from
       * @returns An STArray Object
       */
      static fromParser(parser) {
        const bytes = [];
        while (!parser.end()) {
          const field = parser.readField();
          if (field.name === ARRAY_END_MARKER_NAME) {
            break;
          }
          bytes.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);
        }
        bytes.push(ARRAY_END_MARKER);
        return new _STArray(buffer_1.Buffer.concat(bytes));
      }
      /**
       * Construct an STArray from an Array of JSON Objects
       *
       * @param value STArray or Array of Objects to parse into an STArray
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns An STArray object
       */
      static from(value, definitions = enums_1.DEFAULT_DEFINITIONS) {
        if (value instanceof _STArray) {
          return value;
        }
        if (isObjects(value)) {
          const bytes = [];
          value.forEach((obj) => {
            bytes.push(st_object_1.STObject.from(obj, void 0, definitions).toBytes());
          });
          bytes.push(ARRAY_END_MARKER);
          return new _STArray(buffer_1.Buffer.concat(bytes));
        }
        throw new Error("Cannot construct STArray from value given");
      }
      /**
       * Return the JSON representation of this.bytes
       *
       * @param definitions optional, types and values to use to encode/decode a transaction
       * @returns An Array of JSON objects
       */
      toJSON(definitions = enums_1.DEFAULT_DEFINITIONS) {
        const result = [];
        const arrayParser = new binary_parser_1.BinaryParser(this.toString(), definitions);
        while (!arrayParser.end()) {
          const field = arrayParser.readField();
          if (field.name === ARRAY_END_MARKER_NAME) {
            break;
          }
          const outer = {};
          outer[field.name] = st_object_1.STObject.fromParser(arrayParser).toJSON(definitions);
          result.push(outer);
        }
        return result;
      }
    };
    exports.STArray = STArray;
  }
});

// node_modules/ripple-binary-codec/dist/types/uint.js
var require_uint = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/uint.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt = void 0;
    var serialized_type_1 = require_serialized_type();
    function compare(n1, n2) {
      return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;
    }
    var UInt = class extends serialized_type_1.Comparable {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Overload of compareTo for Comparable
       *
       * @param other other UInt to compare this to
       * @returns -1, 0, or 1 depending on how the objects relate to each other
       */
      compareTo(other) {
        return compare(this.valueOf(), other.valueOf());
      }
      /**
       * Convert a UInt object to JSON
       *
       * @returns number or string represented by this.bytes
       */
      toJSON() {
        const val = this.valueOf();
        return typeof val === "number" ? val : val.toString();
      }
    };
    exports.UInt = UInt;
  }
});

// node_modules/ripple-binary-codec/dist/types/uint-16.js
var require_uint_16 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/uint-16.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt16 = void 0;
    var uint_1 = require_uint();
    var buffer_1 = require_dist();
    var UInt16 = class _UInt16 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt16.defaultUInt16.bytes);
      }
      static fromParser(parser) {
        return new _UInt16(parser.read(_UInt16.width));
      }
      /**
       * Construct a UInt16 object from a number
       *
       * @param val UInt16 object or number
       */
      static from(val) {
        if (val instanceof _UInt16) {
          return val;
        }
        if (typeof val === "number") {
          const buf = buffer_1.Buffer.alloc(_UInt16.width);
          buf.writeUInt16BE(val, 0);
          return new _UInt16(buf);
        }
        throw new Error("Can not construct UInt16 with given value");
      }
      /**
       * get the value of a UInt16 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return this.bytes.readUInt16BE(0);
      }
    };
    exports.UInt16 = UInt16;
    UInt16.width = 16 / 8;
    UInt16.defaultUInt16 = new UInt16(buffer_1.Buffer.alloc(UInt16.width));
  }
});

// node_modules/ripple-binary-codec/dist/types/uint-32.js
var require_uint_32 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/uint-32.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt32 = void 0;
    var uint_1 = require_uint();
    var buffer_1 = require_dist();
    var UInt32 = class _UInt32 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt32.defaultUInt32.bytes);
      }
      static fromParser(parser) {
        return new _UInt32(parser.read(_UInt32.width));
      }
      /**
       * Construct a UInt32 object from a number
       *
       * @param val UInt32 object or number
       */
      static from(val) {
        if (val instanceof _UInt32) {
          return val;
        }
        const buf = buffer_1.Buffer.alloc(_UInt32.width);
        if (typeof val === "string") {
          const num = Number.parseInt(val);
          buf.writeUInt32BE(num, 0);
          return new _UInt32(buf);
        }
        if (typeof val === "number") {
          buf.writeUInt32BE(val, 0);
          return new _UInt32(buf);
        }
        throw new Error("Cannot construct UInt32 from given value");
      }
      /**
       * get the value of a UInt32 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return this.bytes.readUInt32BE(0);
      }
    };
    exports.UInt32 = UInt32;
    UInt32.width = 32 / 8;
    UInt32.defaultUInt32 = new UInt32(buffer_1.Buffer.alloc(UInt32.width));
  }
});

// node_modules/ripple-binary-codec/dist/types/uint-64.js
var require_uint_64 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/uint-64.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt64 = void 0;
    var uint_1 = require_uint();
    var bigInt = require_BigInteger();
    var big_integer_1 = require_BigInteger();
    var buffer_1 = require_dist();
    var HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;
    var mask = bigInt(4294967295);
    var UInt64 = class _UInt64 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt64.defaultUInt64.bytes);
      }
      static fromParser(parser) {
        return new _UInt64(parser.read(_UInt64.width));
      }
      /**
       * Construct a UInt64 object
       *
       * @param val A UInt64, hex-string, bigInt, or number
       * @returns A UInt64 object
       */
      static from(val) {
        if (val instanceof _UInt64) {
          return val;
        }
        let buf = buffer_1.Buffer.alloc(_UInt64.width);
        if (typeof val === "number") {
          if (val < 0) {
            throw new Error("value must be an unsigned integer");
          }
          const number = bigInt(val);
          const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
          intBuf[0].writeUInt32BE(Number(number.shiftRight(32)), 0);
          intBuf[1].writeUInt32BE(Number(number.and(mask)), 0);
          return new _UInt64(buffer_1.Buffer.concat(intBuf));
        }
        if (typeof val === "string") {
          if (!HEX_REGEX.test(val)) {
            throw new Error(`${val} is not a valid hex-string`);
          }
          const strBuf = val.padStart(16, "0");
          buf = buffer_1.Buffer.from(strBuf, "hex");
          return new _UInt64(buf);
        }
        if ((0, big_integer_1.isInstance)(val)) {
          const intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
          intBuf[0].writeUInt32BE(Number(val.shiftRight(bigInt(32))), 0);
          intBuf[1].writeUInt32BE(Number(val.and(mask)), 0);
          return new _UInt64(buffer_1.Buffer.concat(intBuf));
        }
        throw new Error("Cannot construct UInt64 from given value");
      }
      /**
       * The JSON representation of a UInt64 object
       *
       * @returns a hex-string
       */
      toJSON() {
        return this.bytes.toString("hex").toUpperCase();
      }
      /**
       * Get the value of the UInt64
       *
       * @returns the number represented buy this.bytes
       */
      valueOf() {
        const msb = bigInt(this.bytes.slice(0, 4).readUInt32BE(0));
        const lsb = bigInt(this.bytes.slice(4).readUInt32BE(0));
        return msb.shiftLeft(bigInt(32)).or(lsb);
      }
      /**
       * Get the bytes representation of the UInt64 object
       *
       * @returns 8 bytes representing the UInt64
       */
      toBytes() {
        return this.bytes;
      }
    };
    exports.UInt64 = UInt64;
    UInt64.width = 64 / 8;
    UInt64.defaultUInt64 = new UInt64(buffer_1.Buffer.alloc(UInt64.width));
  }
});

// node_modules/ripple-binary-codec/dist/types/uint-8.js
var require_uint_8 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/uint-8.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UInt8 = void 0;
    var uint_1 = require_uint();
    var buffer_1 = require_dist();
    var UInt8 = class _UInt8 extends uint_1.UInt {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _UInt8.defaultUInt8.bytes);
      }
      static fromParser(parser) {
        return new _UInt8(parser.read(_UInt8.width));
      }
      /**
       * Construct a UInt8 object from a number
       *
       * @param val UInt8 object or number
       */
      static from(val) {
        if (val instanceof _UInt8) {
          return val;
        }
        if (typeof val === "number") {
          const buf = buffer_1.Buffer.alloc(_UInt8.width);
          buf.writeUInt8(val, 0);
          return new _UInt8(buf);
        }
        throw new Error("Cannot construct UInt8 from given value");
      }
      /**
       * get the value of a UInt8 object
       *
       * @returns the number represented by this.bytes
       */
      valueOf() {
        return this.bytes.readUInt8(0);
      }
    };
    exports.UInt8 = UInt8;
    UInt8.width = 8 / 8;
    UInt8.defaultUInt8 = new UInt8(buffer_1.Buffer.alloc(UInt8.width));
  }
});

// node_modules/ripple-binary-codec/dist/types/vector-256.js
var require_vector_256 = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/vector-256.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Vector256 = void 0;
    var serialized_type_1 = require_serialized_type();
    var hash_256_1 = require_hash_256();
    var binary_serializer_1 = require_binary_serializer();
    function isStrings(arg) {
      return Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === "string");
    }
    var Vector256 = class _Vector256 extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes);
      }
      /**
       * Construct a Vector256 from a BinaryParser
       *
       * @param parser BinaryParser to
       * @param hint length of the vector, in bytes, optional
       * @returns a Vector256 object
       */
      static fromParser(parser, hint) {
        const bytesList = new binary_serializer_1.BytesList();
        const bytes = hint !== null && hint !== void 0 ? hint : parser.size();
        const hashes = bytes / 32;
        for (let i = 0; i < hashes; i++) {
          hash_256_1.Hash256.fromParser(parser).toBytesSink(bytesList);
        }
        return new _Vector256(bytesList.toBytes());
      }
      /**
       * Construct a Vector256 object from an array of hashes
       *
       * @param value A Vector256 object or array of hex-strings representing Hash256's
       * @returns a Vector256 object
       */
      static from(value) {
        if (value instanceof _Vector256) {
          return value;
        }
        if (isStrings(value)) {
          const bytesList = new binary_serializer_1.BytesList();
          value.forEach((hash) => {
            hash_256_1.Hash256.from(hash).toBytesSink(bytesList);
          });
          return new _Vector256(bytesList.toBytes());
        }
        throw new Error("Cannot construct Vector256 from given value");
      }
      /**
       * Return an Array of hex-strings represented by this.bytes
       *
       * @returns An Array of strings representing the Hash256 objects
       */
      toJSON() {
        if (this.bytes.byteLength % 32 !== 0) {
          throw new Error("Invalid bytes for Vector256");
        }
        const result = [];
        for (let i = 0; i < this.bytes.byteLength; i += 32) {
          result.push(this.bytes.slice(i, i + 32).toString("hex").toUpperCase());
        }
        return result;
      }
    };
    exports.Vector256 = Vector256;
  }
});

// node_modules/ripple-binary-codec/dist/types/xchain-bridge.js
var require_xchain_bridge = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/xchain-bridge.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XChainBridge = void 0;
    var binary_parser_1 = require_binary_parser();
    var account_id_1 = require_account_id();
    var serialized_type_1 = require_serialized_type();
    var buffer_1 = require_dist();
    var issue_1 = require_issue2();
    function isXChainBridgeObject(arg) {
      const keys = Object.keys(arg).sort();
      return keys.length === 4 && keys[0] === "IssuingChainDoor" && keys[1] === "IssuingChainIssue" && keys[2] === "LockingChainDoor" && keys[3] === "LockingChainIssue";
    }
    var XChainBridge = class _XChainBridge extends serialized_type_1.SerializedType {
      constructor(bytes) {
        super(bytes !== null && bytes !== void 0 ? bytes : _XChainBridge.ZERO_XCHAIN_BRIDGE.bytes);
      }
      /**
       * Construct a cross-chain bridge from a JSON
       *
       * @param value XChainBridge or JSON to parse into an XChainBridge
       * @returns An XChainBridge object
       */
      static from(value) {
        if (value instanceof _XChainBridge) {
          return value;
        }
        if (!isXChainBridgeObject(value)) {
          throw new Error("Invalid type to construct an XChainBridge");
        }
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
          const { name, type } = item;
          if (type === account_id_1.AccountID) {
            bytes.push(buffer_1.Buffer.from([20]));
          }
          const object = type.from(value[name]);
          bytes.push(object.toBytes());
        });
        return new _XChainBridge(buffer_1.Buffer.concat(bytes));
      }
      /**
       * Read an XChainBridge from a BinaryParser
       *
       * @param parser BinaryParser to read the XChainBridge from
       * @returns An XChainBridge object
       */
      static fromParser(parser) {
        const bytes = [];
        this.TYPE_ORDER.forEach((item) => {
          const { type } = item;
          if (type === account_id_1.AccountID) {
            parser.skip(1);
            bytes.push(buffer_1.Buffer.from([20]));
          }
          const object = type.fromParser(parser);
          bytes.push(object.toBytes());
        });
        return new _XChainBridge(buffer_1.Buffer.concat(bytes));
      }
      /**
       * Get the JSON representation of this XChainBridge
       *
       * @returns the JSON interpretation of this.bytes
       */
      toJSON() {
        const parser = new binary_parser_1.BinaryParser(this.toString());
        const json = {};
        _XChainBridge.TYPE_ORDER.forEach((item) => {
          const { name, type } = item;
          if (type === account_id_1.AccountID) {
            parser.skip(1);
          }
          const object = type.fromParser(parser).toJSON();
          json[name] = object;
        });
        return json;
      }
    };
    exports.XChainBridge = XChainBridge;
    XChainBridge.ZERO_XCHAIN_BRIDGE = new XChainBridge(buffer_1.Buffer.concat([
      buffer_1.Buffer.from([20]),
      buffer_1.Buffer.alloc(40),
      buffer_1.Buffer.from([20]),
      buffer_1.Buffer.alloc(40)
    ]));
    XChainBridge.TYPE_ORDER = [
      { name: "LockingChainDoor", type: account_id_1.AccountID },
      { name: "LockingChainIssue", type: issue_1.Issue },
      { name: "IssuingChainDoor", type: account_id_1.AccountID },
      { name: "IssuingChainIssue", type: issue_1.Issue }
    ];
  }
});

// node_modules/ripple-binary-codec/dist/types/index.js
var require_types = __commonJS({
  "node_modules/ripple-binary-codec/dist/types/index.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Vector256 = exports.UInt64 = exports.UInt32 = exports.UInt16 = exports.UInt8 = exports.STObject = exports.STArray = exports.PathSet = exports.Hash256 = exports.Hash160 = exports.Hash128 = exports.Currency = exports.Blob = exports.Amount = exports.AccountID = exports.coreTypes = void 0;
    var account_id_1 = require_account_id();
    Object.defineProperty(exports, "AccountID", { enumerable: true, get: function() {
      return account_id_1.AccountID;
    } });
    var amount_1 = require_amount3();
    Object.defineProperty(exports, "Amount", { enumerable: true, get: function() {
      return amount_1.Amount;
    } });
    var blob_1 = require_blob2();
    Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
      return blob_1.Blob;
    } });
    var currency_1 = require_currency2();
    Object.defineProperty(exports, "Currency", { enumerable: true, get: function() {
      return currency_1.Currency;
    } });
    var hash_128_1 = require_hash_128();
    Object.defineProperty(exports, "Hash128", { enumerable: true, get: function() {
      return hash_128_1.Hash128;
    } });
    var hash_160_1 = require_hash_160();
    Object.defineProperty(exports, "Hash160", { enumerable: true, get: function() {
      return hash_160_1.Hash160;
    } });
    var hash_256_1 = require_hash_256();
    Object.defineProperty(exports, "Hash256", { enumerable: true, get: function() {
      return hash_256_1.Hash256;
    } });
    var issue_1 = require_issue2();
    var path_set_1 = require_path_set();
    Object.defineProperty(exports, "PathSet", { enumerable: true, get: function() {
      return path_set_1.PathSet;
    } });
    var st_array_1 = require_st_array();
    Object.defineProperty(exports, "STArray", { enumerable: true, get: function() {
      return st_array_1.STArray;
    } });
    var st_object_1 = require_st_object();
    Object.defineProperty(exports, "STObject", { enumerable: true, get: function() {
      return st_object_1.STObject;
    } });
    var uint_16_1 = require_uint_16();
    Object.defineProperty(exports, "UInt16", { enumerable: true, get: function() {
      return uint_16_1.UInt16;
    } });
    var uint_32_1 = require_uint_32();
    Object.defineProperty(exports, "UInt32", { enumerable: true, get: function() {
      return uint_32_1.UInt32;
    } });
    var uint_64_1 = require_uint_64();
    Object.defineProperty(exports, "UInt64", { enumerable: true, get: function() {
      return uint_64_1.UInt64;
    } });
    var uint_8_1 = require_uint_8();
    Object.defineProperty(exports, "UInt8", { enumerable: true, get: function() {
      return uint_8_1.UInt8;
    } });
    var vector_256_1 = require_vector_256();
    Object.defineProperty(exports, "Vector256", { enumerable: true, get: function() {
      return vector_256_1.Vector256;
    } });
    var xchain_bridge_1 = require_xchain_bridge();
    var enums_1 = require_enums();
    var coreTypes = {
      AccountID: account_id_1.AccountID,
      Amount: amount_1.Amount,
      Blob: blob_1.Blob,
      Currency: currency_1.Currency,
      Hash128: hash_128_1.Hash128,
      Hash160: hash_160_1.Hash160,
      Hash256: hash_256_1.Hash256,
      Issue: issue_1.Issue,
      PathSet: path_set_1.PathSet,
      STArray: st_array_1.STArray,
      STObject: st_object_1.STObject,
      UInt8: uint_8_1.UInt8,
      UInt16: uint_16_1.UInt16,
      UInt32: uint_32_1.UInt32,
      UInt64: uint_64_1.UInt64,
      Vector256: vector_256_1.Vector256,
      XChainBridge: xchain_bridge_1.XChainBridge
    };
    exports.coreTypes = coreTypes;
    enums_1.DEFAULT_DEFINITIONS.associateTypes(coreTypes);
  }
});

// node_modules/ripple-binary-codec/dist/hash-prefixes.js
var require_hash_prefixes = __commonJS({
  "node_modules/ripple-binary-codec/dist/hash-prefixes.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashPrefix = void 0;
    var buffer_1 = require_dist();
    function bytes(uint32) {
      const result = buffer_1.Buffer.alloc(4);
      result.writeUInt32BE(uint32, 0);
      return result;
    }
    var HashPrefix = {
      transactionID: bytes(1415073280),
      // transaction plus metadata
      transaction: bytes(1397638144),
      // account state
      accountStateEntry: bytes(1296846336),
      // inner node in tree
      innerNode: bytes(1296649728),
      // ledger master data for signing
      ledgerHeader: bytes(1280791040),
      // inner transaction to sign
      transactionSig: bytes(1398036480),
      // inner transaction to sign
      transactionMultiSig: bytes(1397576704),
      // validation for signing
      validation: bytes(1447119872),
      // proposal for signing
      proposal: bytes(1347571712),
      // payment channel claim
      paymentChannelClaim: bytes(1129073920)
    };
    exports.HashPrefix = HashPrefix;
  }
});

// node_modules/ripple-binary-codec/dist/hashes.js
var require_hashes = __commonJS({
  "node_modules/ripple-binary-codec/dist/hashes.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;
    var hash_prefixes_1 = require_hash_prefixes();
    var createHash = require_browser();
    var hash_256_1 = require_hash_256();
    var binary_serializer_1 = require_binary_serializer();
    var buffer_1 = require_dist();
    var Sha512Half = class _Sha512Half extends binary_serializer_1.BytesList {
      constructor() {
        super(...arguments);
        this.hash = createHash("sha512");
      }
      /**
       * Construct a new Sha512Hash and write bytes this.hash
       *
       * @param bytes bytes to write to this.hash
       * @returns the new Sha512Hash object
       */
      static put(bytes) {
        return new _Sha512Half().put(bytes);
      }
      /**
       * Write bytes to an existing Sha512Hash
       *
       * @param bytes bytes to write to object
       * @returns the Sha512 object
       */
      put(bytes) {
        this.hash.update(bytes);
        return this;
      }
      /**
       * Compute SHA512 hash and slice in half
       *
       * @returns half of a SHA512 hash
       */
      finish256() {
        return buffer_1.Buffer.from(this.hash.digest().slice(0, 32));
      }
      /**
       * Constructs a Hash256 from the Sha512Half object
       *
       * @returns a Hash256 object
       */
      finish() {
        return new hash_256_1.Hash256(this.finish256());
      }
    };
    exports.Sha512Half = Sha512Half;
    function sha512Half(...args) {
      const hash = new Sha512Half();
      args.forEach((a) => hash.put(a));
      return hash.finish256();
    }
    exports.sha512Half = sha512Half;
    function transactionID(serialized) {
      return new hash_256_1.Hash256(sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized));
    }
    exports.transactionID = transactionID;
  }
});

// node_modules/ripple-binary-codec/dist/binary.js
var require_binary = __commonJS({
  "node_modules/ripple-binary-codec/dist/binary.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;
    var types_1 = require_types();
    var binary_parser_1 = require_binary_parser();
    Object.defineProperty(exports, "BinaryParser", { enumerable: true, get: function() {
      return binary_parser_1.BinaryParser;
    } });
    var hash_prefixes_1 = require_hash_prefixes();
    var binary_serializer_1 = require_binary_serializer();
    Object.defineProperty(exports, "BinarySerializer", { enumerable: true, get: function() {
      return binary_serializer_1.BinarySerializer;
    } });
    Object.defineProperty(exports, "BytesList", { enumerable: true, get: function() {
      return binary_serializer_1.BytesList;
    } });
    var hashes_1 = require_hashes();
    Object.defineProperty(exports, "sha512Half", { enumerable: true, get: function() {
      return hashes_1.sha512Half;
    } });
    Object.defineProperty(exports, "transactionID", { enumerable: true, get: function() {
      return hashes_1.transactionID;
    } });
    var enums_1 = require_enums();
    var bigInt = require_BigInteger();
    var makeParser = (bytes, definitions) => new binary_parser_1.BinaryParser(bytes, definitions);
    exports.makeParser = makeParser;
    var readJSON = (parser, definitions = enums_1.DEFAULT_DEFINITIONS) => parser.readType(types_1.coreTypes.STObject).toJSON(definitions);
    exports.readJSON = readJSON;
    var binaryToJSON = (bytes, definitions) => readJSON(makeParser(bytes, definitions), definitions);
    exports.binaryToJSON = binaryToJSON;
    function serializeObject(object, opts = {}) {
      const { prefix, suffix, signingFieldsOnly = false, definitions } = opts;
      const bytesList = new binary_serializer_1.BytesList();
      if (prefix) {
        bytesList.put(prefix);
      }
      const filter2 = signingFieldsOnly ? (f) => f.isSigningField : void 0;
      types_1.coreTypes.STObject.from(object, filter2, definitions).toBytesSink(bytesList);
      if (suffix) {
        bytesList.put(suffix);
      }
      return bytesList.toBytes();
    }
    exports.serializeObject = serializeObject;
    function signingData(transaction, prefix = hash_prefixes_1.HashPrefix.transactionSig, opts = {}) {
      return serializeObject(transaction, {
        prefix,
        signingFieldsOnly: true,
        definitions: opts.definitions
      });
    }
    exports.signingData = signingData;
    function signingClaimData(claim) {
      const num = bigInt(String(claim.amount));
      const prefix = hash_prefixes_1.HashPrefix.paymentChannelClaim;
      const channel = types_1.coreTypes.Hash256.from(claim.channel).toBytes();
      const amount = types_1.coreTypes.UInt64.from(num).toBytes();
      const bytesList = new binary_serializer_1.BytesList();
      bytesList.put(prefix);
      bytesList.put(channel);
      bytesList.put(amount);
      return bytesList.toBytes();
    }
    exports.signingClaimData = signingClaimData;
    function multiSigningData(transaction, signingAccount, opts = {
      definitions: enums_1.DEFAULT_DEFINITIONS
    }) {
      const prefix = hash_prefixes_1.HashPrefix.transactionMultiSig;
      const suffix = types_1.coreTypes.AccountID.from(signingAccount).toBytes();
      return serializeObject(transaction, {
        prefix,
        suffix,
        signingFieldsOnly: true,
        definitions: opts.definitions
      });
    }
    exports.multiSigningData = multiSigningData;
  }
});

// node_modules/ripple-binary-codec/dist/shamap.js
var require_shamap = __commonJS({
  "node_modules/ripple-binary-codec/dist/shamap.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;
    var assert_1 = require_assert();
    var types_1 = require_types();
    var hash_prefixes_1 = require_hash_prefixes();
    var hashes_1 = require_hashes();
    var buffer_1 = require_dist();
    var ShaMapNode = class {
    };
    exports.ShaMapNode = ShaMapNode;
    var ShaMapLeaf = class extends ShaMapNode {
      constructor(index, item) {
        super();
        this.index = index;
        this.item = item;
      }
      /**
       * @returns true as ShaMapLeaf is a leaf node
       */
      isLeaf() {
        return true;
      }
      /**
       * @returns false as ShaMapLeaf is not an inner node
       */
      isInner() {
        return false;
      }
      /**
       * Get the prefix of the this.item
       *
       * @returns The hash prefix, unless this.item is undefined, then it returns an empty Buffer
       */
      hashPrefix() {
        return this.item === void 0 ? buffer_1.Buffer.alloc(0) : this.item.hashPrefix();
      }
      /**
       * Hash the bytes representation of this
       *
       * @returns hash of this.item concatenated with this.index
       */
      hash() {
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
      }
      /**
       * Write the bytes representation of this to a BytesList
       * @param list BytesList to write bytes to
       */
      toBytesSink(list) {
        if (this.item !== void 0) {
          this.item.toBytesSink(list);
        }
        this.index.toBytesSink(list);
      }
    };
    exports.ShaMapLeaf = ShaMapLeaf;
    var ShaMapInner = class _ShaMapInner extends ShaMapNode {
      constructor(depth = 0) {
        super();
        this.depth = depth;
        this.slotBits = 0;
        this.branches = Array(16);
      }
      /**
       * @returns true as ShaMapInner is an inner node
       */
      isInner() {
        return true;
      }
      /**
       * @returns false as ShaMapInner is not a leaf node
       */
      isLeaf() {
        return false;
      }
      /**
       * Get the hash prefix for this node
       *
       * @returns hash prefix describing an inner node
       */
      hashPrefix() {
        return hash_prefixes_1.HashPrefix.innerNode;
      }
      /**
       * Set a branch of this node to be another node
       *
       * @param slot Slot to add branch to this.branches
       * @param branch Branch to add
       */
      setBranch(slot, branch) {
        this.slotBits = this.slotBits | 1 << slot;
        this.branches[slot] = branch;
      }
      /**
       * @returns true if node is empty
       */
      empty() {
        return this.slotBits === 0;
      }
      /**
       * Compute the hash of this node
       *
       * @returns The hash of this node
       */
      hash() {
        if (this.empty()) {
          return types_1.coreTypes.Hash256.ZERO_256;
        }
        const hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
      }
      /**
       * Writes the bytes representation of this node to a BytesList
       *
       * @param list BytesList to write bytes to
       */
      toBytesSink(list) {
        for (let i = 0; i < this.branches.length; i++) {
          const branch = this.branches[i];
          const hash = branch ? branch.hash() : types_1.coreTypes.Hash256.ZERO_256;
          hash.toBytesSink(list);
        }
      }
      /**
       * Add item to the SHAMap
       *
       * @param index Hash of the index of the item being inserted
       * @param item Item to insert in the map
       * @param leaf Leaf node to insert when branch doesn't exist
       */
      addItem(index, item, leaf) {
        assert_1.strict.ok(index !== void 0);
        if (index !== void 0) {
          const nibble = index.nibblet(this.depth);
          const existing = this.branches[nibble];
          if (existing === void 0) {
            this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));
          } else if (existing instanceof ShaMapLeaf) {
            const newInner = new _ShaMapInner(this.depth + 1);
            newInner.addItem(existing.index, void 0, existing);
            newInner.addItem(index, item, leaf);
            this.setBranch(nibble, newInner);
          } else if (existing instanceof _ShaMapInner) {
            existing.addItem(index, item, leaf);
          } else {
            throw new Error("invalid ShaMap.addItem call");
          }
        }
      }
    };
    var ShaMap = class extends ShaMapInner {
    };
    exports.ShaMap = ShaMap;
  }
});

// node_modules/ripple-binary-codec/dist/ledger-hashes.js
var require_ledger_hashes = __commonJS({
  "node_modules/ripple-binary-codec/dist/ledger-hashes.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeLedgerData = exports.ledgerHash = exports.transactionTreeHash = exports.accountStateHash = void 0;
    var assert = __importStar(require_assert());
    var shamap_1 = require_shamap();
    var hash_prefixes_1 = require_hash_prefixes();
    var hashes_1 = require_hashes();
    var binary_1 = require_binary();
    var hash_256_1 = require_hash_256();
    var st_object_1 = require_st_object();
    var uint_64_1 = require_uint_64();
    var uint_32_1 = require_uint_32();
    var uint_8_1 = require_uint_8();
    var binary_parser_1 = require_binary_parser();
    var bigInt = require_BigInteger();
    function computeHash(itemizer, itemsJson) {
      const map = new shamap_1.ShaMap();
      itemsJson.forEach((item) => map.addItem(...itemizer(item)));
      return map.hash();
    }
    function transactionItemizer(json) {
      assert.ok(json.hash);
      const index = hash_256_1.Hash256.from(json.hash);
      const item = {
        hashPrefix() {
          return hash_prefixes_1.HashPrefix.transaction;
        },
        toBytesSink(sink) {
          const serializer = new binary_1.BinarySerializer(sink);
          serializer.writeLengthEncoded(st_object_1.STObject.from(json));
          serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));
        }
      };
      return [index, item, void 0];
    }
    function entryItemizer(json) {
      const index = hash_256_1.Hash256.from(json.index);
      const bytes = (0, binary_1.serializeObject)(json);
      const item = {
        hashPrefix() {
          return hash_prefixes_1.HashPrefix.accountStateEntry;
        },
        toBytesSink(sink) {
          sink.put(bytes);
        }
      };
      return [index, item, void 0];
    }
    function transactionTreeHash(param) {
      const itemizer = transactionItemizer;
      return computeHash(itemizer, param);
    }
    exports.transactionTreeHash = transactionTreeHash;
    function accountStateHash(param) {
      const itemizer = entryItemizer;
      return computeHash(itemizer, param);
    }
    exports.accountStateHash = accountStateHash;
    function ledgerHash(header) {
      const hash = new hashes_1.Sha512Half();
      hash.put(hash_prefixes_1.HashPrefix.ledgerHeader);
      assert.ok(header.parent_close_time !== void 0);
      assert.ok(header.close_flags !== void 0);
      uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash);
      uint_64_1.UInt64.from(bigInt(String(header.total_coins))).toBytesSink(hash);
      hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash);
      hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash);
      hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash);
      uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash);
      uint_32_1.UInt32.from(header.close_time).toBytesSink(hash);
      uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash);
      uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash);
      return hash.finish();
    }
    exports.ledgerHash = ledgerHash;
    function decodeLedgerData(binary, definitions) {
      assert.ok(typeof binary === "string", "binary must be a hex string");
      const parser = new binary_parser_1.BinaryParser(binary, definitions);
      return {
        ledger_index: parser.readUInt32(),
        total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),
        parent_hash: parser.readType(hash_256_1.Hash256).toHex(),
        transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),
        account_hash: parser.readType(hash_256_1.Hash256).toHex(),
        parent_close_time: parser.readUInt32(),
        close_time: parser.readUInt32(),
        close_time_resolution: parser.readUInt8(),
        close_flags: parser.readUInt8()
      };
    }
    exports.decodeLedgerData = decodeLedgerData;
  }
});

// node_modules/ripple-binary-codec/dist/quality.js
var require_quality3 = __commonJS({
  "node_modules/ripple-binary-codec/dist/quality.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.quality = void 0;
    var types_1 = require_types();
    var decimal_js_1 = require_decimal();
    var bigInt = require_BigInteger();
    var buffer_1 = require_dist();
    var quality = class {
      /**
       * Encode quality amount
       *
       * @param arg string representation of an amount
       * @returns Serialized quality
       */
      static encode(quality2) {
        const decimal = new decimal_js_1.Decimal(quality2);
        const exponent = decimal.e - 15;
        const qualityString = decimal.times(`1e${-exponent}`).abs().toString();
        const bytes = types_1.coreTypes.UInt64.from(bigInt(qualityString)).toBytes();
        bytes[0] = exponent + 100;
        return bytes;
      }
      /**
       * Decode quality amount
       *
       * @param arg hex-string denoting serialized quality
       * @returns deserialized quality
       */
      static decode(quality2) {
        const bytes = buffer_1.Buffer.from(quality2, "hex").slice(-8);
        const exponent = bytes[0] - 100;
        const mantissa = new decimal_js_1.Decimal(`0x${bytes.slice(1).toString("hex")}`);
        return mantissa.times(`1e${exponent}`);
      }
    };
    exports.quality = quality;
  }
});

// node_modules/ripple-binary-codec/dist/coretypes.js
var require_coretypes = __commonJS({
  "node_modules/ripple-binary-codec/dist/coretypes.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.types = exports.ShaMap = exports.HashPrefix = exports.quality = exports.TransactionResult = exports.Type = exports.LedgerEntryType = exports.TransactionType = exports.Field = exports.DEFAULT_DEFINITIONS = exports.ledgerHashes = exports.binary = exports.hashes = void 0;
    var enums_1 = require_enums();
    Object.defineProperty(exports, "DEFAULT_DEFINITIONS", { enumerable: true, get: function() {
      return enums_1.DEFAULT_DEFINITIONS;
    } });
    Object.defineProperty(exports, "Field", { enumerable: true, get: function() {
      return enums_1.Field;
    } });
    Object.defineProperty(exports, "TransactionType", { enumerable: true, get: function() {
      return enums_1.TransactionType;
    } });
    Object.defineProperty(exports, "LedgerEntryType", { enumerable: true, get: function() {
      return enums_1.LedgerEntryType;
    } });
    Object.defineProperty(exports, "Type", { enumerable: true, get: function() {
      return enums_1.Type;
    } });
    Object.defineProperty(exports, "TransactionResult", { enumerable: true, get: function() {
      return enums_1.TransactionResult;
    } });
    var types = __importStar(require_types());
    exports.types = types;
    var binary = __importStar(require_binary());
    exports.binary = binary;
    var shamap_1 = require_shamap();
    Object.defineProperty(exports, "ShaMap", { enumerable: true, get: function() {
      return shamap_1.ShaMap;
    } });
    var ledgerHashes = __importStar(require_ledger_hashes());
    exports.ledgerHashes = ledgerHashes;
    var hashes = __importStar(require_hashes());
    exports.hashes = hashes;
    var quality_1 = require_quality3();
    Object.defineProperty(exports, "quality", { enumerable: true, get: function() {
      return quality_1.quality;
    } });
    var hash_prefixes_1 = require_hash_prefixes();
    Object.defineProperty(exports, "HashPrefix", { enumerable: true, get: function() {
      return hash_prefixes_1.HashPrefix;
    } });
  }
});

// node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js
var require_xrpl_definitions = __commonJS({
  "node_modules/ripple-binary-codec/dist/enums/xrpl-definitions.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XrplDefinitions = void 0;
    var xrpl_definitions_base_1 = require_xrpl_definitions_base();
    var types_1 = require_types();
    var XrplDefinitions = class extends xrpl_definitions_base_1.XrplDefinitionsBase {
      /**
       * Present rippled types in a typed and updatable format.
       * For an example of the input format see `definitions.json`
       * To generate a new definitions file from rippled source code, use this tool: https://github.com/RichardAH/xrpl-codec-gen
       *
       * See the definitions.test.js file for examples of how to create your own updated definitions.json.
       *
       * @param enums - A json encoding of the core types, transaction types, transaction results, transaction names, and fields.
       * @param additionalTypes - A list of SerializedType objects with the same name as the fields defined.
       *              These types will be included in addition to the coreTypes used on mainnet.
       */
      constructor(enums, additionalTypes) {
        const types = Object.assign({}, types_1.coreTypes, additionalTypes);
        super(enums, types);
      }
    };
    exports.XrplDefinitions = XrplDefinitions;
  }
});

// node_modules/ripple-binary-codec/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/ripple-binary-codec/dist/index.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.coreTypes = exports.DEFAULT_DEFINITIONS = exports.XrplDefinitionsBase = exports.XrplDefinitions = exports.TRANSACTION_TYPES = exports.decodeLedgerData = exports.decodeQuality = exports.encodeQuality = exports.encodeForMultisigning = exports.encodeForSigningClaim = exports.encodeForSigning = exports.encode = exports.decode = void 0;
    var assert = __importStar(require_assert());
    var coretypes_1 = require_coretypes();
    var ledger_hashes_1 = require_ledger_hashes();
    Object.defineProperty(exports, "decodeLedgerData", { enumerable: true, get: function() {
      return ledger_hashes_1.decodeLedgerData;
    } });
    var enums_1 = require_enums();
    Object.defineProperty(exports, "XrplDefinitionsBase", { enumerable: true, get: function() {
      return enums_1.XrplDefinitionsBase;
    } });
    Object.defineProperty(exports, "TRANSACTION_TYPES", { enumerable: true, get: function() {
      return enums_1.TRANSACTION_TYPES;
    } });
    Object.defineProperty(exports, "DEFAULT_DEFINITIONS", { enumerable: true, get: function() {
      return enums_1.DEFAULT_DEFINITIONS;
    } });
    var xrpl_definitions_1 = require_xrpl_definitions();
    Object.defineProperty(exports, "XrplDefinitions", { enumerable: true, get: function() {
      return xrpl_definitions_1.XrplDefinitions;
    } });
    var types_1 = require_types();
    Object.defineProperty(exports, "coreTypes", { enumerable: true, get: function() {
      return types_1.coreTypes;
    } });
    var { signingData, signingClaimData, multiSigningData, binaryToJSON, serializeObject } = coretypes_1.binary;
    function decode(binary, definitions) {
      assert.ok(typeof binary === "string", "binary must be a hex string");
      return binaryToJSON(binary, definitions);
    }
    exports.decode = decode;
    function encode(json, definitions) {
      assert.ok(typeof json === "object");
      return serializeObject(json, { definitions }).toString("hex").toUpperCase();
    }
    exports.encode = encode;
    function encodeForSigning(json, definitions) {
      assert.ok(typeof json === "object");
      return signingData(json, coretypes_1.HashPrefix.transactionSig, {
        definitions
      }).toString("hex").toUpperCase();
    }
    exports.encodeForSigning = encodeForSigning;
    function encodeForSigningClaim(json) {
      assert.ok(typeof json === "object");
      return signingClaimData(json).toString("hex").toUpperCase();
    }
    exports.encodeForSigningClaim = encodeForSigningClaim;
    function encodeForMultisigning(json, signer, definitions) {
      assert.ok(typeof json === "object");
      assert.equal(json["SigningPubKey"], "");
      const definitionsOpt = definitions ? { definitions } : void 0;
      return multiSigningData(json, signer, definitionsOpt).toString("hex").toUpperCase();
    }
    exports.encodeForMultisigning = encodeForMultisigning;
    function encodeQuality(value) {
      assert.ok(typeof value === "string");
      return coretypes_1.quality.encode(value).toString("hex").toUpperCase();
    }
    exports.encodeQuality = encodeQuality;
    function decodeQuality(value) {
      assert.ok(typeof value === "string");
      return coretypes_1.quality.decode(value).toString();
    }
    exports.decodeQuality = decodeQuality;
  }
});

// node_modules/ripple-lib/dist/npm/common/hashes/sha512Half.js
var require_sha512Half = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/hashes/sha512Half.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var crypto_1 = require_crypto_browserify();
    var sha512Half = (hex) => {
      return crypto_1.createHash("sha512").update(Buffer.from(hex, "hex")).digest("hex").toUpperCase().slice(0, 64);
    };
    exports.default = sha512Half;
  }
});

// node_modules/ripple-lib/dist/npm/common/hashes/hash-prefix.js
var require_hash_prefix = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/hashes/hash-prefix.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var HashPrefix;
    (function(HashPrefix2) {
      HashPrefix2[HashPrefix2["TRANSACTION_ID"] = 1415073280] = "TRANSACTION_ID";
      HashPrefix2[HashPrefix2["TRANSACTION_NODE"] = 1397638144] = "TRANSACTION_NODE";
      HashPrefix2[HashPrefix2["INNER_NODE"] = 1296649728] = "INNER_NODE";
      HashPrefix2[HashPrefix2["LEAF_NODE"] = 1296846336] = "LEAF_NODE";
      HashPrefix2[HashPrefix2["TRANSACTION_SIGN"] = 1398036480] = "TRANSACTION_SIGN";
      HashPrefix2[HashPrefix2["TRANSACTION_SIGN_TESTNET"] = 1937012736] = "TRANSACTION_SIGN_TESTNET";
      HashPrefix2[HashPrefix2["TRANSACTION_MULTISIGN"] = 1397576704] = "TRANSACTION_MULTISIGN";
      HashPrefix2[HashPrefix2["LEDGER"] = 1280791040] = "LEDGER";
    })(HashPrefix || (HashPrefix = {}));
    exports.default = HashPrefix;
  }
});

// node_modules/ripple-lib/dist/npm/common/hashes/shamap.js
var require_shamap2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/hashes/shamap.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHAMap = exports.Leaf = exports.InnerNode = exports.Node = exports.NodeType = void 0;
    var hash_prefix_1 = __importDefault(require_hash_prefix());
    var sha512Half_1 = __importDefault(require_sha512Half());
    var HEX_ZERO = "0000000000000000000000000000000000000000000000000000000000000000";
    var NodeType;
    (function(NodeType2) {
      NodeType2[NodeType2["INNER"] = 1] = "INNER";
      NodeType2[NodeType2["TRANSACTION_NO_METADATA"] = 2] = "TRANSACTION_NO_METADATA";
      NodeType2[NodeType2["TRANSACTION_METADATA"] = 3] = "TRANSACTION_METADATA";
      NodeType2[NodeType2["ACCOUNT_STATE"] = 4] = "ACCOUNT_STATE";
    })(NodeType = exports.NodeType || (exports.NodeType = {}));
    var Node = class {
      constructor() {
      }
      addItem(_tag, _node) {
        throw new Error("Called unimplemented virtual method SHAMapTreeNode#addItem.");
      }
      get hash() {
        throw new Error("Called unimplemented virtual method SHAMapTreeNode#hash.");
      }
    };
    exports.Node = Node;
    var InnerNode = class _InnerNode extends Node {
      constructor(depth = 0) {
        super();
        this.leaves = {};
        this.type = NodeType.INNER;
        this.depth = depth;
        this.empty = true;
      }
      addItem(tag, node) {
        const existingNode = this.getNode(parseInt(tag[this.depth], 16));
        if (existingNode) {
          if (existingNode instanceof _InnerNode) {
            existingNode.addItem(tag, node);
          } else if (existingNode instanceof Leaf) {
            if (existingNode.tag === tag) {
              throw new Error("Tried to add a node to a SHAMap that was already in there.");
            } else {
              const newInnerNode = new _InnerNode(this.depth + 1);
              newInnerNode.addItem(existingNode.tag, existingNode);
              newInnerNode.addItem(tag, node);
              this.setNode(parseInt(tag[this.depth], 16), newInnerNode);
            }
          }
        } else {
          this.setNode(parseInt(tag[this.depth], 16), node);
        }
      }
      setNode(slot, node) {
        if (slot < 0 || slot > 15) {
          throw new Error("Invalid slot: slot must be between 0-15.");
        }
        this.leaves[slot] = node;
        this.empty = false;
      }
      getNode(slot) {
        if (slot < 0 || slot > 15) {
          throw new Error("Invalid slot: slot must be between 0-15.");
        }
        return this.leaves[slot];
      }
      get hash() {
        if (this.empty)
          return HEX_ZERO;
        let hex = "";
        for (let i = 0; i < 16; i++) {
          hex += this.leaves[i] ? this.leaves[i].hash : HEX_ZERO;
        }
        const prefix = hash_prefix_1.default.INNER_NODE.toString(16);
        return sha512Half_1.default(prefix + hex);
      }
    };
    exports.InnerNode = InnerNode;
    var Leaf = class extends Node {
      constructor(tag, data, type) {
        super();
        this.tag = tag;
        this.type = type;
        this.data = data;
      }
      get hash() {
        switch (this.type) {
          case NodeType.ACCOUNT_STATE: {
            const leafPrefix = hash_prefix_1.default.LEAF_NODE.toString(16);
            return sha512Half_1.default(leafPrefix + this.data + this.tag);
          }
          case NodeType.TRANSACTION_NO_METADATA: {
            const txIDPrefix = hash_prefix_1.default.TRANSACTION_ID.toString(16);
            return sha512Half_1.default(txIDPrefix + this.data);
          }
          case NodeType.TRANSACTION_METADATA: {
            const txNodePrefix = hash_prefix_1.default.TRANSACTION_NODE.toString(16);
            return sha512Half_1.default(txNodePrefix + this.data + this.tag);
          }
          default:
            throw new Error("Tried to hash a SHAMap node of unknown type.");
        }
      }
    };
    exports.Leaf = Leaf;
    var SHAMap = class {
      constructor() {
        this.root = new InnerNode(0);
      }
      addItem(tag, data, type) {
        this.root.addItem(tag, new Leaf(tag, data, type));
      }
      get hash() {
        return this.root.hash;
      }
    };
    exports.SHAMap = SHAMap;
  }
});

// node_modules/ripple-lib/dist/npm/common/hashes/ledgerspaces.js
var require_ledgerspaces = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/hashes/ledgerspaces.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = {
      account: "a",
      dirNode: "d",
      generatorMap: "g",
      rippleState: "r",
      offer: "o",
      ownerDir: "O",
      bookDir: "B",
      contract: "c",
      skipList: "s",
      escrow: "u",
      amendment: "f",
      feeSettings: "e",
      ticket: "T",
      signerList: "S",
      paychan: "x",
      check: "C",
      depositPreauth: "p"
    };
  }
});

// node_modules/ripple-lib/dist/npm/common/hashes/index.js
var require_hashes2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/hashes/index.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computePaymentChannelHash = exports.computeEscrowHash = exports.computeLedgerHash = exports.computeStateTreeHash = exports.computeTransactionTreeHash = exports.computeTrustlineHash = exports.computeOrderID = exports.computeSignerListLedgerObjectID = exports.computeAccountLedgerObjectID = exports.computeBinaryTransactionSigningHash = exports.computeTransactionHash = exports.computeBinaryTransactionHash = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var ripple_address_codec_1 = require_dist4();
    var sha512Half_1 = __importDefault(require_sha512Half());
    var hash_prefix_1 = __importDefault(require_hash_prefix());
    var shamap_1 = require_shamap2();
    var ripple_binary_codec_1 = require_dist6();
    var ledgerspaces_1 = __importDefault(require_ledgerspaces());
    var padLeftZero = (string, length) => {
      return Array(length - string.length + 1).join("0") + string;
    };
    var intToHex = (integer, byteLength) => {
      return padLeftZero(Number(integer).toString(16), byteLength * 2);
    };
    var bytesToHex = (bytes) => {
      return Buffer.from(bytes).toString("hex");
    };
    var bigintToHex = (integerString, byteLength) => {
      const hex = new bignumber_js_1.default(integerString).toString(16);
      return padLeftZero(hex, byteLength * 2);
    };
    var ledgerSpaceHex = (name) => {
      return intToHex(ledgerspaces_1.default[name].charCodeAt(0), 2);
    };
    var addressToHex = (address) => {
      return Buffer.from(ripple_address_codec_1.decodeAccountID(address)).toString("hex");
    };
    var currencyToHex = (currency) => {
      if (currency.length === 3) {
        const bytes = new Array(20 + 1).join("0").split("").map(parseFloat);
        bytes[12] = currency.charCodeAt(0) & 255;
        bytes[13] = currency.charCodeAt(1) & 255;
        bytes[14] = currency.charCodeAt(2) & 255;
        return bytesToHex(bytes);
      }
      return currency;
    };
    var addLengthPrefix = (hex) => {
      const length = hex.length / 2;
      if (length <= 192) {
        return bytesToHex([length]) + hex;
      } else if (length <= 12480) {
        const x = length - 193;
        return bytesToHex([193 + (x >>> 8), x & 255]) + hex;
      } else if (length <= 918744) {
        const x = length - 12481;
        return bytesToHex([241 + (x >>> 16), x >>> 8 & 255, x & 255]) + hex;
      }
      throw new Error("Variable integer overflow.");
    };
    exports.computeBinaryTransactionHash = (txBlobHex) => {
      const prefix = hash_prefix_1.default.TRANSACTION_ID.toString(16).toUpperCase();
      return sha512Half_1.default(prefix + txBlobHex);
    };
    exports.computeTransactionHash = (txJSON) => {
      return exports.computeBinaryTransactionHash(ripple_binary_codec_1.encode(txJSON));
    };
    exports.computeBinaryTransactionSigningHash = (txBlobHex) => {
      const prefix = hash_prefix_1.default.TRANSACTION_SIGN.toString(16).toUpperCase();
      return sha512Half_1.default(prefix + txBlobHex);
    };
    exports.computeAccountLedgerObjectID = (address) => {
      return sha512Half_1.default(ledgerSpaceHex("account") + addressToHex(address));
    };
    exports.computeSignerListLedgerObjectID = (address) => {
      return sha512Half_1.default(ledgerSpaceHex("signerList") + addressToHex(address) + "00000000");
    };
    exports.computeOrderID = (address, sequence) => {
      const prefix = "00" + intToHex(ledgerspaces_1.default.offer.charCodeAt(0), 1);
      return sha512Half_1.default(prefix + addressToHex(address) + intToHex(sequence, 4));
    };
    exports.computeTrustlineHash = (address1, address2, currency) => {
      const address1Hex = addressToHex(address1);
      const address2Hex = addressToHex(address2);
      const swap = new bignumber_js_1.default(address1Hex, 16).isGreaterThan(new bignumber_js_1.default(address2Hex, 16));
      const lowAddressHex = swap ? address2Hex : address1Hex;
      const highAddressHex = swap ? address1Hex : address2Hex;
      const prefix = ledgerSpaceHex("rippleState");
      return sha512Half_1.default(prefix + lowAddressHex + highAddressHex + currencyToHex(currency));
    };
    exports.computeTransactionTreeHash = (transactions) => {
      const shamap = new shamap_1.SHAMap();
      transactions.forEach((txJSON) => {
        const txBlobHex = ripple_binary_codec_1.encode(txJSON);
        const metaHex = ripple_binary_codec_1.encode(txJSON.metaData);
        const txHash = exports.computeBinaryTransactionHash(txBlobHex);
        const data = addLengthPrefix(txBlobHex) + addLengthPrefix(metaHex);
        shamap.addItem(txHash, data, shamap_1.NodeType.TRANSACTION_METADATA);
      });
      return shamap.hash;
    };
    exports.computeStateTreeHash = (entries) => {
      const shamap = new shamap_1.SHAMap();
      entries.forEach((ledgerEntry) => {
        const data = ripple_binary_codec_1.encode(ledgerEntry);
        shamap.addItem(ledgerEntry.index, data, shamap_1.NodeType.ACCOUNT_STATE);
      });
      return shamap.hash;
    };
    exports.computeLedgerHash = (ledgerHeader) => {
      const prefix = hash_prefix_1.default.LEDGER.toString(16).toUpperCase();
      return sha512Half_1.default(prefix + intToHex(ledgerHeader.ledger_index, 4) + bigintToHex(ledgerHeader.total_coins, 8) + ledgerHeader.parent_hash + ledgerHeader.transaction_hash + ledgerHeader.account_hash + intToHex(ledgerHeader.parent_close_time, 4) + intToHex(ledgerHeader.close_time, 4) + intToHex(ledgerHeader.close_time_resolution, 1) + intToHex(ledgerHeader.close_flags, 1));
    };
    exports.computeEscrowHash = (address, sequence) => {
      return sha512Half_1.default(ledgerSpaceHex("escrow") + addressToHex(address) + intToHex(sequence, 4));
    };
    exports.computePaymentChannelHash = (address, dstAddress, sequence) => {
      return sha512Half_1.default(ledgerSpaceHex("paychan") + addressToHex(address) + addressToHex(dstAddress) + intToHex(sequence, 4));
    };
  }
});

// node_modules/ripple-lib/dist/npm/ledger/transactions.js
var require_transactions = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/transactions.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var ripple_binary_codec_1 = __importDefault(require_dist6());
    var hashes_1 = require_hashes2();
    var utils = __importStar(require_utils5());
    var transaction_1 = __importDefault(require_transaction());
    var transaction_2 = __importDefault(require_transaction2());
    var common_1 = require_common();
    function parseBinaryTransaction(transaction) {
      const tx = ripple_binary_codec_1.default.decode(transaction.tx_blob);
      tx.hash = hashes_1.computeTransactionHash(tx);
      tx.ledger_index = transaction.ledger_index;
      return {
        tx,
        meta: ripple_binary_codec_1.default.decode(transaction.meta),
        validated: transaction.validated
      };
    }
    function parseAccountTxTransaction(tx, includeRawTransaction) {
      const _tx = tx.tx_blob ? parseBinaryTransaction(tx) : tx;
      return transaction_1.default(Object.assign({}, _tx.tx, { meta: _tx.meta, validated: _tx.validated }), includeRawTransaction);
    }
    function counterpartyFilter(filters, tx) {
      if (tx.address === filters.counterparty) {
        return true;
      }
      const specification = tx.specification;
      if (specification && (specification.destination && specification.destination.address === filters.counterparty || specification.counterparty === filters.counterparty)) {
        return true;
      }
      return false;
    }
    function transactionFilter(address, filters, tx) {
      if (filters.excludeFailures && tx.outcome.result !== "tesSUCCESS") {
        return false;
      }
      if (filters.types && !filters.types.includes(tx.type)) {
        return false;
      }
      if (filters.initiated === true && tx.address !== address) {
        return false;
      }
      if (filters.initiated === false && tx.address === address) {
        return false;
      }
      if (filters.counterparty && !counterpartyFilter(filters, tx)) {
        return false;
      }
      return true;
    }
    function orderFilter(options, tx) {
      return !options.startTx || (options.earliestFirst ? utils.compareTransactions(tx, options.startTx) > 0 : utils.compareTransactions(tx, options.startTx) < 0);
    }
    function formatPartialResponse(address, options, data) {
      const parse2 = (tx) => parseAccountTxTransaction(tx, options.includeRawTransactions);
      return {
        marker: data.marker,
        results: data.transactions.filter((tx) => tx.validated).map(parse2).filter(_.partial(transactionFilter, address, options)).filter(_.partial(orderFilter, options))
      };
    }
    function getAccountTx(connection, address, options, marker, limit) {
      const request = {
        command: "account_tx",
        account: address,
        ledger_index_min: options.minLedgerVersion || -1,
        ledger_index_max: options.maxLedgerVersion || -1,
        forward: options.earliestFirst,
        binary: options.binary,
        limit: utils.clamp(limit, 10, 400),
        marker
      };
      return connection.request(request).then((response) => formatPartialResponse(address, options, response));
    }
    function checkForLedgerGaps(connection, options, transactions) {
      let { minLedgerVersion, maxLedgerVersion } = options;
      if (options.limit && transactions.length === options.limit) {
        if (options.earliestFirst) {
          maxLedgerVersion = transactions[transactions.length - 1].outcome.ledgerVersion;
        } else {
          minLedgerVersion = transactions[transactions.length - 1].outcome.ledgerVersion;
        }
      }
      return utils.hasCompleteLedgerRange(connection, minLedgerVersion, maxLedgerVersion).then((hasCompleteLedgerRange) => {
        if (!hasCompleteLedgerRange) {
          throw new common_1.errors.MissingLedgerHistoryError();
        }
      });
    }
    function formatResponse(connection, options, transactions) {
      const sortedTransactions = options.earliestFirst ? transactions.sort(utils.compareTransactions) : transactions.sort(utils.compareTransactions).reverse();
      return checkForLedgerGaps(connection, options, sortedTransactions).then(() => sortedTransactions);
    }
    function getTransactionsInternal(connection, address, options) {
      const getter = _.partial(getAccountTx, connection, address, options);
      const format2 = _.partial(formatResponse, connection, options);
      return utils.getRecursive(getter, options.limit).then(format2);
    }
    function getTransactions(address, options = {}) {
      common_1.validate.getTransactions({ address, options });
      address = common_1.ensureClassicAddress(address);
      const defaults = { maxLedgerVersion: -1 };
      if (options.start) {
        return transaction_2.default.call(this, options.start).then((tx) => {
          const ledgerVersion = tx.outcome.ledgerVersion;
          const bound = options.earliestFirst ? { minLedgerVersion: ledgerVersion } : { maxLedgerVersion: ledgerVersion };
          const startOptions = Object.assign({}, defaults, options, { startTx: tx }, bound);
          return getTransactionsInternal(this.connection, address, startOptions);
        });
      }
      const newOptions = Object.assign({}, defaults, options);
      return getTransactionsInternal(this.connection, address, newOptions);
    }
    exports.default = getTransactions;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/account-trustline.js
var require_account_trustline = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/account-trustline.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils7();
    var common_1 = require_common();
    function parseAccountTrustline(trustline) {
      const specification = common_1.removeUndefined({
        limit: trustline.limit,
        currency: trustline.currency,
        counterparty: trustline.account,
        qualityIn: utils_1.parseQuality(trustline.quality_in) || void 0,
        qualityOut: utils_1.parseQuality(trustline.quality_out) || void 0,
        ripplingDisabled: trustline.no_ripple,
        frozen: trustline.freeze,
        authorized: trustline.authorized
      });
      const counterparty = common_1.removeUndefined({
        limit: trustline.limit_peer,
        ripplingDisabled: trustline.no_ripple_peer,
        frozen: trustline.freeze_peer,
        authorized: trustline.peer_authorized
      });
      const state = {
        balance: trustline.balance
      };
      return { specification, counterparty, state };
    }
    exports.default = parseAccountTrustline;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/trustlines.js
var require_trustlines = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/trustlines.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var common_1 = require_common();
    var account_trustline_1 = __importDefault(require_account_trustline());
    function currencyFilter(currency, trustline) {
      return currency === null || trustline.specification.currency === currency;
    }
    function getTrustlines(address, options = {}) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getTrustlines({ address, options });
        address = common_1.ensureClassicAddress(address);
        const responses = yield this._requestAll("account_lines", {
          account: address,
          ledger_index: (_a = options.ledgerVersion) !== null && _a !== void 0 ? _a : yield this.getLedgerVersion(),
          limit: options.limit,
          peer: options.counterparty
        });
        const trustlines = _.flatMap(responses, (response) => response.lines);
        return trustlines.map(account_trustline_1.default).filter((trustline) => {
          return currencyFilter(options.currency || null, trustline);
        });
      });
    }
    exports.default = getTrustlines;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/balances.js
var require_balances = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/balances.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils5());
    var common_1 = require_common();
    function getTrustlineBalanceAmount(trustline) {
      return {
        currency: trustline.specification.currency,
        counterparty: trustline.specification.counterparty,
        value: trustline.state.balance
      };
    }
    function formatBalances(options, balances) {
      const result = balances.trustlines.map(getTrustlineBalanceAmount);
      if (!(options.counterparty || options.currency && options.currency !== "XRP")) {
        const xrpBalance = {
          currency: "XRP",
          value: balances.xrp
        };
        result.unshift(xrpBalance);
      }
      if (options.limit && result.length > options.limit) {
        const toRemove = result.length - options.limit;
        result.splice(-toRemove, toRemove);
      }
      return result;
    }
    function getLedgerVersionHelper(connection, optionValue) {
      if (optionValue != null && optionValue !== null) {
        return Promise.resolve(optionValue);
      }
      return connection.getLedgerVersion();
    }
    function getBalances(address, options = {}) {
      common_1.validate.getTrustlines({ address, options });
      address = common_1.ensureClassicAddress(address);
      return Promise.all([
        getLedgerVersionHelper(this.connection, options.ledgerVersion).then((ledgerVersion) => utils.getXRPBalance(this.connection, address, ledgerVersion)),
        this.getTrustlines(address, options)
      ]).then((results) => formatBalances(options, { xrp: results[0], trustlines: results[1] }));
    }
    exports.default = getBalances;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/balance-sheet.js
var require_balance_sheet = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/balance-sheet.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var common_1 = require_common();
    var utils_1 = require_utils5();
    function formatBalanceSheet(balanceSheet) {
      const result = {};
      if (balanceSheet.balances != null) {
        result.balances = [];
        Object.entries(balanceSheet.balances).forEach((entry) => {
          const [counterparty, balances] = entry;
          balances.forEach((balance) => {
            result.balances.push(Object.assign({ counterparty }, balance));
          });
        });
      }
      if (balanceSheet.assets != null) {
        result.assets = [];
        Object.entries(balanceSheet.assets).forEach(([counterparty, assets]) => {
          assets.forEach((balance) => {
            result.assets.push(Object.assign({ counterparty }, balance));
          });
        });
      }
      if (balanceSheet.obligations != null) {
        result.obligations = Object.entries(balanceSheet.obligations).map(([currency, value]) => ({ currency, value }));
      }
      return result;
    }
    function getBalanceSheet(address, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getBalanceSheet({ address, options });
        options = yield utils_1.ensureLedgerVersion.call(this, options);
        const response = yield this.request("gateway_balances", {
          account: address,
          strict: true,
          hotwallet: options.excludeAddresses,
          ledger_index: options.ledgerVersion
        });
        return formatBalanceSheet(response);
      });
    }
    exports.default = getBalanceSheet;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/pathfind.js
var require_pathfind = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/pathfind.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var amount_1 = __importDefault(require_amount2());
    function parsePaths(paths) {
      return paths.map((steps) => steps.map((step) => _.omit(step, ["type", "type_hex"])));
    }
    function removeAnyCounterpartyEncoding(address, amount) {
      return amount.counterparty === address ? _.omit(amount, "counterparty") : amount;
    }
    function createAdjustment(address, adjustmentWithoutAddress) {
      const amountKey = Object.keys(adjustmentWithoutAddress)[0];
      const amount = adjustmentWithoutAddress[amountKey];
      return _.set({ address }, amountKey, removeAnyCounterpartyEncoding(address, amount));
    }
    function parseAlternative(sourceAddress, destinationAddress, destinationAmount, alternative) {
      const amounts = alternative.destination_amount != null ? {
        source: { amount: amount_1.default(alternative.source_amount) },
        destination: { minAmount: amount_1.default(alternative.destination_amount) }
      } : {
        source: { maxAmount: amount_1.default(alternative.source_amount) },
        destination: { amount: amount_1.default(destinationAmount) }
      };
      return {
        source: createAdjustment(sourceAddress, amounts.source),
        destination: createAdjustment(destinationAddress, amounts.destination),
        paths: JSON.stringify(parsePaths(alternative.paths_computed))
      };
    }
    function parsePathfind(pathfindResult) {
      const sourceAddress = pathfindResult.source_account;
      const destinationAddress = pathfindResult.destination_account;
      const destinationAmount = pathfindResult.destination_amount;
      return pathfindResult.alternatives.map((alt) => parseAlternative(sourceAddress, destinationAddress, destinationAmount, alt));
    }
    exports.default = parsePathfind;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/pathfind.js
var require_pathfind2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/pathfind.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var bignumber_js_1 = __importDefault(require_bignumber());
    var utils_1 = require_utils5();
    var common_1 = require_common();
    var pathfind_1 = __importDefault(require_pathfind());
    var NotFoundError = common_1.errors.NotFoundError;
    var ValidationError = common_1.errors.ValidationError;
    function addParams(request, result) {
      return _.defaults(Object.assign({}, result, {
        source_account: request.source_account,
        source_currencies: request.source_currencies
      }), { destination_amount: request.destination_amount });
    }
    function requestPathFind(connection, pathfind) {
      const destinationAmount = Object.assign({
        value: pathfind.destination.amount.currency === "XRP" ? common_1.dropsToXrp("-1") : "-1"
      }, pathfind.destination.amount);
      const request = {
        command: "ripple_path_find",
        source_account: pathfind.source.address,
        destination_account: pathfind.destination.address,
        destination_amount: common_1.toRippledAmount(destinationAmount)
      };
      if (typeof request.destination_amount === "object" && !request.destination_amount.issuer) {
        request.destination_amount.issuer = request.destination_account;
      }
      if (pathfind.source.currencies && pathfind.source.currencies.length > 0) {
        request.source_currencies = pathfind.source.currencies.map((amount) => utils_1.renameCounterpartyToIssuer(amount));
      }
      if (pathfind.source.amount) {
        if (pathfind.destination.amount.value != null) {
          throw new ValidationError("Cannot specify both source.amount and destination.amount.value in getPaths");
        }
        request.send_max = common_1.toRippledAmount(pathfind.source.amount);
        if (typeof request.send_max !== "string" && !request.send_max.issuer) {
          request.send_max.issuer = pathfind.source.address;
        }
      }
      return connection.request(request).then((paths) => addParams(request, paths));
    }
    function addDirectXrpPath(paths, xrpBalance) {
      const destinationAmount = paths.destination_amount;
      if (new bignumber_js_1.default(xrpBalance).isGreaterThanOrEqualTo(destinationAmount)) {
        paths.alternatives.unshift({
          paths_computed: [],
          source_amount: paths.destination_amount
        });
      }
      return paths;
    }
    function isRippledIOUAmount(amount) {
      return typeof amount === "object" && amount.currency && amount.currency !== "XRP";
    }
    function conditionallyAddDirectXRPPath(connection, address, paths) {
      if (isRippledIOUAmount(paths.destination_amount) || !paths.destination_currencies.includes("XRP")) {
        return Promise.resolve(paths);
      }
      return utils_1.getXRPBalance(connection, address, void 0).then((xrpBalance) => addDirectXrpPath(paths, xrpBalance));
    }
    function filterSourceFundsLowPaths(pathfind, paths) {
      if (pathfind.source.amount && pathfind.destination.amount.value == null && paths.alternatives) {
        paths.alternatives = paths.alternatives.filter((alt) => {
          if (!alt.source_amount) {
            return false;
          }
          const pathfindSourceAmountValue = new bignumber_js_1.default(pathfind.source.amount.currency === "XRP" ? common_1.xrpToDrops(pathfind.source.amount.value) : pathfind.source.amount.value);
          const altSourceAmountValue = new bignumber_js_1.default(typeof alt.source_amount === "string" ? alt.source_amount : alt.source_amount.value);
          return altSourceAmountValue.eq(pathfindSourceAmountValue);
        });
      }
      return paths;
    }
    function formatResponse(pathfind, paths) {
      if (paths.alternatives && paths.alternatives.length > 0) {
        return pathfind_1.default(paths);
      }
      if (paths.destination_currencies != null && !paths.destination_currencies.includes(pathfind.destination.amount.currency)) {
        throw new NotFoundError("No paths found. The destination_account does not accept " + pathfind.destination.amount.currency + ", they only accept: " + paths.destination_currencies.join(", "));
      } else if (paths.source_currencies && paths.source_currencies.length > 0) {
        throw new NotFoundError("No paths found. Please ensure that the source_account has sufficient funds to execute the payment in one of the specified source_currencies. If it does there may be insufficient liquidity in the network to execute this payment right now");
      } else {
        throw new NotFoundError("No paths found. Please ensure that the source_account has sufficient funds to execute the payment. If it does there may be insufficient liquidity in the network to execute this payment right now");
      }
    }
    function getPaths(pathfind) {
      common_1.validate.getPaths({ pathfind });
      const address = pathfind.source.address;
      return requestPathFind(this.connection, pathfind).then((paths) => conditionallyAddDirectXRPPath(this.connection, address, paths)).then((paths) => filterSourceFundsLowPaths(pathfind, paths)).then((paths) => formatResponse(pathfind, paths));
    }
    exports.default = getPaths;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/flags.js
var require_flags = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/flags.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trustlineFlags = exports.orderFlags = void 0;
    var orderFlags = {
      Passive: 65536,
      Sell: 131072
    };
    exports.orderFlags = orderFlags;
    var trustlineFlags = {
      LowReserve: 65536,
      HighReserve: 131072,
      LowAuth: 262144,
      HighAuth: 524288,
      LowNoRipple: 1048576,
      HighNoRipple: 2097152,
      LowFreeze: 4194304,
      HighFreeze: 8388608
    };
    exports.trustlineFlags = trustlineFlags;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/account-order.js
var require_account_order = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/account-order.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAccountOrder = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var amount_1 = __importDefault(require_amount2());
    var utils_1 = require_utils7();
    var common_1 = require_common();
    var flags_1 = require_flags();
    function computeQuality(takerGets, takerPays) {
      const quotient = new bignumber_js_1.default(takerPays.value).dividedBy(takerGets.value);
      return quotient.precision(16, bignumber_js_1.default.ROUND_HALF_UP).toString();
    }
    function parseAccountOrder(address, order) {
      const direction = (order.flags & flags_1.orderFlags.Sell) === 0 ? "buy" : "sell";
      const takerGetsAmount = amount_1.default(order.taker_gets);
      const takerPaysAmount = amount_1.default(order.taker_pays);
      const quantity = direction === "buy" ? takerPaysAmount : takerGetsAmount;
      const totalPrice = direction === "buy" ? takerGetsAmount : takerPaysAmount;
      const specification = common_1.removeUndefined({
        direction,
        quantity,
        totalPrice,
        passive: (order.flags & flags_1.orderFlags.Passive) !== 0 || void 0,
        expirationTime: utils_1.parseTimestamp(order.expiration)
      });
      const makerExchangeRate = order.quality ? utils_1.adjustQualityForXRP(order.quality.toString(), takerGetsAmount.currency, takerPaysAmount.currency) : computeQuality(takerGetsAmount, takerPaysAmount);
      const properties = {
        maker: address,
        sequence: order.seq,
        makerExchangeRate
      };
      return { specification, properties };
    }
    exports.parseAccountOrder = parseAccountOrder;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/orders.js
var require_orders = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/orders.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var common_1 = require_common();
    var account_order_1 = require_account_order();
    function formatResponse(address, responses) {
      let orders = [];
      for (const response of responses) {
        const offers = response.offers.map((offer) => {
          return account_order_1.parseAccountOrder(address, offer);
        });
        orders = orders.concat(offers);
      }
      return _.sortBy(orders, (order) => order.properties.sequence);
    }
    function getOrders(address, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getOrders({ address, options });
        const responses = yield this._requestAll("account_offers", {
          account: address,
          ledger_index: options.ledgerVersion || (yield this.getLedgerVersion()),
          limit: options.limit
        });
        return formatResponse(address, responses);
      });
    }
    exports.default = getOrders;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/orderbook-order.js
var require_orderbook_order = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/orderbook-order.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseOrderbookOrder = void 0;
    var _ = __importStar(require_lodash());
    var utils_1 = require_utils7();
    var common_1 = require_common();
    var flags_1 = require_flags();
    var amount_1 = __importDefault(require_amount2());
    function parseOrderbookOrder(data) {
      const direction = (data.Flags & flags_1.orderFlags.Sell) === 0 ? "buy" : "sell";
      const takerGetsAmount = amount_1.default(data.TakerGets);
      const takerPaysAmount = amount_1.default(data.TakerPays);
      const quantity = direction === "buy" ? takerPaysAmount : takerGetsAmount;
      const totalPrice = direction === "buy" ? takerGetsAmount : takerPaysAmount;
      const specification = common_1.removeUndefined({
        direction,
        quantity,
        totalPrice,
        passive: (data.Flags & flags_1.orderFlags.Passive) !== 0 || void 0,
        expirationTime: utils_1.parseTimestamp(data.Expiration)
      });
      const properties = {
        maker: data.Account,
        sequence: data.Sequence,
        makerExchangeRate: utils_1.adjustQualityForXRP(data.quality, takerGetsAmount.currency, takerPaysAmount.currency)
      };
      const takerGetsFunded = data.taker_gets_funded ? amount_1.default(data.taker_gets_funded) : void 0;
      const takerPaysFunded = data.taker_pays_funded ? amount_1.default(data.taker_pays_funded) : void 0;
      const available = common_1.removeUndefined({
        fundedAmount: takerGetsFunded,
        priceOfFundedAmount: takerPaysFunded
      });
      const state = _.isEmpty(available) ? void 0 : available;
      return common_1.removeUndefined({ specification, properties, state, data });
    }
    exports.parseOrderbookOrder = parseOrderbookOrder;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/orderbook.js
var require_orderbook2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/orderbook.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOrderbook = exports.formatBidsAndAsks = void 0;
    var _ = __importStar(require_lodash());
    var utils = __importStar(require_utils5());
    var orderbook_order_1 = require_orderbook_order();
    var common_1 = require_common();
    var bignumber_js_1 = __importDefault(require_bignumber());
    function isSameIssue(a, b) {
      return a.currency === b.currency && a.counterparty === b.counterparty;
    }
    function directionFilter(direction, order) {
      return order.specification.direction === direction;
    }
    function flipOrder(order) {
      const specification = order.specification;
      const flippedSpecification = {
        quantity: specification.totalPrice,
        totalPrice: specification.quantity,
        direction: specification.direction === "buy" ? "sell" : "buy"
      };
      const newSpecification = _.merge({}, specification, flippedSpecification);
      return _.merge({}, order, { specification: newSpecification });
    }
    function alignOrder(base, order) {
      const quantity = order.specification.quantity;
      return isSameIssue(quantity, base) ? order : flipOrder(order);
    }
    function formatBidsAndAsks(orderbook, offers) {
      const orders = offers.sort((a, b) => {
        return new bignumber_js_1.default(a.quality).comparedTo(b.quality);
      }).map(orderbook_order_1.parseOrderbookOrder);
      const alignedOrders = orders.map(_.partial(alignOrder, orderbook.base));
      const bids = alignedOrders.filter(_.partial(directionFilter, "buy"));
      const asks = alignedOrders.filter(_.partial(directionFilter, "sell"));
      return { bids, asks };
    }
    exports.formatBidsAndAsks = formatBidsAndAsks;
    function makeRequest(api2, taker, options, takerGets, takerPays) {
      return __awaiter(this, void 0, void 0, function* () {
        const orderData = utils.renameCounterpartyToIssuerInOrder({
          taker_gets: takerGets,
          taker_pays: takerPays
        });
        return api2._requestAll("book_offers", {
          taker_gets: orderData.taker_gets,
          taker_pays: orderData.taker_pays,
          ledger_index: options.ledgerVersion || "validated",
          limit: options.limit,
          taker
        });
      });
    }
    function getOrderbook(address, orderbook, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getOrderbook({ address, orderbook, options });
        const [directOfferResults, reverseOfferResults] = yield Promise.all([
          makeRequest(this, address, options, orderbook.base, orderbook.counter),
          makeRequest(this, address, options, orderbook.counter, orderbook.base)
        ]);
        const directOffers = _.flatMap(directOfferResults, (directOfferResult) => directOfferResult.offers);
        const reverseOffers = _.flatMap(reverseOfferResults, (reverseOfferResult) => reverseOfferResult.offers);
        return formatBidsAndAsks(orderbook, [...directOffers, ...reverseOffers]);
      });
    }
    exports.getOrderbook = getOrderbook;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/settings.js
var require_settings3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/settings.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSettings = exports.parseAccountFlags = void 0;
    var fields_1 = __importDefault(require_fields());
    var common_1 = require_common();
    var AccountFlags = common_1.constants.AccountFlags;
    function parseAccountFlags(value, options = {}) {
      const settings = {};
      for (const flagName in AccountFlags) {
        if (value & AccountFlags[flagName]) {
          settings[flagName] = true;
        } else {
          if (!options.excludeFalse) {
            settings[flagName] = false;
          }
        }
      }
      return settings;
    }
    exports.parseAccountFlags = parseAccountFlags;
    function formatSettings(response) {
      const data = response.account_data;
      const parsedFlags = parseAccountFlags(data.Flags, { excludeFalse: true });
      const parsedFields = fields_1.default(data);
      return Object.assign({}, parsedFlags, parsedFields);
    }
    function getSettings(address, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getSettings({ address, options });
        address = common_1.ensureClassicAddress(address);
        const response = yield this.request("account_info", {
          account: address,
          ledger_index: options.ledgerVersion || "validated",
          signer_lists: true
        });
        return formatSettings(response);
      });
    }
    exports.getSettings = getSettings;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/accountinfo.js
var require_accountinfo = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/accountinfo.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var common_1 = require_common();
    function formatAccountInfo(response) {
      const data = response.account_data;
      return common_1.removeUndefined({
        sequence: data.Sequence,
        xrpBalance: common_1.dropsToXrp(data.Balance),
        ownerCount: data.OwnerCount,
        previousInitiatedTransactionID: data.AccountTxnID,
        previousAffectingTransactionID: data.PreviousTxnID,
        previousAffectingTransactionLedgerVersion: data.PreviousTxnLgrSeq
      });
    }
    function getAccountInfo(address, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getAccountInfo({ address, options });
        address = common_1.ensureClassicAddress(address);
        const response = yield this.request("account_info", {
          account: address,
          ledger_index: options.ledgerVersion || "validated"
        });
        return formatAccountInfo(response);
      });
    }
    exports.default = getAccountInfo;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/accountobjects.js
var require_accountobjects = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/accountobjects.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var common_1 = require_common();
    function getAccountObjects(address, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield this.request("account_objects", common_1.removeUndefined({
          account: address,
          type: options.type,
          ledger_hash: options.ledgerHash,
          ledger_index: options.ledgerIndex,
          limit: options.limit,
          marker: options.marker
        }));
        return response;
      });
    }
    exports.default = getAccountObjects;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/payment-channel.js
var require_payment_channel = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/payment-channel.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parsePaymentChannel = void 0;
    var utils_1 = require_utils7();
    var common_1 = require_common();
    function parsePaymentChannel(data) {
      return common_1.removeUndefined({
        memos: utils_1.parseMemos(data),
        account: data.Account,
        amount: common_1.dropsToXrp(data.Amount),
        balance: common_1.dropsToXrp(data.Balance),
        destination: data.Destination,
        publicKey: data.PublicKey,
        settleDelay: data.SettleDelay,
        expiration: utils_1.parseTimestamp(data.Expiration),
        cancelAfter: utils_1.parseTimestamp(data.CancelAfter),
        sourceTag: data.SourceTag,
        destinationTag: data.DestinationTag,
        previousAffectingTransactionID: data.PreviousTxnID,
        previousAffectingTransactionLedgerVersion: data.PreviousTxnLgrSeq
      });
    }
    exports.parsePaymentChannel = parsePaymentChannel;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/payment-channel.js
var require_payment_channel2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/payment-channel.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var payment_channel_1 = require_payment_channel();
    var common_1 = require_common();
    var NotFoundError = common_1.errors.NotFoundError;
    function formatResponse(response) {
      if (response.node == null || response.node.LedgerEntryType !== "PayChannel") {
        throw new NotFoundError("Payment channel ledger entry not found");
      }
      return payment_channel_1.parsePaymentChannel(response.node);
    }
    function getPaymentChannel(id) {
      return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getPaymentChannel({ id });
        const response = yield this.request("ledger_entry", {
          index: id,
          binary: false,
          ledger_index: "validated"
        });
        return formatResponse(response);
      });
    }
    exports.default = getPaymentChannel;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/utils.js
var require_utils8 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/utils.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getClassicAccountAndTag = exports.setCanonicalFlag = exports.common = exports.prepareTransaction = exports.convertMemo = exports.convertStringToHex = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var common = __importStar(require_common());
    exports.common = common;
    var common_1 = require_common();
    var errors_1 = require_errors();
    var ripple_address_codec_1 = require_dist4();
    var txFlags = common.txFlags;
    var TRANSACTION_TYPES_WITH_DESTINATION_TAG_FIELD = [
      "Payment",
      "CheckCreate",
      "EscrowCreate",
      "PaymentChannelCreate"
    ];
    function formatPrepareResponse(txJSON) {
      const instructions = {
        fee: common.dropsToXrp(txJSON.Fee),
        maxLedgerVersion: txJSON.LastLedgerSequence == null ? null : txJSON.LastLedgerSequence
      };
      if (txJSON.TicketSequence != null) {
        instructions["ticketSequence"] = txJSON.TicketSequence;
      } else {
        instructions["sequence"] = txJSON.Sequence;
      }
      return {
        txJSON: JSON.stringify(txJSON),
        instructions
      };
    }
    function setCanonicalFlag(txJSON) {
      txJSON.Flags |= txFlags.Universal.FullyCanonicalSig;
      txJSON.Flags = txJSON.Flags >>> 0;
    }
    exports.setCanonicalFlag = setCanonicalFlag;
    function scaleValue(value, multiplier, extra = 0) {
      return new bignumber_js_1.default(value).times(multiplier).plus(extra).toString();
    }
    function getClassicAccountAndTag(Account, expectedTag) {
      if (ripple_address_codec_1.isValidXAddress(Account)) {
        const classic = ripple_address_codec_1.xAddressToClassicAddress(Account);
        if (expectedTag != null && classic.tag !== expectedTag) {
          throw new errors_1.ValidationError("address includes a tag that does not match the tag specified in the transaction");
        }
        return {
          classicAccount: classic.classicAddress,
          tag: classic.tag
        };
      } else {
        return {
          classicAccount: Account,
          tag: expectedTag
        };
      }
    }
    exports.getClassicAccountAndTag = getClassicAccountAndTag;
    function prepareTransaction(txJSON, api2, instructions) {
      common.validate.instructions(instructions);
      common.validate.tx_json(txJSON);
      if (instructions.sequence != null && instructions.sequence === 0) {
        return Promise.reject(new errors_1.ValidationError("`sequence` cannot be 0"));
      }
      const disallowedFieldsInTxJSON = [
        "maxLedgerVersion",
        "maxLedgerVersionOffset",
        "fee",
        "sequence",
        "ticketSequence"
      ];
      const badFields = disallowedFieldsInTxJSON.filter((field) => txJSON[field]);
      if (badFields.length) {
        return Promise.reject(new errors_1.ValidationError('txJSON additionalProperty "' + badFields[0] + '" exists in instance when not allowed'));
      }
      const newTxJSON = Object.assign({}, txJSON);
      if (txJSON["SignerQuorum"] === 0) {
        delete newTxJSON.SignerEntries;
      }
      const { classicAccount, tag: sourceTag } = getClassicAccountAndTag(txJSON.Account);
      newTxJSON.Account = classicAccount;
      if (sourceTag != null) {
        if (txJSON.SourceTag && txJSON.SourceTag !== sourceTag) {
          return Promise.reject(new errors_1.ValidationError("The `SourceTag`, if present, must match the tag of the `Account` X-address"));
        }
        if (sourceTag) {
          newTxJSON.SourceTag = sourceTag;
        }
      }
      if (typeof txJSON.Destination === "string") {
        const { classicAccount: destinationAccount, tag: destinationTag } = getClassicAccountAndTag(txJSON.Destination);
        newTxJSON.Destination = destinationAccount;
        if (destinationTag != null) {
          if (TRANSACTION_TYPES_WITH_DESTINATION_TAG_FIELD.includes(txJSON.TransactionType)) {
            if (txJSON.DestinationTag && txJSON.DestinationTag !== destinationTag) {
              return Promise.reject(new errors_1.ValidationError("The Payment `DestinationTag`, if present, must match the tag of the `Destination` X-address"));
            }
            if (destinationTag) {
              newTxJSON.DestinationTag = destinationTag;
            }
          }
        }
      }
      function convertToClassicAccountIfPresent(fieldName) {
        const account = txJSON[fieldName];
        if (typeof account === "string") {
          const { classicAccount: ca } = getClassicAccountAndTag(account);
          newTxJSON[fieldName] = ca;
        }
      }
      function convertIssuedCurrencyToAccountIfPresent(fieldName) {
        const amount = txJSON[fieldName];
        if (typeof amount === "number" || amount instanceof Array || amount == null)
          return;
        newTxJSON[fieldName] = common_1.toRippledAmount(amount);
      }
      convertToClassicAccountIfPresent("Authorize");
      convertToClassicAccountIfPresent("Unauthorize");
      convertToClassicAccountIfPresent("Owner");
      convertToClassicAccountIfPresent("RegularKey");
      convertIssuedCurrencyToAccountIfPresent("Amount");
      convertIssuedCurrencyToAccountIfPresent("SendMax");
      convertIssuedCurrencyToAccountIfPresent("DeliverMin");
      convertIssuedCurrencyToAccountIfPresent("TakerPays");
      convertIssuedCurrencyToAccountIfPresent("TakerGets");
      convertIssuedCurrencyToAccountIfPresent("LimitAmount");
      setCanonicalFlag(newTxJSON);
      function prepareMaxLedgerVersion() {
        if (newTxJSON.LastLedgerSequence && instructions.maxLedgerVersion) {
          return Promise.reject(new errors_1.ValidationError("`LastLedgerSequence` in txJSON and `maxLedgerVersion` in `instructions` cannot both be set"));
        }
        if (newTxJSON.LastLedgerSequence && instructions.maxLedgerVersionOffset) {
          return Promise.reject(new errors_1.ValidationError("`LastLedgerSequence` in txJSON and `maxLedgerVersionOffset` in `instructions` cannot both be set"));
        }
        if (newTxJSON.LastLedgerSequence) {
          return Promise.resolve();
        }
        if (instructions.maxLedgerVersion !== void 0) {
          if (instructions.maxLedgerVersion !== null) {
            newTxJSON.LastLedgerSequence = instructions.maxLedgerVersion;
          }
          return Promise.resolve();
        }
        const offset = instructions.maxLedgerVersionOffset != null ? instructions.maxLedgerVersionOffset : 3;
        return api2.connection.getLedgerVersion().then((ledgerVersion) => {
          newTxJSON.LastLedgerSequence = ledgerVersion + offset;
          return;
        });
      }
      function prepareFee() {
        if (newTxJSON.Fee && instructions.fee) {
          return Promise.reject(new errors_1.ValidationError("`Fee` in txJSON and `fee` in `instructions` cannot both be set"));
        }
        if (newTxJSON.Fee) {
          return Promise.resolve();
        }
        const multiplier = instructions.signersCount == null ? 1 : instructions.signersCount + 1;
        if (instructions.fee != null) {
          const fee = new bignumber_js_1.default(instructions.fee);
          if (fee.isGreaterThan(api2._maxFeeXRP)) {
            return Promise.reject(new errors_1.ValidationError(`Fee of ${fee.toString(10)} XRP exceeds max of ${api2._maxFeeXRP} XRP. To use this fee, increase \`maxFeeXRP\` in the RippleAPI constructor.`));
          }
          newTxJSON.Fee = scaleValue(common.xrpToDrops(instructions.fee), multiplier);
          return Promise.resolve();
        }
        const cushion = api2._feeCushion;
        return api2.getFee(cushion).then((fee) => {
          return api2.connection.getFeeRef().then((feeRef) => {
            const extraFee = newTxJSON.TransactionType !== "EscrowFinish" || newTxJSON.Fulfillment == null ? 0 : cushion * feeRef * (32 + Math.floor(Buffer.from(newTxJSON.Fulfillment, "hex").length / 16));
            const feeDrops = common.xrpToDrops(fee);
            const maxFeeXRP = instructions.maxFee ? bignumber_js_1.default.min(api2._maxFeeXRP, instructions.maxFee) : api2._maxFeeXRP;
            const maxFeeDrops = common.xrpToDrops(maxFeeXRP);
            const normalFee = scaleValue(feeDrops, multiplier, extraFee);
            newTxJSON.Fee = bignumber_js_1.default.min(normalFee, maxFeeDrops).toString(10);
            return;
          });
        });
      }
      function prepareSequence() {
        return __awaiter(this, void 0, void 0, function* () {
          if (instructions.sequence != null) {
            if (newTxJSON.Sequence == null || instructions.sequence === newTxJSON.Sequence) {
              newTxJSON.Sequence = instructions.sequence;
              return Promise.resolve();
            } else {
              return Promise.reject(new errors_1.ValidationError("`Sequence` in txJSON must match `sequence` in `instructions`"));
            }
          }
          if (newTxJSON.Sequence != null) {
            return Promise.resolve();
          }
          if (instructions.ticketSequence != null) {
            newTxJSON.Sequence = 0;
            newTxJSON.TicketSequence = instructions.ticketSequence;
            return Promise.resolve();
          }
          try {
            const response = yield api2.request("account_info", {
              account: classicAccount,
              ledger_index: "current"
            });
            newTxJSON.Sequence = response.account_data.Sequence;
            return Promise.resolve();
          } catch (e) {
            return Promise.reject(e);
          }
        });
      }
      return Promise.all([
        prepareMaxLedgerVersion(),
        prepareFee(),
        prepareSequence()
      ]).then(() => formatPrepareResponse(newTxJSON));
    }
    exports.prepareTransaction = prepareTransaction;
    function convertStringToHex(string) {
      return Buffer.from(string, "utf8").toString("hex").toUpperCase();
    }
    exports.convertStringToHex = convertStringToHex;
    function convertMemo(memo) {
      return {
        Memo: common.removeUndefined({
          MemoData: memo.data ? convertStringToHex(memo.data) : void 0,
          MemoType: memo.type ? convertStringToHex(memo.type) : void 0,
          MemoFormat: memo.format ? convertStringToHex(memo.format) : void 0
        })
      };
    }
    exports.convertMemo = convertMemo;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/payment.js
var require_payment3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/payment.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var utils = __importStar(require_utils8());
    var validate = utils.common.validate;
    var paymentFlags = utils.common.txFlags.Payment;
    var ValidationError = utils.common.errors.ValidationError;
    var common_1 = require_common();
    var utils_1 = require_utils8();
    function isMaxAdjustment(source) {
      return source.maxAmount != null;
    }
    function isMinAdjustment(destination) {
      return destination.minAmount != null;
    }
    function isXRPToXRPPayment(payment) {
      const { source, destination } = payment;
      const sourceCurrency = isMaxAdjustment(source) ? source.maxAmount.currency : source.amount.currency;
      const destinationCurrency = isMinAdjustment(destination) ? destination.minAmount.currency : destination.amount.currency;
      return (sourceCurrency === "XRP" || sourceCurrency === "drops") && (destinationCurrency === "XRP" || destinationCurrency === "drops");
    }
    function isIOUWithoutCounterparty(amount) {
      return amount && amount.currency !== "XRP" && amount.currency !== "drops" && amount.counterparty == null;
    }
    function applyAnyCounterpartyEncoding(payment) {
      [payment.source, payment.destination].forEach((adjustment) => {
        ["amount", "minAmount", "maxAmount"].forEach((key) => {
          if (isIOUWithoutCounterparty(adjustment[key])) {
            adjustment[key].counterparty = adjustment.address;
          }
        });
      });
    }
    function createMaximalAmount(amount) {
      const maxXRPValue = "100000000000";
      const maxIOUValue = "999999999999999900000000000000000000000000000000000000000000000000000000000000000000000000000000";
      let maxValue;
      if (amount.currency === "XRP") {
        maxValue = maxXRPValue;
      } else if (amount.currency === "drops") {
        maxValue = common_1.xrpToDrops(maxXRPValue);
      } else {
        maxValue = maxIOUValue;
      }
      return Object.assign({}, amount, { value: maxValue });
    }
    function validateAndNormalizeAddress(address, expectedTag) {
      const classicAddress = utils_1.getClassicAccountAndTag(address, expectedTag);
      classicAddress.tag = classicAddress.tag === false ? void 0 : classicAddress.tag;
      return classicAddress;
    }
    function createPaymentTransaction(address, paymentArgument) {
      const payment = _.cloneDeep(paymentArgument);
      applyAnyCounterpartyEncoding(payment);
      const sourceAddressAndTag = validateAndNormalizeAddress(payment.source.address, payment.source.tag);
      const addressToVerifyAgainst = validateAndNormalizeAddress(address, void 0);
      if (addressToVerifyAgainst.classicAccount !== sourceAddressAndTag.classicAccount) {
        throw new ValidationError("address must match payment.source.address");
      }
      if (addressToVerifyAgainst.tag != null && sourceAddressAndTag.tag != null && addressToVerifyAgainst.tag !== sourceAddressAndTag.tag) {
        throw new ValidationError("address includes a tag that does not match payment.source.tag");
      }
      const destinationAddressAndTag = validateAndNormalizeAddress(payment.destination.address, payment.destination.tag);
      if (isMaxAdjustment(payment.source) && isMinAdjustment(payment.destination) || !isMaxAdjustment(payment.source) && !isMinAdjustment(payment.destination)) {
        throw new ValidationError("payment must specify either (source.maxAmount and destination.amount) or (source.amount and destination.minAmount)");
      }
      const destinationAmount = isMinAdjustment(payment.destination) ? payment.destination.minAmount : payment.destination.amount;
      const sourceAmount = isMaxAdjustment(payment.source) ? payment.source.maxAmount : payment.source.amount;
      const amount = isMinAdjustment(payment.destination) && !isXRPToXRPPayment(payment) ? createMaximalAmount(destinationAmount) : destinationAmount;
      const txJSON = {
        TransactionType: "Payment",
        Account: sourceAddressAndTag.classicAccount,
        Destination: destinationAddressAndTag.classicAccount,
        Amount: common_1.toRippledAmount(amount),
        Flags: 0
      };
      if (payment.invoiceID != null) {
        txJSON.InvoiceID = payment.invoiceID;
      }
      if (sourceAddressAndTag.tag != null) {
        txJSON.SourceTag = sourceAddressAndTag.tag;
      }
      if (destinationAddressAndTag.tag != null) {
        txJSON.DestinationTag = destinationAddressAndTag.tag;
      }
      if (payment.memos != null) {
        txJSON.Memos = payment.memos.map(utils.convertMemo);
      }
      if (payment.noDirectRipple === true) {
        txJSON.Flags |= paymentFlags.NoRippleDirect;
      }
      if (payment.limitQuality === true) {
        txJSON.Flags |= paymentFlags.LimitQuality;
      }
      if (!isXRPToXRPPayment(payment)) {
        if (payment.allowPartialPayment || isMinAdjustment(payment.destination)) {
          txJSON.Flags |= paymentFlags.PartialPayment;
        }
        txJSON.SendMax = common_1.toRippledAmount(sourceAmount);
        if (isMinAdjustment(payment.destination)) {
          txJSON.DeliverMin = common_1.toRippledAmount(destinationAmount);
        }
        if (payment.paths != null) {
          txJSON.Paths = JSON.parse(payment.paths);
        }
      } else if (payment.allowPartialPayment === true) {
        throw new ValidationError("XRP to XRP payments cannot be partial payments");
      }
      return txJSON;
    }
    function preparePayment(address, payment, instructions = {}) {
      try {
        validate.preparePayment({ address, payment, instructions });
        const txJSON = createPaymentTransaction(address, payment);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = preparePayment;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/trustline.js
var require_trustline3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/trustline.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var bignumber_js_1 = __importDefault(require_bignumber());
    var utils = __importStar(require_utils8());
    var validate = utils.common.validate;
    var trustlineFlags = utils.common.txFlags.TrustSet;
    function convertQuality(quality) {
      return new bignumber_js_1.default(quality).shiftedBy(9).integerValue(bignumber_js_1.default.ROUND_DOWN).toNumber();
    }
    function createTrustlineTransaction(account, trustline) {
      const limit = {
        currency: trustline.currency,
        issuer: trustline.counterparty,
        value: trustline.limit
      };
      const txJSON = {
        TransactionType: "TrustSet",
        Account: account,
        LimitAmount: limit,
        Flags: 0
      };
      if (trustline.qualityIn != null) {
        txJSON.QualityIn = convertQuality(trustline.qualityIn);
      }
      if (trustline.qualityOut != null) {
        txJSON.QualityOut = convertQuality(trustline.qualityOut);
      }
      if (trustline.authorized === true) {
        txJSON.Flags |= trustlineFlags.SetAuth;
      }
      if (trustline.ripplingDisabled != null) {
        txJSON.Flags |= trustline.ripplingDisabled ? trustlineFlags.NoRipple : trustlineFlags.ClearNoRipple;
      }
      if (trustline.frozen != null) {
        txJSON.Flags |= trustline.frozen ? trustlineFlags.SetFreeze : trustlineFlags.ClearFreeze;
      }
      if (trustline.memos != null) {
        txJSON.Memos = trustline.memos.map(utils.convertMemo);
      }
      return txJSON;
    }
    function prepareTrustline(address, trustline, instructions = {}) {
      try {
        validate.prepareTrustline({ address, trustline, instructions });
        const txJSON = createTrustlineTransaction(address, trustline);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = prepareTrustline;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/order.js
var require_order3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/order.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var offerFlags = utils.common.txFlags.OfferCreate;
    var common_1 = require_common();
    function createOrderTransaction(account, order) {
      const takerPays = common_1.toRippledAmount(order.direction === "buy" ? order.quantity : order.totalPrice);
      const takerGets = common_1.toRippledAmount(order.direction === "buy" ? order.totalPrice : order.quantity);
      const txJSON = {
        TransactionType: "OfferCreate",
        Account: account,
        TakerGets: takerGets,
        TakerPays: takerPays,
        Flags: 0
      };
      if (order.direction === "sell") {
        txJSON.Flags |= offerFlags.Sell;
      }
      if (order.passive === true) {
        txJSON.Flags |= offerFlags.Passive;
      }
      if (order.immediateOrCancel === true) {
        txJSON.Flags |= offerFlags.ImmediateOrCancel;
      }
      if (order.fillOrKill === true) {
        txJSON.Flags |= offerFlags.FillOrKill;
      }
      if (order.expirationTime != null) {
        txJSON.Expiration = common_1.iso8601ToRippleTime(order.expirationTime);
      }
      if (order.orderToReplace != null) {
        txJSON.OfferSequence = order.orderToReplace;
      }
      if (order.memos != null) {
        txJSON.Memos = order.memos.map(utils.convertMemo);
      }
      return txJSON;
    }
    function prepareOrder(address, order, instructions = {}) {
      try {
        common_1.validate.prepareOrder({ address, order, instructions });
        const txJSON = createOrderTransaction(address, order);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = prepareOrder;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/ordercancellation.js
var require_ordercancellation = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/ordercancellation.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var validate = utils.common.validate;
    function createOrderCancellationTransaction(account, orderCancellation) {
      const txJSON = {
        TransactionType: "OfferCancel",
        Account: account,
        OfferSequence: orderCancellation.orderSequence
      };
      if (orderCancellation.memos != null) {
        txJSON.Memos = orderCancellation.memos.map(utils.convertMemo);
      }
      return txJSON;
    }
    function prepareOrderCancellation(address, orderCancellation, instructions = {}) {
      try {
        validate.prepareOrderCancellation({
          address,
          orderCancellation,
          instructions
        });
        const txJSON = createOrderCancellationTransaction(address, orderCancellation);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = prepareOrderCancellation;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/escrow-creation.js
var require_escrow_creation3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/escrow-creation.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var common_1 = require_common();
    var ValidationError = utils.common.errors.ValidationError;
    function createEscrowCreationTransaction(account, payment) {
      const txJSON = {
        TransactionType: "EscrowCreate",
        Account: account,
        Destination: payment.destination,
        Amount: common_1.xrpToDrops(payment.amount)
      };
      if (payment.condition != null) {
        txJSON.Condition = payment.condition;
      }
      if (payment.allowCancelAfter != null) {
        txJSON.CancelAfter = common_1.iso8601ToRippleTime(payment.allowCancelAfter);
      }
      if (payment.allowExecuteAfter != null) {
        txJSON.FinishAfter = common_1.iso8601ToRippleTime(payment.allowExecuteAfter);
      }
      if (payment.sourceTag != null) {
        txJSON.SourceTag = payment.sourceTag;
      }
      if (payment.destinationTag != null) {
        txJSON.DestinationTag = payment.destinationTag;
      }
      if (payment.memos != null) {
        txJSON.Memos = payment.memos.map(utils.convertMemo);
      }
      if (Boolean(payment.allowCancelAfter) && Boolean(payment.allowExecuteAfter) && txJSON.CancelAfter <= txJSON.FinishAfter) {
        throw new ValidationError('prepareEscrowCreation: "allowCancelAfter" must be after "allowExecuteAfter"');
      }
      return txJSON;
    }
    function prepareEscrowCreation(address, escrowCreation, instructions = {}) {
      try {
        common_1.validate.prepareEscrowCreation({ address, escrowCreation, instructions });
        const txJSON = createEscrowCreationTransaction(address, escrowCreation);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = prepareEscrowCreation;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/escrow-execution.js
var require_escrow_execution3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/escrow-execution.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var validate = utils.common.validate;
    var ValidationError = utils.common.errors.ValidationError;
    function createEscrowExecutionTransaction(account, payment) {
      const txJSON = {
        TransactionType: "EscrowFinish",
        Account: account,
        Owner: payment.owner,
        OfferSequence: payment.escrowSequence
      };
      if (Boolean(payment.condition) !== Boolean(payment.fulfillment)) {
        throw new ValidationError('"condition" and "fulfillment" fields on EscrowFinish must only be specified together.');
      }
      if (payment.condition != null) {
        txJSON.Condition = payment.condition;
      }
      if (payment.fulfillment != null) {
        txJSON.Fulfillment = payment.fulfillment;
      }
      if (payment.memos != null) {
        txJSON.Memos = payment.memos.map(utils.convertMemo);
      }
      return txJSON;
    }
    function prepareEscrowExecution(address, escrowExecution, instructions = {}) {
      try {
        validate.prepareEscrowExecution({ address, escrowExecution, instructions });
        const txJSON = createEscrowExecutionTransaction(address, escrowExecution);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = prepareEscrowExecution;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/escrow-cancellation.js
var require_escrow_cancellation3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/escrow-cancellation.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var validate = utils.common.validate;
    function createEscrowCancellationTransaction(account, payment) {
      const txJSON = {
        TransactionType: "EscrowCancel",
        Account: account,
        Owner: payment.owner,
        OfferSequence: payment.escrowSequence
      };
      if (payment.memos != null) {
        txJSON.Memos = payment.memos.map(utils.convertMemo);
      }
      return txJSON;
    }
    function prepareEscrowCancellation(address, escrowCancellation, instructions = {}) {
      validate.prepareEscrowCancellation({
        address,
        escrowCancellation,
        instructions
      });
      const txJSON = createEscrowCancellationTransaction(address, escrowCancellation);
      return utils.prepareTransaction(txJSON, this, instructions);
    }
    exports.default = prepareEscrowCancellation;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/payment-channel-create.js
var require_payment_channel_create3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/payment-channel-create.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var common_1 = require_common();
    function createPaymentChannelCreateTransaction(account, paymentChannel) {
      const txJSON = {
        Account: account,
        TransactionType: "PaymentChannelCreate",
        Amount: common_1.xrpToDrops(paymentChannel.amount),
        Destination: paymentChannel.destination,
        SettleDelay: paymentChannel.settleDelay,
        PublicKey: paymentChannel.publicKey.toUpperCase()
      };
      if (paymentChannel.cancelAfter != null) {
        txJSON.CancelAfter = common_1.iso8601ToRippleTime(paymentChannel.cancelAfter);
      }
      if (paymentChannel.sourceTag != null) {
        txJSON.SourceTag = paymentChannel.sourceTag;
      }
      if (paymentChannel.destinationTag != null) {
        txJSON.DestinationTag = paymentChannel.destinationTag;
      }
      return txJSON;
    }
    function preparePaymentChannelCreate(address, paymentChannelCreate, instructions = {}) {
      try {
        common_1.validate.preparePaymentChannelCreate({
          address,
          paymentChannelCreate,
          instructions
        });
        const txJSON = createPaymentChannelCreateTransaction(address, paymentChannelCreate);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = preparePaymentChannelCreate;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/payment-channel-fund.js
var require_payment_channel_fund3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/payment-channel-fund.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var common_1 = require_common();
    function createPaymentChannelFundTransaction(account, fund) {
      const txJSON = {
        Account: account,
        TransactionType: "PaymentChannelFund",
        Channel: fund.channel,
        Amount: common_1.xrpToDrops(fund.amount)
      };
      if (fund.expiration != null) {
        txJSON.Expiration = common_1.iso8601ToRippleTime(fund.expiration);
      }
      return txJSON;
    }
    function preparePaymentChannelFund(address, paymentChannelFund, instructions = {}) {
      try {
        common_1.validate.preparePaymentChannelFund({
          address,
          paymentChannelFund,
          instructions
        });
        const txJSON = createPaymentChannelFundTransaction(address, paymentChannelFund);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = preparePaymentChannelFund;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/payment-channel-claim.js
var require_payment_channel_claim3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/payment-channel-claim.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var ValidationError = utils.common.errors.ValidationError;
    var claimFlags = utils.common.txFlags.PaymentChannelClaim;
    var common_1 = require_common();
    function createPaymentChannelClaimTransaction(account, claim) {
      const txJSON = {
        Account: account,
        TransactionType: "PaymentChannelClaim",
        Channel: claim.channel,
        Flags: 0
      };
      if (claim.balance != null) {
        txJSON.Balance = common_1.xrpToDrops(claim.balance);
      }
      if (claim.amount != null) {
        txJSON.Amount = common_1.xrpToDrops(claim.amount);
      }
      if (Boolean(claim.signature) !== Boolean(claim.publicKey)) {
        throw new ValidationError('"signature" and "publicKey" fields on PaymentChannelClaim must only be specified together.');
      }
      if (claim.signature != null) {
        txJSON.Signature = claim.signature;
      }
      if (claim.publicKey != null) {
        txJSON.PublicKey = claim.publicKey;
      }
      if (claim.renew === true && claim.close === true) {
        throw new ValidationError('"renew" and "close" flags on PaymentChannelClaim are mutually exclusive');
      }
      if (claim.renew === true) {
        txJSON.Flags |= claimFlags.Renew;
      }
      if (claim.close === true) {
        txJSON.Flags |= claimFlags.Close;
      }
      return txJSON;
    }
    function preparePaymentChannelClaim(address, paymentChannelClaim, instructions = {}) {
      try {
        common_1.validate.preparePaymentChannelClaim({
          address,
          paymentChannelClaim,
          instructions
        });
        const txJSON = createPaymentChannelClaimTransaction(address, paymentChannelClaim);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = preparePaymentChannelClaim;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/check-create.js
var require_check_create3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/check-create.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var toRippledAmount = utils.common.toRippledAmount;
    var common_1 = require_common();
    function createCheckCreateTransaction(account, check) {
      const txJSON = {
        Account: account,
        TransactionType: "CheckCreate",
        Destination: check.destination,
        SendMax: toRippledAmount(check.sendMax)
      };
      if (check.destinationTag != null) {
        txJSON.DestinationTag = check.destinationTag;
      }
      if (check.expiration != null) {
        txJSON.Expiration = common_1.iso8601ToRippleTime(check.expiration);
      }
      if (check.invoiceID != null) {
        txJSON.InvoiceID = check.invoiceID;
      }
      return txJSON;
    }
    function prepareCheckCreate(address, checkCreate, instructions = {}) {
      try {
        common_1.validate.prepareCheckCreate({ address, checkCreate, instructions });
        const txJSON = createCheckCreateTransaction(address, checkCreate);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = prepareCheckCreate;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/check-cancel.js
var require_check_cancel3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/check-cancel.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils8();
    var common_1 = require_common();
    function createCheckCancelTransaction(account, cancel) {
      const txJSON = {
        Account: account,
        TransactionType: "CheckCancel",
        CheckID: cancel.checkID
      };
      return txJSON;
    }
    function prepareCheckCancel(address, checkCancel, instructions = {}) {
      try {
        common_1.validate.prepareCheckCancel({ address, checkCancel, instructions });
        const txJSON = createCheckCancelTransaction(address, checkCancel);
        return utils_1.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = prepareCheckCancel;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/check-cash.js
var require_check_cash3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/check-cash.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var ValidationError = utils.common.errors.ValidationError;
    var toRippledAmount = utils.common.toRippledAmount;
    var common_1 = require_common();
    function createCheckCashTransaction(account, checkCash) {
      if (checkCash.amount && checkCash.deliverMin) {
        throw new ValidationError('"amount" and "deliverMin" properties on CheckCash are mutually exclusive');
      }
      const txJSON = {
        Account: account,
        TransactionType: "CheckCash",
        CheckID: checkCash.checkID
      };
      if (checkCash.amount != null) {
        txJSON.Amount = toRippledAmount(checkCash.amount);
      }
      if (checkCash.deliverMin != null) {
        txJSON.DeliverMin = toRippledAmount(checkCash.deliverMin);
      }
      return txJSON;
    }
    function prepareCheckCash(address, checkCash, instructions = {}) {
      try {
        common_1.validate.prepareCheckCash({ address, checkCash, instructions });
        const txJSON = createCheckCashTransaction(address, checkCash);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = prepareCheckCash;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/settings.js
var require_settings4 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/settings.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = __importStar(require_assert());
    var bignumber_js_1 = __importDefault(require_bignumber());
    var utils = __importStar(require_utils8());
    var validate = utils.common.validate;
    var AccountSetFlags = utils.common.constants.AccountSetFlags;
    var AccountFields = utils.common.constants.AccountFields;
    function setTransactionFlags(txJSON, values) {
      const keys = Object.keys(values).filter((key) => AccountSetFlags[key] != null);
      assert.ok(keys.length <= 1, "ERROR: can only set one setting per transaction");
      const flagName = keys[0];
      const value = values[flagName];
      const index = AccountSetFlags[flagName];
      if (index != null) {
        if (value) {
          txJSON.SetFlag = index;
        } else {
          txJSON.ClearFlag = index;
        }
      }
    }
    function setTransactionFields(txJSON, input) {
      const fieldSchema = AccountFields;
      for (const fieldName in fieldSchema) {
        const field = fieldSchema[fieldName];
        let value = input[field.name];
        if (value === void 0) {
          continue;
        }
        if (value === null && field.hasOwnProperty("defaults")) {
          value = field.defaults;
        }
        if (field.encoding === "hex" && !field.length) {
          value = Buffer.from(value, "ascii").toString("hex").toUpperCase();
        }
        txJSON[fieldName] = value;
      }
    }
    function convertTransferRate(transferRate) {
      return new bignumber_js_1.default(transferRate).shiftedBy(9).toNumber();
    }
    function formatSignerEntry(signer) {
      return {
        SignerEntry: {
          Account: signer.address,
          SignerWeight: signer.weight
        }
      };
    }
    function createSettingsTransactionWithoutMemos(account, settings) {
      if (settings.regularKey !== void 0) {
        const removeRegularKey = {
          TransactionType: "SetRegularKey",
          Account: account
        };
        if (settings.regularKey === null) {
          return removeRegularKey;
        }
        return Object.assign({}, removeRegularKey, {
          RegularKey: settings.regularKey
        });
      }
      if (settings.signers != null) {
        const setSignerList = {
          TransactionType: "SignerListSet",
          Account: account,
          SignerEntries: [],
          SignerQuorum: settings.signers.threshold
        };
        if (settings.signers.weights != null) {
          setSignerList.SignerEntries = settings.signers.weights.map(formatSignerEntry);
        }
        return setSignerList;
      }
      const txJSON = {
        TransactionType: "AccountSet",
        Account: account
      };
      const settingsWithoutMemos = Object.assign({}, settings);
      delete settingsWithoutMemos.memos;
      setTransactionFlags(txJSON, settingsWithoutMemos);
      setTransactionFields(txJSON, settings);
      if (txJSON.TransferRate != null) {
        txJSON.TransferRate = convertTransferRate(txJSON.TransferRate);
      }
      return txJSON;
    }
    function createSettingsTransaction(account, settings) {
      const txJSON = createSettingsTransactionWithoutMemos(account, settings);
      if (settings.memos != null) {
        txJSON.Memos = settings.memos.map(utils.convertMemo);
      }
      return txJSON;
    }
    function prepareSettings(address, settings, instructions = {}) {
      try {
        validate.prepareSettings({ address, settings, instructions });
        const txJSON = createSettingsTransaction(address, settings);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = prepareSettings;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/ticket.js
var require_ticket = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/ticket.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var validate = utils.common.validate;
    var ValidationError = utils.common.errors.ValidationError;
    function createTicketTransaction(account, ticketCount) {
      if (!ticketCount || ticketCount === 0)
        throw new ValidationError("Ticket count must be greater than 0.");
      const txJSON = {
        TransactionType: "TicketCreate",
        Account: account,
        TicketCount: ticketCount
      };
      return txJSON;
    }
    function prepareTicketCreate(address, ticketCount, instructions = {}) {
      try {
        validate.prepareTicketCreate({ address, ticketCount, instructions });
        const txJSON = createTicketTransaction(address, ticketCount);
        return utils.prepareTransaction(txJSON, this, instructions);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    exports.default = prepareTicketCreate;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/sign.js
var require_sign3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/sign.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var lodash_1 = __importDefault(require_lodash());
    var utils = __importStar(require_utils8());
    var ripple_keypairs_1 = __importDefault(require_dist5());
    var ripple_binary_codec_1 = __importDefault(require_dist6());
    var hashes_1 = require_hashes2();
    var bignumber_js_1 = __importDefault(require_bignumber());
    var common_1 = require_common();
    var validate = utils.common.validate;
    function computeSignature(tx, privateKey, signAs) {
      const signingData = signAs ? ripple_binary_codec_1.default.encodeForMultisigning(tx, signAs) : ripple_binary_codec_1.default.encodeForSigning(tx);
      return ripple_keypairs_1.default.sign(signingData, privateKey);
    }
    function signWithKeypair(api2, txJSON, keypair, options = {
      signAs: ""
    }) {
      validate.sign({ txJSON, keypair });
      const tx = JSON.parse(txJSON);
      if (tx.TxnSignature || tx.Signers) {
        throw new utils.common.errors.ValidationError('txJSON must not contain "TxnSignature" or "Signers" properties');
      }
      checkFee(api2, tx.Fee);
      const txToSignAndEncode = Object.assign({}, tx);
      txToSignAndEncode.SigningPubKey = options.signAs ? "" : keypair.publicKey;
      if (options.signAs) {
        const signer = {
          Account: options.signAs,
          SigningPubKey: keypair.publicKey,
          TxnSignature: computeSignature(txToSignAndEncode, keypair.privateKey, options.signAs)
        };
        txToSignAndEncode.Signers = [{ Signer: signer }];
      } else {
        txToSignAndEncode.TxnSignature = computeSignature(txToSignAndEncode, keypair.privateKey);
      }
      const serialized = ripple_binary_codec_1.default.encode(txToSignAndEncode);
      checkTxSerialization(serialized, tx);
      return {
        signedTransaction: serialized,
        id: hashes_1.computeBinaryTransactionHash(serialized)
      };
    }
    function objectDiff(a, b) {
      const diffs = {};
      const compare = function(i1, i2, k) {
        const type1 = Object.prototype.toString.call(i1);
        const type2 = Object.prototype.toString.call(i2);
        if (type2 === "[object Undefined]") {
          diffs[k] = null;
          return;
        }
        if (type1 !== type2) {
          diffs[k] = i2;
          return;
        }
        if (type1 === "[object Object]") {
          const objDiff = objectDiff(i1, i2);
          if (Object.keys(objDiff).length > 0) {
            diffs[k] = objDiff;
          }
          return;
        }
        if (type1 === "[object Array]") {
          if (!lodash_1.default.isEqual(i1, i2)) {
            diffs[k] = i2;
          }
          return;
        }
        if (type1 === "[object Function]") {
          if (i1.toString() !== i2.toString()) {
            diffs[k] = i2;
          }
          return;
        }
        if (i1 !== i2) {
          diffs[k] = i2;
        }
      };
      for (const key in a) {
        if (a.hasOwnProperty(key)) {
          compare(a[key], b[key], key);
        }
      }
      for (const key in b) {
        if (b.hasOwnProperty(key)) {
          if (!a[key] && a[key] !== b[key]) {
            diffs[key] = b[key];
          }
        }
      }
      return diffs;
    }
    function checkTxSerialization(serialized, tx) {
      var _a;
      const decoded = ripple_binary_codec_1.default.decode(serialized);
      if (!decoded.TxnSignature && !decoded.Signers) {
        throw new utils.common.errors.ValidationError("Serialized transaction must have a TxnSignature or Signers property");
      }
      delete decoded.TxnSignature;
      delete decoded.Signers;
      if (!tx.SigningPubKey) {
        delete decoded.SigningPubKey;
      }
      (_a = tx.Memos) === null || _a === void 0 ? void 0 : _a.map((memo) => {
        var _a2, _b, _c;
        if ((_a2 = memo === null || memo === void 0 ? void 0 : memo.Memo) === null || _a2 === void 0 ? void 0 : _a2.MemoData) {
          memo.Memo.MemoData = memo.Memo.MemoData.toUpperCase();
        }
        if ((_b = memo === null || memo === void 0 ? void 0 : memo.Memo) === null || _b === void 0 ? void 0 : _b.MemoType) {
          memo.Memo.MemoType = memo.Memo.MemoType.toUpperCase();
        }
        if ((_c = memo === null || memo === void 0 ? void 0 : memo.Memo) === null || _c === void 0 ? void 0 : _c.MemoFormat) {
          memo.Memo.MemoFormat = memo.Memo.MemoFormat.toUpperCase();
        }
        return memo;
      });
      if (!lodash_1.default.isEqual(decoded, tx)) {
        const error = new utils.common.errors.ValidationError("Serialized transaction does not match original txJSON. See `error.data`");
        error.data = {
          decoded,
          tx,
          diff: objectDiff(tx, decoded)
        };
        throw error;
      }
    }
    function checkFee(api2, txFee) {
      const fee = new bignumber_js_1.default(txFee);
      const maxFeeDrops = common_1.xrpToDrops(api2._maxFeeXRP);
      if (fee.isGreaterThan(maxFeeDrops)) {
        throw new utils.common.errors.ValidationError(`"Fee" should not exceed "${maxFeeDrops}". To use a higher fee, set \`maxFeeXRP\` in the RippleAPI constructor.`);
      }
    }
    function sign(txJSON, secret, options, keypair) {
      if (typeof secret === "string") {
        validate.sign({ txJSON, secret });
        return signWithKeypair(this, txJSON, ripple_keypairs_1.default.deriveKeypair(secret), options);
      } else {
        if (!keypair && !secret) {
          throw new utils.common.errors.ValidationError("sign: Missing secret or keypair.");
        }
        return signWithKeypair(this, txJSON, keypair ? keypair : secret, options);
      }
    }
    exports.default = sign;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/combine.js
var require_combine2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/combine.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var ripple_binary_codec_1 = __importDefault(require_dist6());
    var bignumber_js_1 = __importDefault(require_bignumber());
    var errors_1 = require_errors();
    var ripple_address_codec_1 = require_dist4();
    var common_1 = require_common();
    var hashes_1 = require_hashes2();
    function validateTransactionEquivalence(transactions) {
      const exampleTransaction = JSON.stringify(Object.assign(Object.assign({}, transactions[0]), { Signers: null }));
      if (transactions.slice(1).some((tx) => JSON.stringify(Object.assign(Object.assign({}, tx), { Signers: null })) !== exampleTransaction)) {
        throw new errors_1.ValidationError("txJSON is not the same for all signedTransactions");
      }
    }
    function addressToBigNumber(address) {
      const hex = Buffer.from(ripple_address_codec_1.decodeAccountID(address)).toString("hex");
      return new bignumber_js_1.default(hex, 16);
    }
    function compareSigners(a, b) {
      return addressToBigNumber(a.Signer.Account).comparedTo(addressToBigNumber(b.Signer.Account));
    }
    function getTransactionWithAllSigners(transactions) {
      const sortedSigners = _.flatMap(transactions, (tx) => tx.Signers).filter((signer) => signer).sort(compareSigners);
      return Object.assign(Object.assign({}, transactions[0]), { Signers: sortedSigners });
    }
    function combine(signedTransactions) {
      common_1.validate.combine({ signedTransactions });
      const transactions = signedTransactions.map(ripple_binary_codec_1.default.decode);
      validateTransactionEquivalence(transactions);
      const signedTransaction = ripple_binary_codec_1.default.encode(getTransactionWithAllSigners(transactions));
      return {
        signedTransaction,
        id: hashes_1.computeBinaryTransactionHash(signedTransaction)
      };
    }
    exports.default = combine;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/submit.js
var require_submit3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/submit.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = __importStar(require_utils8());
    var common_1 = require_common();
    function isImmediateRejection(engineResult) {
      return engineResult.startsWith("tem");
    }
    function formatSubmitResponse(response) {
      const data = {
        resultCode: response.engine_result,
        resultMessage: response.engine_result_message,
        engine_result: response.engine_result,
        engine_result_code: response.engine_result_code,
        engine_result_message: response.engine_result_message,
        tx_blob: response.tx_blob,
        tx_json: response.tx_json
      };
      if (isImmediateRejection(response.engine_result)) {
        throw new utils.common.errors.RippledError("Submit failed", data);
      }
      return data;
    }
    function submit(signedTransaction, failHard) {
      return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.submit({ signedTransaction });
        const response = yield this.request("submit", Object.assign({ tx_blob: signedTransaction }, failHard ? { fail_hard: failHard } : {}));
        return formatSubmitResponse(response);
      });
    }
    exports.default = submit;
  }
});

// node_modules/ripple-lib/dist/npm/offline/derive.js
var require_derive = __commonJS({
  "node_modules/ripple-lib/dist/npm/offline/derive.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = void 0;
    var ripple_keypairs_1 = require_dist5();
    Object.defineProperty(exports, "deriveKeypair", { enumerable: true, get: function() {
      return ripple_keypairs_1.deriveKeypair;
    } });
    Object.defineProperty(exports, "deriveAddress", { enumerable: true, get: function() {
      return ripple_keypairs_1.deriveAddress;
    } });
    var ripple_address_codec_1 = require_dist4();
    function deriveXAddress(options) {
      const classicAddress = ripple_keypairs_1.deriveAddress(options.publicKey);
      return ripple_address_codec_1.classicAddressToXAddress(classicAddress, options.tag, options.test);
    }
    exports.deriveXAddress = deriveXAddress;
  }
});

// node_modules/ripple-lib/dist/npm/offline/ledgerhash.js
var require_ledgerhash = __commonJS({
  "node_modules/ripple-lib/dist/npm/offline/ledgerhash.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ = __importStar(require_lodash());
    var hashes_1 = require_hashes2();
    var common = __importStar(require_common());
    function convertLedgerHeader(header) {
      return {
        account_hash: header.stateHash,
        close_time: common.iso8601ToRippleTime(header.closeTime),
        close_time_resolution: header.closeTimeResolution,
        close_flags: header.closeFlags,
        hash: header.ledgerHash,
        ledger_hash: header.ledgerHash,
        ledger_index: header.ledgerVersion.toString(),
        parent_hash: header.parentLedgerHash,
        parent_close_time: common.iso8601ToRippleTime(header.parentCloseTime),
        total_coins: header.totalDrops,
        transaction_hash: header.transactionHash
      };
    }
    function hashLedgerHeader(ledgerHeader) {
      const header = convertLedgerHeader(ledgerHeader);
      return hashes_1.computeLedgerHash(header);
    }
    function computeTransactionHash(ledger, options) {
      let transactions;
      if (ledger.rawTransactions) {
        transactions = JSON.parse(ledger.rawTransactions);
      } else if (ledger.transactions) {
        try {
          transactions = ledger.transactions.map((tx) => JSON.parse(tx.rawTransaction));
        } catch (e) {
          if (e.toString() === "SyntaxError: Unexpected token u in JSON at position 0") {
            throw new common.errors.ValidationError("ledger is missing raw transactions");
          }
        }
      } else {
        if (options.computeTreeHashes) {
          throw new common.errors.ValidationError("transactions property is missing from the ledger");
        }
        return ledger.transactionHash;
      }
      const txs = transactions.map((tx) => {
        const mergeTx = Object.assign({}, _.omit(tx, "tx"), tx.tx || {});
        const renameMeta = Object.assign({}, _.omit(mergeTx, "meta"), tx.meta ? { metaData: tx.meta } : {});
        return renameMeta;
      });
      const transactionHash = hashes_1.computeTransactionTreeHash(txs);
      if (ledger.transactionHash != null && ledger.transactionHash !== transactionHash) {
        throw new common.errors.ValidationError("transactionHash in header does not match computed hash of transactions", {
          transactionHashInHeader: ledger.transactionHash,
          computedHashOfTransactions: transactionHash
        });
      }
      return transactionHash;
    }
    function computeStateHash(ledger, options) {
      if (ledger.rawState == null) {
        if (options.computeTreeHashes) {
          throw new common.errors.ValidationError("rawState property is missing from the ledger");
        }
        return ledger.stateHash;
      }
      const state = JSON.parse(ledger.rawState);
      const stateHash = hashes_1.computeStateTreeHash(state);
      if (ledger.stateHash != null && ledger.stateHash !== stateHash) {
        throw new common.errors.ValidationError("stateHash in header does not match computed hash of state");
      }
      return stateHash;
    }
    function computeLedgerHeaderHash(ledger, options = {}) {
      const subhashes = {
        transactionHash: computeTransactionHash(ledger, options),
        stateHash: computeStateHash(ledger, options)
      };
      return hashLedgerHeader(Object.assign({}, ledger, subhashes));
    }
    exports.default = computeLedgerHeaderHash;
  }
});

// node_modules/ripple-lib/dist/npm/offline/sign-payment-channel-claim.js
var require_sign_payment_channel_claim3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/offline/sign-payment-channel-claim.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = __importStar(require_common());
    var ripple_keypairs_1 = __importDefault(require_dist5());
    var ripple_binary_codec_1 = __importDefault(require_dist6());
    var { validate, xrpToDrops } = common;
    function signPaymentChannelClaim(channel, amount, privateKey) {
      validate.signPaymentChannelClaim({ channel, amount, privateKey });
      const signingData = ripple_binary_codec_1.default.encodeForSigningClaim({
        channel,
        amount: xrpToDrops(amount)
      });
      return ripple_keypairs_1.default.sign(signingData, privateKey);
    }
    exports.default = signPaymentChannelClaim;
  }
});

// node_modules/ripple-lib/dist/npm/offline/verify-payment-channel-claim.js
var require_verify_payment_channel_claim3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/offline/verify-payment-channel-claim.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ripple_keypairs_1 = __importDefault(require_dist5());
    var ripple_binary_codec_1 = __importDefault(require_dist6());
    var common_1 = require_common();
    function verifyPaymentChannelClaim(channel, amount, signature, publicKey) {
      common_1.validate.verifyPaymentChannelClaim({ channel, amount, signature, publicKey });
      const signingData = ripple_binary_codec_1.default.encodeForSigningClaim({
        channel,
        amount: common_1.xrpToDrops(amount)
      });
      return ripple_keypairs_1.default.verify(signingData, signature, publicKey);
    }
    exports.default = verifyPaymentChannelClaim;
  }
});

// node_modules/ripple-lib/dist/npm/offline/generate-address.js
var require_generate_address2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/offline/generate-address.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateAddressAPI = void 0;
    var ripple_address_codec_1 = require_dist4();
    var ripple_keypairs_1 = __importDefault(require_dist5());
    var common_1 = require_common();
    function generateAddressAPI(options = {}) {
      common_1.validate.generateAddress({ options });
      try {
        const generateSeedOptions = {
          algorithm: options.algorithm
        };
        if (options.entropy) {
          generateSeedOptions.entropy = Uint8Array.from(options.entropy);
        }
        const secret = ripple_keypairs_1.default.generateSeed(generateSeedOptions);
        const keypair = ripple_keypairs_1.default.deriveKeypair(secret);
        const classicAddress = ripple_keypairs_1.default.deriveAddress(keypair.publicKey);
        const returnValue = {
          xAddress: ripple_address_codec_1.classicAddressToXAddress(classicAddress, false, options && options.test),
          secret
        };
        if (options.includeClassicAddress) {
          returnValue.classicAddress = classicAddress;
          returnValue.address = classicAddress;
        }
        return returnValue;
      } catch (error) {
        throw new common_1.errors.UnexpectedError(error.message);
      }
    }
    exports.generateAddressAPI = generateAddressAPI;
  }
});

// node_modules/ripple-lib/dist/npm/offline/utils.js
var require_utils9 = __commonJS({
  "node_modules/ripple-lib/dist/npm/offline/utils.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyPaymentChannelClaim = exports.signPaymentChannelClaim = exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = exports.generateXAddress = exports.generateAddress = exports.computePaymentChannelHash = exports.computeEscrowHash = exports.computeLedgerHash = exports.computeStateTreeHash = exports.computeTransactionTreeHash = exports.computeTrustlineHash = exports.computeOrderID = exports.computeSignerListLedgerObjectID = exports.computeAccountLedgerObjectID = exports.computeBinaryTransactionSigningHash = exports.computeTransactionHash = exports.computeBinaryTransactionHash = exports.isValidSecret = exports.iso8601ToRippleTime = exports.rippleTimeToISO8601 = exports.removeUndefined = exports.convertKeysFromSnakeCaseToCamelCase = exports.toRippledAmount = exports.xrpToDrops = exports.dropsToXrp = exports.computeLedgerHeaderHash = void 0;
    var derive_1 = require_derive();
    Object.defineProperty(exports, "deriveKeypair", { enumerable: true, get: function() {
      return derive_1.deriveKeypair;
    } });
    Object.defineProperty(exports, "deriveAddress", { enumerable: true, get: function() {
      return derive_1.deriveAddress;
    } });
    Object.defineProperty(exports, "deriveXAddress", { enumerable: true, get: function() {
      return derive_1.deriveXAddress;
    } });
    var ledgerhash_1 = __importDefault(require_ledgerhash());
    exports.computeLedgerHeaderHash = ledgerhash_1.default;
    var sign_payment_channel_claim_1 = __importDefault(require_sign_payment_channel_claim3());
    exports.signPaymentChannelClaim = sign_payment_channel_claim_1.default;
    var verify_payment_channel_claim_1 = __importDefault(require_verify_payment_channel_claim3());
    exports.verifyPaymentChannelClaim = verify_payment_channel_claim_1.default;
    var utils_1 = require_utils4();
    Object.defineProperty(exports, "dropsToXrp", { enumerable: true, get: function() {
      return utils_1.dropsToXrp;
    } });
    Object.defineProperty(exports, "xrpToDrops", { enumerable: true, get: function() {
      return utils_1.xrpToDrops;
    } });
    Object.defineProperty(exports, "toRippledAmount", { enumerable: true, get: function() {
      return utils_1.toRippledAmount;
    } });
    Object.defineProperty(exports, "convertKeysFromSnakeCaseToCamelCase", { enumerable: true, get: function() {
      return utils_1.convertKeysFromSnakeCaseToCamelCase;
    } });
    Object.defineProperty(exports, "removeUndefined", { enumerable: true, get: function() {
      return utils_1.removeUndefined;
    } });
    Object.defineProperty(exports, "rippleTimeToISO8601", { enumerable: true, get: function() {
      return utils_1.rippleTimeToISO8601;
    } });
    Object.defineProperty(exports, "iso8601ToRippleTime", { enumerable: true, get: function() {
      return utils_1.iso8601ToRippleTime;
    } });
    Object.defineProperty(exports, "isValidSecret", { enumerable: true, get: function() {
      return utils_1.isValidSecret;
    } });
    var hashes_1 = require_hashes2();
    Object.defineProperty(exports, "computeBinaryTransactionHash", { enumerable: true, get: function() {
      return hashes_1.computeBinaryTransactionHash;
    } });
    Object.defineProperty(exports, "computeTransactionHash", { enumerable: true, get: function() {
      return hashes_1.computeTransactionHash;
    } });
    Object.defineProperty(exports, "computeBinaryTransactionSigningHash", { enumerable: true, get: function() {
      return hashes_1.computeBinaryTransactionSigningHash;
    } });
    Object.defineProperty(exports, "computeAccountLedgerObjectID", { enumerable: true, get: function() {
      return hashes_1.computeAccountLedgerObjectID;
    } });
    Object.defineProperty(exports, "computeSignerListLedgerObjectID", { enumerable: true, get: function() {
      return hashes_1.computeSignerListLedgerObjectID;
    } });
    Object.defineProperty(exports, "computeOrderID", { enumerable: true, get: function() {
      return hashes_1.computeOrderID;
    } });
    Object.defineProperty(exports, "computeTrustlineHash", { enumerable: true, get: function() {
      return hashes_1.computeTrustlineHash;
    } });
    Object.defineProperty(exports, "computeTransactionTreeHash", { enumerable: true, get: function() {
      return hashes_1.computeTransactionTreeHash;
    } });
    Object.defineProperty(exports, "computeStateTreeHash", { enumerable: true, get: function() {
      return hashes_1.computeStateTreeHash;
    } });
    Object.defineProperty(exports, "computeLedgerHash", { enumerable: true, get: function() {
      return hashes_1.computeLedgerHash;
    } });
    Object.defineProperty(exports, "computeEscrowHash", { enumerable: true, get: function() {
      return hashes_1.computeEscrowHash;
    } });
    Object.defineProperty(exports, "computePaymentChannelHash", { enumerable: true, get: function() {
      return hashes_1.computePaymentChannelHash;
    } });
    var generate_address_1 = require_generate_address2();
    Object.defineProperty(exports, "generateXAddress", { enumerable: true, get: function() {
      return generate_address_1.generateAddressAPI;
    } });
    var generateAddress = (options = {}) => generate_address_1.generateAddressAPI(Object.assign(Object.assign({}, options), { includeClassicAddress: true }));
    exports.generateAddress = generateAddress;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/parse/ledger.js
var require_ledger = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/parse/ledger.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseLedger = void 0;
    var _ = __importStar(require_lodash());
    var common_1 = require_common();
    var transaction_1 = __importDefault(require_transaction());
    function parseTransactionWrapper(ledgerVersion, tx) {
      const transaction = Object.assign({}, _.omit(tx, "metaData"), {
        meta: tx.metaData,
        ledger_index: ledgerVersion
      });
      const result = transaction_1.default(transaction, true);
      if (!result.outcome.ledgerVersion) {
        result.outcome.ledgerVersion = ledgerVersion;
      }
      return result;
    }
    function parseTransactions(transactions, ledgerVersion) {
      if (_.isEmpty(transactions)) {
        return {};
      }
      if (typeof transactions[0] === "string") {
        return { transactionHashes: transactions };
      }
      return {
        transactions: transactions.map(_.partial(parseTransactionWrapper, ledgerVersion))
      };
    }
    function parseState(state) {
      if (_.isEmpty(state)) {
        return {};
      }
      if (typeof state[0] === "string") {
        return { stateHashes: state };
      }
      return { rawState: JSON.stringify(state) };
    }
    function parseLedger(ledger) {
      const ledgerVersion = parseInt(ledger.ledger_index, 10);
      return common_1.removeUndefined(Object.assign({
        stateHash: ledger.account_hash,
        closeTime: common_1.rippleTimeToISO8601(ledger.close_time),
        closeTimeResolution: ledger.close_time_resolution,
        closeFlags: ledger.close_flags,
        ledgerHash: ledger.ledger_hash,
        ledgerVersion,
        parentLedgerHash: ledger.parent_hash,
        parentCloseTime: common_1.rippleTimeToISO8601(ledger.parent_close_time),
        totalDrops: ledger.total_coins,
        transactionHash: ledger.transaction_hash
      }, parseTransactions(ledger.transactions, ledgerVersion), parseState(ledger.accountState)));
    }
    exports.parseLedger = parseLedger;
  }
});

// node_modules/ripple-lib/dist/npm/ledger/ledger.js
var require_ledger2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/ledger/ledger.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var common_1 = require_common();
    var ledger_1 = require_ledger();
    function getLedger(options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getLedger({ options });
        const response = yield this.request("ledger", {
          ledger_hash: options.ledgerHash,
          ledger_index: options.ledgerVersion || "validated",
          expand: options.includeAllData,
          transactions: options.includeTransactions,
          accounts: options.includeState
        });
        return ledger_1.parseLedger(response.ledger);
      });
    }
    exports.default = getLedger;
  }
});

// node_modules/stream-http/lib/capability.js
var require_capability = __commonJS({
  "node_modules/stream-http/lib/capability.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);
    exports.writableStream = isFunction(global.WritableStream);
    exports.abortController = isFunction(global.AbortController);
    var xhr;
    function getXHR() {
      if (xhr !== void 0) return xhr;
      if (global.XMLHttpRequest) {
        xhr = new global.XMLHttpRequest();
        try {
          xhr.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch (e) {
          xhr = null;
        }
      } else {
        xhr = null;
      }
      return xhr;
    }
    function checkTypeSupport(type) {
      var xhr2 = getXHR();
      if (!xhr2) return false;
      try {
        xhr2.responseType = type;
        return xhr2.responseType === type;
      } catch (e) {
      }
      return false;
    }
    exports.arraybuffer = exports.fetch || checkTypeSupport("arraybuffer");
    exports.msstream = !exports.fetch && checkTypeSupport("ms-stream");
    exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport("moz-chunked-arraybuffer");
    exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);
    function isFunction(value) {
      return typeof value === "function";
    }
    xhr = null;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/stream-http/lib/response.js
var require_response = __commonJS({
  "node_modules/stream-http/lib/response.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var capability = require_capability();
    var inherits = require_inherits_browser();
    var stream = require_readable_browser();
    var rStates = exports.readyStates = {
      UNSENT: 0,
      OPENED: 1,
      HEADERS_RECEIVED: 2,
      LOADING: 3,
      DONE: 4
    };
    var IncomingMessage = exports.IncomingMessage = function(xhr, response, mode, resetTimers) {
      var self2 = this;
      stream.Readable.call(self2);
      self2._mode = mode;
      self2.headers = {};
      self2.rawHeaders = [];
      self2.trailers = {};
      self2.rawTrailers = [];
      self2.on("end", function() {
        process.nextTick(function() {
          self2.emit("close");
        });
      });
      if (mode === "fetch") {
        let read2 = function() {
          reader.read().then(function(result) {
            if (self2._destroyed)
              return;
            resetTimers(result.done);
            if (result.done) {
              self2.push(null);
              return;
            }
            self2.push(Buffer.from(result.value));
            read2();
          }).catch(function(err) {
            resetTimers(true);
            if (!self2._destroyed)
              self2.emit("error", err);
          });
        };
        var read = read2;
        self2._fetchResponse = response;
        self2.url = response.url;
        self2.statusCode = response.status;
        self2.statusMessage = response.statusText;
        response.headers.forEach(function(header, key) {
          self2.headers[key.toLowerCase()] = header;
          self2.rawHeaders.push(key, header);
        });
        if (capability.writableStream) {
          var writable = new WritableStream({
            write: function(chunk) {
              resetTimers(false);
              return new Promise(function(resolve2, reject) {
                if (self2._destroyed) {
                  reject();
                } else if (self2.push(Buffer.from(chunk))) {
                  resolve2();
                } else {
                  self2._resumeFetch = resolve2;
                }
              });
            },
            close: function() {
              resetTimers(true);
              if (!self2._destroyed)
                self2.push(null);
            },
            abort: function(err) {
              resetTimers(true);
              if (!self2._destroyed)
                self2.emit("error", err);
            }
          });
          try {
            response.body.pipeTo(writable).catch(function(err) {
              resetTimers(true);
              if (!self2._destroyed)
                self2.emit("error", err);
            });
            return;
          } catch (e) {
          }
        }
        var reader = response.body.getReader();
        read2();
      } else {
        self2._xhr = xhr;
        self2._pos = 0;
        self2.url = xhr.responseURL;
        self2.statusCode = xhr.status;
        self2.statusMessage = xhr.statusText;
        var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
        headers.forEach(function(header) {
          var matches = header.match(/^([^:]+):\s*(.*)/);
          if (matches) {
            var key = matches[1].toLowerCase();
            if (key === "set-cookie") {
              if (self2.headers[key] === void 0) {
                self2.headers[key] = [];
              }
              self2.headers[key].push(matches[2]);
            } else if (self2.headers[key] !== void 0) {
              self2.headers[key] += ", " + matches[2];
            } else {
              self2.headers[key] = matches[2];
            }
            self2.rawHeaders.push(matches[1], matches[2]);
          }
        });
        self2._charset = "x-user-defined";
        if (!capability.overrideMimeType) {
          var mimeType = self2.rawHeaders["mime-type"];
          if (mimeType) {
            var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
            if (charsetMatch) {
              self2._charset = charsetMatch[1].toLowerCase();
            }
          }
          if (!self2._charset)
            self2._charset = "utf-8";
        }
      }
    };
    inherits(IncomingMessage, stream.Readable);
    IncomingMessage.prototype._read = function() {
      var self2 = this;
      var resolve2 = self2._resumeFetch;
      if (resolve2) {
        self2._resumeFetch = null;
        resolve2();
      }
    };
    IncomingMessage.prototype._onXHRProgress = function(resetTimers) {
      var self2 = this;
      var xhr = self2._xhr;
      var response = null;
      switch (self2._mode) {
        case "text":
          response = xhr.responseText;
          if (response.length > self2._pos) {
            var newData = response.substr(self2._pos);
            if (self2._charset === "x-user-defined") {
              var buffer = Buffer.alloc(newData.length);
              for (var i = 0; i < newData.length; i++)
                buffer[i] = newData.charCodeAt(i) & 255;
              self2.push(buffer);
            } else {
              self2.push(newData, self2._charset);
            }
            self2._pos = response.length;
          }
          break;
        case "arraybuffer":
          if (xhr.readyState !== rStates.DONE || !xhr.response)
            break;
          response = xhr.response;
          self2.push(Buffer.from(new Uint8Array(response)));
          break;
        case "moz-chunked-arraybuffer":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING || !response)
            break;
          self2.push(Buffer.from(new Uint8Array(response)));
          break;
        case "ms-stream":
          response = xhr.response;
          if (xhr.readyState !== rStates.LOADING)
            break;
          var reader = new global.MSStreamReader();
          reader.onprogress = function() {
            if (reader.result.byteLength > self2._pos) {
              self2.push(Buffer.from(new Uint8Array(reader.result.slice(self2._pos))));
              self2._pos = reader.result.byteLength;
            }
          };
          reader.onload = function() {
            resetTimers(true);
            self2.push(null);
          };
          reader.readAsArrayBuffer(response);
          break;
      }
      if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
        resetTimers(true);
        self2.push(null);
      }
    };
  }
});

// node_modules/stream-http/lib/request.js
var require_request = __commonJS({
  "node_modules/stream-http/lib/request.js"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var capability = require_capability();
    var inherits = require_inherits_browser();
    var response = require_response();
    var stream = require_readable_browser();
    var IncomingMessage = response.IncomingMessage;
    var rStates = response.readyStates;
    function decideMode(preferBinary, useFetch) {
      if (capability.fetch && useFetch) {
        return "fetch";
      } else if (capability.mozchunkedarraybuffer) {
        return "moz-chunked-arraybuffer";
      } else if (capability.msstream) {
        return "ms-stream";
      } else if (capability.arraybuffer && preferBinary) {
        return "arraybuffer";
      } else {
        return "text";
      }
    }
    var ClientRequest = module.exports = function(opts) {
      var self2 = this;
      stream.Writable.call(self2);
      self2._opts = opts;
      self2._body = [];
      self2._headers = {};
      if (opts.auth)
        self2.setHeader("Authorization", "Basic " + Buffer.from(opts.auth).toString("base64"));
      Object.keys(opts.headers).forEach(function(name) {
        self2.setHeader(name, opts.headers[name]);
      });
      var preferBinary;
      var useFetch = true;
      if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
        useFetch = false;
        preferBinary = true;
      } else if (opts.mode === "prefer-streaming") {
        preferBinary = false;
      } else if (opts.mode === "allow-wrong-content-type") {
        preferBinary = !capability.overrideMimeType;
      } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
        preferBinary = true;
      } else {
        throw new Error("Invalid value for opts.mode");
      }
      self2._mode = decideMode(preferBinary, useFetch);
      self2._fetchTimer = null;
      self2._socketTimeout = null;
      self2._socketTimer = null;
      self2.on("finish", function() {
        self2._onFinish();
      });
    };
    inherits(ClientRequest, stream.Writable);
    ClientRequest.prototype.setHeader = function(name, value) {
      var self2 = this;
      var lowerName = name.toLowerCase();
      if (unsafeHeaders.indexOf(lowerName) !== -1)
        return;
      self2._headers[lowerName] = {
        name,
        value
      };
    };
    ClientRequest.prototype.getHeader = function(name) {
      var header = this._headers[name.toLowerCase()];
      if (header)
        return header.value;
      return null;
    };
    ClientRequest.prototype.removeHeader = function(name) {
      var self2 = this;
      delete self2._headers[name.toLowerCase()];
    };
    ClientRequest.prototype._onFinish = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      var opts = self2._opts;
      if ("timeout" in opts && opts.timeout !== 0) {
        self2.setTimeout(opts.timeout);
      }
      var headersObj = self2._headers;
      var body = null;
      if (opts.method !== "GET" && opts.method !== "HEAD") {
        body = new Blob(self2._body, {
          type: (headersObj["content-type"] || {}).value || ""
        });
      }
      var headersList = [];
      Object.keys(headersObj).forEach(function(keyName) {
        var name = headersObj[keyName].name;
        var value = headersObj[keyName].value;
        if (Array.isArray(value)) {
          value.forEach(function(v) {
            headersList.push([name, v]);
          });
        } else {
          headersList.push([name, value]);
        }
      });
      if (self2._mode === "fetch") {
        var signal = null;
        if (capability.abortController) {
          var controller = new AbortController();
          signal = controller.signal;
          self2._fetchAbortController = controller;
          if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
            self2._fetchTimer = global.setTimeout(function() {
              self2.emit("requestTimeout");
              if (self2._fetchAbortController)
                self2._fetchAbortController.abort();
            }, opts.requestTimeout);
          }
        }
        global.fetch(self2._opts.url, {
          method: self2._opts.method,
          headers: headersList,
          body: body || void 0,
          mode: "cors",
          credentials: opts.withCredentials ? "include" : "same-origin",
          signal
        }).then(function(response2) {
          self2._fetchResponse = response2;
          self2._resetTimers(false);
          self2._connect();
        }, function(reason) {
          self2._resetTimers(true);
          if (!self2._destroyed)
            self2.emit("error", reason);
        });
      } else {
        var xhr = self2._xhr = new global.XMLHttpRequest();
        try {
          xhr.open(self2._opts.method, self2._opts.url, true);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
        if ("responseType" in xhr)
          xhr.responseType = self2._mode;
        if ("withCredentials" in xhr)
          xhr.withCredentials = !!opts.withCredentials;
        if (self2._mode === "text" && "overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        if ("requestTimeout" in opts) {
          xhr.timeout = opts.requestTimeout;
          xhr.ontimeout = function() {
            self2.emit("requestTimeout");
          };
        }
        headersList.forEach(function(header) {
          xhr.setRequestHeader(header[0], header[1]);
        });
        self2._response = null;
        xhr.onreadystatechange = function() {
          switch (xhr.readyState) {
            case rStates.LOADING:
            case rStates.DONE:
              self2._onXHRProgress();
              break;
          }
        };
        if (self2._mode === "moz-chunked-arraybuffer") {
          xhr.onprogress = function() {
            self2._onXHRProgress();
          };
        }
        xhr.onerror = function() {
          if (self2._destroyed)
            return;
          self2._resetTimers(true);
          self2.emit("error", new Error("XHR error"));
        };
        try {
          xhr.send(body);
        } catch (err) {
          process.nextTick(function() {
            self2.emit("error", err);
          });
          return;
        }
      }
    };
    function statusValid(xhr) {
      try {
        var status = xhr.status;
        return status !== null && status !== 0;
      } catch (e) {
        return false;
      }
    }
    ClientRequest.prototype._onXHRProgress = function() {
      var self2 = this;
      self2._resetTimers(false);
      if (!statusValid(self2._xhr) || self2._destroyed)
        return;
      if (!self2._response)
        self2._connect();
      self2._response._onXHRProgress(self2._resetTimers.bind(self2));
    };
    ClientRequest.prototype._connect = function() {
      var self2 = this;
      if (self2._destroyed)
        return;
      self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._resetTimers.bind(self2));
      self2._response.on("error", function(err) {
        self2.emit("error", err);
      });
      self2.emit("response", self2._response);
    };
    ClientRequest.prototype._write = function(chunk, encoding, cb) {
      var self2 = this;
      self2._body.push(chunk);
      cb();
    };
    ClientRequest.prototype._resetTimers = function(done) {
      var self2 = this;
      global.clearTimeout(self2._socketTimer);
      self2._socketTimer = null;
      if (done) {
        global.clearTimeout(self2._fetchTimer);
        self2._fetchTimer = null;
      } else if (self2._socketTimeout) {
        self2._socketTimer = global.setTimeout(function() {
          self2.emit("timeout");
        }, self2._socketTimeout);
      }
    };
    ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function(err) {
      var self2 = this;
      self2._destroyed = true;
      self2._resetTimers(true);
      if (self2._response)
        self2._response._destroyed = true;
      if (self2._xhr)
        self2._xhr.abort();
      else if (self2._fetchAbortController)
        self2._fetchAbortController.abort();
      if (err)
        self2.emit("error", err);
    };
    ClientRequest.prototype.end = function(data, encoding, cb) {
      var self2 = this;
      if (typeof data === "function") {
        cb = data;
        data = void 0;
      }
      stream.Writable.prototype.end.call(self2, data, encoding, cb);
    };
    ClientRequest.prototype.setTimeout = function(timeout, cb) {
      var self2 = this;
      if (cb)
        self2.once("timeout", cb);
      self2._socketTimeout = timeout;
      self2._resetTimers(false);
    };
    ClientRequest.prototype.flushHeaders = function() {
    };
    ClientRequest.prototype.setNoDelay = function() {
    };
    ClientRequest.prototype.setSocketKeepAlive = function() {
    };
    var unsafeHeaders = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "cookie",
      "cookie2",
      "date",
      "dnt",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "via"
    ];
  }
});

// node_modules/builtin-status-codes/browser.js
var require_browser2 = __commonJS({
  "node_modules/builtin-status-codes/browser.js"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    module.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/stream-http/index.js
var require_stream_http = __commonJS({
  "node_modules/stream-http/index.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var ClientRequest = require_request();
    var response = require_response();
    var extend = require_immutable();
    var statusCodes = require_browser2();
    var url = (init_url(), __toCommonJS(url_exports));
    var http = exports;
    http.request = function(opts, cb) {
      if (typeof opts === "string")
        opts = url.parse(opts);
      else
        opts = extend(opts);
      var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
      var protocol = opts.protocol || defaultProtocol;
      var host = opts.hostname || opts.host;
      var port = opts.port;
      var path = opts.path || "/";
      if (host && host.indexOf(":") !== -1)
        host = "[" + host + "]";
      opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
      opts.method = (opts.method || "GET").toUpperCase();
      opts.headers = opts.headers || {};
      var req = new ClientRequest(opts);
      if (cb)
        req.on("response", cb);
      return req;
    };
    http.get = function get(opts, cb) {
      var req = http.request(opts, cb);
      req.end();
      return req;
    };
    http.ClientRequest = ClientRequest;
    http.IncomingMessage = response.IncomingMessage;
    http.Agent = function() {
    };
    http.Agent.defaultMaxSockets = 4;
    http.globalAgent = new http.Agent();
    http.STATUS_CODES = statusCodes;
    http.METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
  }
});

// node_modules/https-browserify/index.js
var require_https_browserify = __commonJS({
  "node_modules/https-browserify/index.js"(exports, module) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var http = require_stream_http();
    var url = (init_url(), __toCommonJS(url_exports));
    var https = module.exports;
    for (key in http) {
      if (http.hasOwnProperty(key)) https[key] = http[key];
    }
    var key;
    https.request = function(params, cb) {
      params = validateParams(params);
      return http.request.call(this, params, cb);
    };
    https.get = function(params, cb) {
      params = validateParams(params);
      return http.get.call(this, params, cb);
    };
    function validateParams(params) {
      if (typeof params === "string") {
        params = url.parse(params);
      }
      if (!params.protocol) {
        params.protocol = "https:";
      }
      if (params.protocol !== "https:") {
        throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
      }
      return params;
    }
  }
});

// node_modules/ripple-lib/dist/npm/wallet/wallet-generation.js
var require_wallet_generation = __commonJS({
  "node_modules/ripple-lib/dist/npm/wallet/wallet-generation.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFaucetUrl = exports.FaucetNetwork = void 0;
    var https = require_https_browserify();
    var common_1 = require_common();
    var schema_validator_1 = require_schema_validator();
    var errors_1 = require_errors();
    var FaucetNetwork;
    (function(FaucetNetwork2) {
      FaucetNetwork2["Testnet"] = "faucet.altnet.rippletest.net";
      FaucetNetwork2["Devnet"] = "faucet.devnet.rippletest.net";
    })(FaucetNetwork = exports.FaucetNetwork || (exports.FaucetNetwork = {}));
    var INTERVAL_SECONDS = 1;
    var MAX_ATTEMPTS = 20;
    function generateFaucetWallet(address) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.isConnected())
          throw new errors_1.RippledError("RippleAPI not connected, cannot call faucet");
        let body;
        let startingBalance = 0;
        let faucetUrl = getFaucetUrl(this);
        if (address && schema_validator_1.isValidAddress(address)) {
          body = new TextEncoder().encode(JSON.stringify({
            destination: address
          }));
          const addressToFundBalance = yield getAddressXrpBalance(this, address);
          if (addressToFundBalance && !isNaN(+addressToFundBalance)) {
            startingBalance = +addressToFundBalance;
          } else {
            startingBalance = 0;
          }
        }
        const options = {
          hostname: faucetUrl,
          port: 443,
          path: "/accounts",
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Content-Length": body ? body.length : 0
          }
        };
        return new Promise((resolve2, reject) => {
          const request = https.request(options, (response) => {
            const chunks = [];
            response.on("data", (d) => {
              chunks.push(d);
            });
            response.on("end", () => __awaiter(this, void 0, void 0, function* () {
              const body2 = Buffer.concat(chunks).toString();
              if (response.headers["content-type"].startsWith("application/json")) {
                const wallet = JSON.parse(body2);
                const classicAddress = wallet.account.classicAddress;
                if (classicAddress) {
                  try {
                    const isFunded = yield hasAddressBalanceIncreased(this, classicAddress, startingBalance);
                    if (isFunded) {
                      resolve2(wallet);
                    } else {
                      reject(new common_1.errors.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`));
                    }
                  } catch (err) {
                    reject(new common_1.errors.XRPLFaucetError(err));
                  }
                } else {
                  reject(new common_1.errors.XRPLFaucetError(`The faucet account classic address is undefined`));
                }
              } else {
                reject({
                  statusCode: response.statusCode,
                  contentType: response.headers["content-type"],
                  body: body2
                });
              }
            }));
          });
          request.write(body ? body : "");
          request.on("error", (error) => {
            reject(error);
          });
          request.end();
        });
      });
    }
    function getAddressXrpBalance(api2, address) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const balances = yield api2.getBalances(address);
          const xrpBalance = balances.filter((balance) => balance.currency.toUpperCase() === "XRP");
          return xrpBalance[0].value;
        } catch (err) {
          return `Unable to retrieve ${address} balance. Error: ${err}`;
        }
      });
    }
    function hasAddressBalanceIncreased(api2, address, originalBalance) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve2, reject) => {
          let attempts = MAX_ATTEMPTS;
          const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            if (attempts < 0) {
              clearInterval(interval);
              resolve2(false);
            } else {
              attempts--;
            }
            try {
              const newBalance = +(yield getAddressXrpBalance(api2, address));
              if (newBalance > originalBalance) {
                clearInterval(interval);
                resolve2(true);
              }
            } catch (err) {
              clearInterval(interval);
              reject(new common_1.errors.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err}`));
            }
          }), INTERVAL_SECONDS * 1e3);
        });
      });
    }
    function getFaucetUrl(api2) {
      const connectionUrl = api2.connection.getUrl();
      if (connectionUrl.includes("altnet") || connectionUrl.includes("testnet")) {
        return FaucetNetwork.Testnet;
      }
      if (connectionUrl.includes("devnet")) {
        return FaucetNetwork.Devnet;
      }
      return void 0;
    }
    exports.getFaucetUrl = getFaucetUrl;
    exports.default = generateFaucetWallet;
  }
});

// node_modules/ripple-lib/dist/npm/api.js
var require_api = __commonJS({
  "node_modules/ripple-lib/dist/npm/api.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RippleAPI = void 0;
    var events_1 = require_events();
    var common_1 = require_common();
    var server_1 = require_server();
    var transaction_1 = __importDefault(require_transaction2());
    var transactions_1 = __importDefault(require_transactions());
    var trustlines_1 = __importDefault(require_trustlines());
    var balances_1 = __importDefault(require_balances());
    var balance_sheet_1 = __importDefault(require_balance_sheet());
    var pathfind_1 = __importDefault(require_pathfind2());
    var orders_1 = __importDefault(require_orders());
    var orderbook_1 = require_orderbook2();
    var settings_1 = require_settings3();
    var accountinfo_1 = __importDefault(require_accountinfo());
    var accountobjects_1 = __importDefault(require_accountobjects());
    var payment_channel_1 = __importDefault(require_payment_channel2());
    var payment_1 = __importDefault(require_payment3());
    var trustline_1 = __importDefault(require_trustline3());
    var order_1 = __importDefault(require_order3());
    var ordercancellation_1 = __importDefault(require_ordercancellation());
    var escrow_creation_1 = __importDefault(require_escrow_creation3());
    var escrow_execution_1 = __importDefault(require_escrow_execution3());
    var escrow_cancellation_1 = __importDefault(require_escrow_cancellation3());
    var payment_channel_create_1 = __importDefault(require_payment_channel_create3());
    var payment_channel_fund_1 = __importDefault(require_payment_channel_fund3());
    var payment_channel_claim_1 = __importDefault(require_payment_channel_claim3());
    var check_create_1 = __importDefault(require_check_create3());
    var check_cancel_1 = __importDefault(require_check_cancel3());
    var check_cash_1 = __importDefault(require_check_cash3());
    var settings_2 = __importDefault(require_settings4());
    var ticket_1 = __importDefault(require_ticket());
    var sign_1 = __importDefault(require_sign3());
    var combine_1 = __importDefault(require_combine2());
    var submit_1 = __importDefault(require_submit3());
    var utils_1 = require_utils9();
    var derive_1 = require_derive();
    var ledgerhash_1 = __importDefault(require_ledgerhash());
    var sign_payment_channel_claim_1 = __importDefault(require_sign_payment_channel_claim3());
    var verify_payment_channel_claim_1 = __importDefault(require_verify_payment_channel_claim3());
    var ledger_1 = __importDefault(require_ledger2());
    var rangeset_1 = __importDefault(require_rangeset());
    var ledgerUtils = __importStar(require_utils5());
    var transactionUtils = __importStar(require_utils8());
    var schemaValidator = __importStar(require_schema_validator());
    var serverinfo_1 = require_serverinfo();
    var utils_2 = require_utils5();
    var ripple_address_codec_1 = require_dist4();
    var hashes_1 = require_hashes2();
    var wallet_generation_1 = __importDefault(require_wallet_generation());
    function getCollectKeyFromCommand(command) {
      switch (command) {
        case "account_offers":
        case "book_offers":
          return "offers";
        case "account_lines":
          return "lines";
        default:
          return void 0;
      }
    }
    var RippleAPI = class extends events_1.EventEmitter {
      constructor(options = {}) {
        super();
        this.generateAddress = utils_1.generateAddress;
        this.generateXAddress = utils_1.generateXAddress;
        this.connect = server_1.connect;
        this.disconnect = server_1.disconnect;
        this.isConnected = server_1.isConnected;
        this.getServerInfo = serverinfo_1.getServerInfo;
        this.getFee = serverinfo_1.getFee;
        this.getLedgerVersion = server_1.getLedgerVersion;
        this.getTransaction = transaction_1.default;
        this.getTransactions = transactions_1.default;
        this.getTrustlines = trustlines_1.default;
        this.getBalances = balances_1.default;
        this.getBalanceSheet = balance_sheet_1.default;
        this.getPaths = pathfind_1.default;
        this.getOrderbook = orderbook_1.getOrderbook;
        this.getOrders = orders_1.default;
        this.getSettings = settings_1.getSettings;
        this.getAccountInfo = accountinfo_1.default;
        this.getAccountObjects = accountobjects_1.default;
        this.getPaymentChannel = payment_channel_1.default;
        this.getLedger = ledger_1.default;
        this.parseAccountFlags = settings_1.parseAccountFlags;
        this.preparePayment = payment_1.default;
        this.prepareTrustline = trustline_1.default;
        this.prepareOrder = order_1.default;
        this.prepareOrderCancellation = ordercancellation_1.default;
        this.prepareEscrowCreation = escrow_creation_1.default;
        this.prepareEscrowExecution = escrow_execution_1.default;
        this.prepareEscrowCancellation = escrow_cancellation_1.default;
        this.preparePaymentChannelCreate = payment_channel_create_1.default;
        this.preparePaymentChannelFund = payment_channel_fund_1.default;
        this.preparePaymentChannelClaim = payment_channel_claim_1.default;
        this.prepareCheckCreate = check_create_1.default;
        this.prepareCheckCash = check_cash_1.default;
        this.prepareCheckCancel = check_cancel_1.default;
        this.prepareTicketCreate = ticket_1.default;
        this.prepareSettings = settings_2.default;
        this.sign = sign_1.default;
        this.combine = combine_1.default;
        this.submit = submit_1.default;
        this.deriveKeypair = derive_1.deriveKeypair;
        this.deriveAddress = derive_1.deriveAddress;
        this.computeLedgerHash = ledgerhash_1.default;
        this.signPaymentChannelClaim = sign_payment_channel_claim_1.default;
        this.verifyPaymentChannelClaim = verify_payment_channel_claim_1.default;
        this.generateFaucetWallet = wallet_generation_1.default;
        this.errors = common_1.errors;
        this.xrpToDrops = common_1.xrpToDrops;
        this.dropsToXrp = common_1.dropsToXrp;
        this.rippleTimeToISO8601 = common_1.rippleTimeToISO8601;
        this.iso8601ToRippleTime = common_1.iso8601ToRippleTime;
        this.txFlags = common_1.txFlags;
        this.accountSetFlags = common_1.constants.AccountSetFlags;
        this.isValidAddress = schemaValidator.isValidAddress;
        this.isValidSecret = schemaValidator.isValidSecret;
        common_1.validate.apiOptions(options);
        this._feeCushion = options.feeCushion || 1.2;
        this._maxFeeXRP = options.maxFeeXRP || "2";
        const serverURL = options.server;
        if (serverURL != null) {
          this.connection = new common_1.Connection(serverURL, options);
          this.connection.on("ledgerClosed", (message) => {
            this.emit("ledger", server_1.formatLedgerClose(message));
          });
          this.connection.on("error", (errorCode, errorMessage, data) => {
            this.emit("error", errorCode, errorMessage, data);
          });
          this.connection.on("connected", () => {
            this.emit("connected");
          });
          this.connection.on("disconnected", (code) => {
            let finalCode = code;
            if (finalCode === 1005 || finalCode === 4e3) {
              finalCode = 1e3;
            }
            this.emit("disconnected", finalCode);
          });
        } else {
          this.connection = new common_1.Connection(null, options);
        }
      }
      request(command, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.connection.request(Object.assign(Object.assign({}, params), { command, account: params.account ? common_1.ensureClassicAddress(params.account) : void 0 }));
        });
      }
      hasNextPage(currentResponse) {
        return !!currentResponse.marker;
      }
      requestNextPage(command, params = {}, currentResponse) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!currentResponse.marker) {
            return Promise.reject(new common_1.errors.NotFoundError("response does not have a next page"));
          }
          const nextPageParams = Object.assign({}, params, {
            marker: currentResponse.marker
          });
          return this.request(command, nextPageParams);
        });
      }
      prepareTransaction(txJSON, instructions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          return transactionUtils.prepareTransaction(txJSON, this, instructions);
        });
      }
      convertStringToHex(string) {
        return transactionUtils.convertStringToHex(string);
      }
      _requestAll(command, params = {}, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const collectKey = options.collect || getCollectKeyFromCommand(command);
          if (!collectKey) {
            throw new common_1.errors.ValidationError(`no collect key for command ${command}`);
          }
          const countTo = params.limit != null ? params.limit : Infinity;
          let count = 0;
          let marker = params.marker;
          let lastBatchLength;
          const results = [];
          do {
            const countRemaining = utils_2.clamp(countTo - count, 10, 400);
            const repeatProps = Object.assign(Object.assign({}, params), { limit: countRemaining, marker });
            const singleResult = yield this.request(command, repeatProps);
            const collectedData = singleResult[collectKey];
            marker = singleResult["marker"];
            results.push(singleResult);
            const isExpectedFormat = Array.isArray(collectedData);
            if (isExpectedFormat) {
              count += collectedData.length;
              lastBatchLength = collectedData.length;
            } else {
              lastBatchLength = 0;
            }
          } while (!!marker && count < countTo && lastBatchLength !== 0);
          return results;
        });
      }
    };
    exports.RippleAPI = RippleAPI;
    RippleAPI._PRIVATE = {
      validate: common_1.validate,
      RangeSet: rangeset_1.default,
      ledgerUtils,
      schemaValidator
    };
    RippleAPI.renameCounterpartyToIssuer = utils_2.renameCounterpartyToIssuer;
    RippleAPI.formatBidsAndAsks = orderbook_1.formatBidsAndAsks;
    RippleAPI.deriveXAddress = derive_1.deriveXAddress;
    RippleAPI.deriveClassicAddress = derive_1.deriveAddress;
    RippleAPI.classicAddressToXAddress = ripple_address_codec_1.classicAddressToXAddress;
    RippleAPI.xAddressToClassicAddress = ripple_address_codec_1.xAddressToClassicAddress;
    RippleAPI.isValidXAddress = ripple_address_codec_1.isValidXAddress;
    RippleAPI.isValidClassicAddress = ripple_address_codec_1.isValidClassicAddress;
    RippleAPI.encodeSeed = ripple_address_codec_1.encodeSeed;
    RippleAPI.decodeSeed = ripple_address_codec_1.decodeSeed;
    RippleAPI.encodeAccountID = ripple_address_codec_1.encodeAccountID;
    RippleAPI.decodeAccountID = ripple_address_codec_1.decodeAccountID;
    RippleAPI.encodeNodePublic = ripple_address_codec_1.encodeNodePublic;
    RippleAPI.decodeNodePublic = ripple_address_codec_1.decodeNodePublic;
    RippleAPI.encodeAccountPublic = ripple_address_codec_1.encodeAccountPublic;
    RippleAPI.decodeAccountPublic = ripple_address_codec_1.decodeAccountPublic;
    RippleAPI.encodeXAddress = ripple_address_codec_1.encodeXAddress;
    RippleAPI.decodeXAddress = ripple_address_codec_1.decodeXAddress;
    RippleAPI.computeBinaryTransactionHash = hashes_1.computeBinaryTransactionHash;
    RippleAPI.computeTransactionHash = hashes_1.computeTransactionHash;
    RippleAPI.computeBinaryTransactionSigningHash = hashes_1.computeBinaryTransactionSigningHash;
    RippleAPI.computeAccountLedgerObjectID = hashes_1.computeAccountLedgerObjectID;
    RippleAPI.computeSignerListLedgerObjectID = hashes_1.computeSignerListLedgerObjectID;
    RippleAPI.computeOrderID = hashes_1.computeOrderID;
    RippleAPI.computeTrustlineHash = hashes_1.computeTrustlineHash;
    RippleAPI.computeTransactionTreeHash = hashes_1.computeTransactionTreeHash;
    RippleAPI.computeStateTreeHash = hashes_1.computeStateTreeHash;
    RippleAPI.computeLedgerHash = ledgerhash_1.default;
    RippleAPI.computeEscrowHash = hashes_1.computeEscrowHash;
    RippleAPI.computePaymentChannelHash = hashes_1.computePaymentChannelHash;
    RippleAPI.txFlags = common_1.txFlags;
    RippleAPI.accountSetFlags = common_1.constants.AccountSetFlags;
  }
});

// node_modules/ripple-lib/dist/npm/transaction/types.js
var require_types2 = __commonJS({
  "node_modules/ripple-lib/dist/npm/transaction/types.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ripple-lib/dist/npm/common/types/objects/ledger.js
var require_ledger3 = __commonJS({
  "node_modules/ripple-lib/dist/npm/common/types/objects/ledger.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/ripple-lib/dist/npm/broadcast.js
var require_broadcast = __commonJS({
  "node_modules/ripple-lib/dist/npm/broadcast.js"(exports) {
    "use strict";
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RippleAPIBroadcast = void 0;
    var api_1 = require_api();
    var RippleAPIBroadcast = class extends api_1.RippleAPI {
      constructor(servers, options = {}) {
        super(options);
        this.ledgerVersion = void 0;
        const apis = servers.map((server) => new api_1.RippleAPI(Object.assign({}, options, { server })));
        this._apis = apis;
        this.getMethodNames().forEach((name) => {
          this[name] = function() {
            return Promise.race(apis.map((api2) => api2[name](...arguments)));
          };
        });
        this.connect = function() {
          return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(apis.map((api2) => api2.connect()));
          });
        };
        this.disconnect = function() {
          return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(apis.map((api2) => api2.disconnect()));
          });
        };
        this.isConnected = function() {
          return apis.map((api2) => api2.isConnected()).every(Boolean);
        };
        const defaultAPI = apis[0];
        const syncMethods = ["sign", "generateAddress", "computeLedgerHash"];
        syncMethods.forEach((name) => {
          this[name] = defaultAPI[name].bind(defaultAPI);
        });
        apis.forEach((api2) => {
          api2.on("ledger", this.onLedgerEvent.bind(this));
          api2.on("error", (errorCode, errorMessage, data) => this.emit("error", errorCode, errorMessage, data));
        });
      }
      onLedgerEvent(ledger) {
        if (ledger.ledgerVersion > this.ledgerVersion || this.ledgerVersion == null) {
          this.ledgerVersion = ledger.ledgerVersion;
          this.emit("ledger", ledger);
        }
      }
      getMethodNames() {
        const methodNames = [];
        const rippleAPI = this._apis[0];
        for (const name of Object.getOwnPropertyNames(rippleAPI)) {
          if (typeof rippleAPI[name] === "function") {
            methodNames.push(name);
          }
        }
        return methodNames;
      }
    };
    exports.RippleAPIBroadcast = RippleAPIBroadcast;
  }
});

// node_modules/ripple-lib/dist/npm/index.js
var require_npm = __commonJS({
  "node_modules/ripple-lib/dist/npm/index.js"(exports) {
    var import_dist4 = __toESM(require_dist());
    var import_dist5 = __toESM(require_dist2());
    var import_dist6 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !exports2.hasOwnProperty(p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_api(), exports);
    __exportStar(require_types2(), exports);
    __exportStar(require_ledger3(), exports);
    __exportStar(require_utils9(), exports);
    var broadcast_1 = require_broadcast();
    Object.defineProperty(exports, "RippleAPIBroadcast", { enumerable: true, get: function() {
      return broadcast_1.RippleAPIBroadcast;
    } });
  }
});
export default require_npm();
/*! Bundled license information:

assert/build/internal/util/comparisons.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)

decimal.js/decimal.js:
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
//# sourceMappingURL=ripple-lib.js.map
