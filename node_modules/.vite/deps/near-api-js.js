import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_immutable
} from "./chunk-MWTTE2MT.js";
import {
  require_browser,
  require_commonjs,
  require_commonjs2,
  require_commonjs3,
  require_key_pair
} from "./chunk-RB7NSKI6.js";
import "./chunk-JYDJ66VN.js";
import "./chunk-NUR4LEB5.js";
import "./chunk-N6JDCBV6.js";
import "./chunk-WGA7U3VS.js";
import "./chunk-I4BR23GQ.js";
import "./chunk-M5IBZDAP.js";
import "./chunk-CDUUVO7V.js";
import "./chunk-BR4MBQ57.js";
import "./chunk-LCOOFUYL.js";
import "./chunk-A6A3TVJO.js";
import "./chunk-RKLWBVCN.js";
import "./chunk-LWZV2KFL.js";
import "./chunk-BHJJSHP2.js";
import {
  require_util
} from "./chunk-JGI3UVAJ.js";
import "./chunk-FU55H4EU.js";
import "./chunk-PSMAFUOK.js";
import "./chunk-SVJFUM6P.js";
import "./chunk-A4DENNXW.js";
import "./chunk-3PLQ733S.js";
import "./chunk-WKI7UJOK.js";
import {
  __commonJS,
  __publicField,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-W7YBHVXA.js";

// node_modules/@near-js/keystores/lib/commonjs/keystore.cjs
var require_keystore = __commonJS({
  "node_modules/@near-js/keystores/lib/commonjs/keystore.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyStore = void 0;
    var KeyStore = class {
    };
    exports.KeyStore = KeyStore;
  }
});

// node_modules/@near-js/keystores/lib/commonjs/in_memory_key_store.cjs
var require_in_memory_key_store = __commonJS({
  "node_modules/@near-js/keystores/lib/commonjs/in_memory_key_store.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InMemoryKeyStore = void 0;
    var crypto_1 = require_commonjs3();
    var keystore_1 = require_keystore();
    var InMemoryKeyStore = class extends keystore_1.KeyStore {
      constructor() {
        super();
        /** @hidden */
        __publicField(this, "keys");
        this.keys = {};
      }
      /**
       * Stores a {@link KeyPair} in in-memory storage item
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       * @param keyPair The key pair to store in local storage
       */
      async setKey(networkId, accountId, keyPair) {
        this.keys[`${accountId}:${networkId}`] = keyPair.toString();
      }
      /**
       * Gets a {@link KeyPair} from in-memory storage
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       * @returns {Promise<KeyPair>}
       */
      async getKey(networkId, accountId) {
        const value = this.keys[`${accountId}:${networkId}`];
        if (!value) {
          return null;
        }
        return crypto_1.KeyPair.fromString(value);
      }
      /**
       * Removes a {@link KeyPair} from in-memory storage
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       */
      async removeKey(networkId, accountId) {
        delete this.keys[`${accountId}:${networkId}`];
      }
      /**
       * Removes all {@link KeyPair} from in-memory storage
       */
      async clear() {
        this.keys = {};
      }
      /**
       * Get the network(s) from in-memory storage
       * @returns {Promise<string[]>}
       */
      async getNetworks() {
        const result = /* @__PURE__ */ new Set();
        Object.keys(this.keys).forEach((key) => {
          const parts = key.split(":");
          result.add(parts[1]);
        });
        return Array.from(result.values());
      }
      /**
       * Gets the account(s) from in-memory storage
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       */
      async getAccounts(networkId) {
        const result = new Array();
        Object.keys(this.keys).forEach((key) => {
          const parts = key.split(":");
          if (parts[parts.length - 1] === networkId) {
            result.push(parts.slice(0, parts.length - 1).join(":"));
          }
        });
        return result;
      }
      /** @hidden */
      toString() {
        return "InMemoryKeyStore";
      }
    };
    exports.InMemoryKeyStore = InMemoryKeyStore;
  }
});

// node_modules/@near-js/keystores/lib/commonjs/merge_key_store.cjs
var require_merge_key_store = __commonJS({
  "node_modules/@near-js/keystores/lib/commonjs/merge_key_store.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MergeKeyStore = void 0;
    var keystore_1 = require_keystore();
    var MergeKeyStore = class extends keystore_1.KeyStore {
      /**
       * @param keyStores read calls are attempted from start to end of array
       * @param options KeyStore options
       * @param options.writeKeyStoreIndex the keystore index that will receive all write calls
       */
      constructor(keyStores, options = { writeKeyStoreIndex: 0 }) {
        super();
        __publicField(this, "options");
        __publicField(this, "keyStores");
        this.options = options;
        this.keyStores = keyStores;
      }
      /**
       * Store a {@link KeyPair} to the first index of a key store array
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       * @param keyPair The key pair to store in local storage
       */
      async setKey(networkId, accountId, keyPair) {
        await this.keyStores[this.options.writeKeyStoreIndex].setKey(networkId, accountId, keyPair);
      }
      /**
       * Gets a {@link KeyPair} from the array of key stores
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       * @returns {Promise<KeyPair>}
       */
      async getKey(networkId, accountId) {
        for (const keyStore of this.keyStores) {
          const keyPair = await keyStore.getKey(networkId, accountId);
          if (keyPair) {
            return keyPair;
          }
        }
        return null;
      }
      /**
       * Removes a {@link KeyPair} from the array of key stores
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       */
      async removeKey(networkId, accountId) {
        for (const keyStore of this.keyStores) {
          await keyStore.removeKey(networkId, accountId);
        }
      }
      /**
       * Removes all items from each key store
       */
      async clear() {
        for (const keyStore of this.keyStores) {
          await keyStore.clear();
        }
      }
      /**
       * Get the network(s) from the array of key stores
       * @returns {Promise<string[]>}
       */
      async getNetworks() {
        const result = /* @__PURE__ */ new Set();
        for (const keyStore of this.keyStores) {
          for (const network of await keyStore.getNetworks()) {
            result.add(network);
          }
        }
        return Array.from(result);
      }
      /**
       * Gets the account(s) from the array of key stores
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       */
      async getAccounts(networkId) {
        const result = /* @__PURE__ */ new Set();
        for (const keyStore of this.keyStores) {
          for (const account of await keyStore.getAccounts(networkId)) {
            result.add(account);
          }
        }
        return Array.from(result);
      }
      /** @hidden */
      toString() {
        return `MergeKeyStore(${this.keyStores.join(", ")})`;
      }
    };
    exports.MergeKeyStore = MergeKeyStore;
  }
});

// node_modules/@near-js/keystores/lib/commonjs/multi_contract_keystore.cjs
var require_multi_contract_keystore = __commonJS({
  "node_modules/@near-js/keystores/lib/commonjs/multi_contract_keystore.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiContractKeyStore = void 0;
    var MultiContractKeyStore = class {
    };
    exports.MultiContractKeyStore = MultiContractKeyStore;
  }
});

// node_modules/@near-js/keystores/lib/commonjs/index.cjs
var require_commonjs4 = __commonJS({
  "node_modules/@near-js/keystores/lib/commonjs/index.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiContractKeyStore = exports.MergeKeyStore = exports.KeyStore = exports.InMemoryKeyStore = void 0;
    var in_memory_key_store_1 = require_in_memory_key_store();
    Object.defineProperty(exports, "InMemoryKeyStore", { enumerable: true, get: function() {
      return in_memory_key_store_1.InMemoryKeyStore;
    } });
    var keystore_1 = require_keystore();
    Object.defineProperty(exports, "KeyStore", { enumerable: true, get: function() {
      return keystore_1.KeyStore;
    } });
    var merge_key_store_1 = require_merge_key_store();
    Object.defineProperty(exports, "MergeKeyStore", { enumerable: true, get: function() {
      return merge_key_store_1.MergeKeyStore;
    } });
    var multi_contract_keystore_1 = require_multi_contract_keystore();
    Object.defineProperty(exports, "MultiContractKeyStore", { enumerable: true, get: function() {
      return multi_contract_keystore_1.MultiContractKeyStore;
    } });
  }
});

// node_modules/near-api-js/lib/key_stores/keystore.js
var require_keystore2 = __commonJS({
  "node_modules/near-api-js/lib/key_stores/keystore.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyStore = void 0;
    var keystores_1 = require_commonjs4();
    Object.defineProperty(exports, "KeyStore", { enumerable: true, get: function() {
      return keystores_1.KeyStore;
    } });
  }
});

// node_modules/near-api-js/lib/key_stores/in_memory_key_store.js
var require_in_memory_key_store2 = __commonJS({
  "node_modules/near-api-js/lib/key_stores/in_memory_key_store.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InMemoryKeyStore = void 0;
    var keystores_1 = require_commonjs4();
    Object.defineProperty(exports, "InMemoryKeyStore", { enumerable: true, get: function() {
      return keystores_1.InMemoryKeyStore;
    } });
  }
});

// node_modules/@near-js/keystores-browser/lib/commonjs/browser_local_storage_key_store.cjs
var require_browser_local_storage_key_store = __commonJS({
  "node_modules/@near-js/keystores-browser/lib/commonjs/browser_local_storage_key_store.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserLocalStorageKeyStore = void 0;
    var crypto_1 = require_commonjs3();
    var keystores_1 = require_commonjs4();
    var LOCAL_STORAGE_KEY_PREFIX = "near-api-js:keystore:";
    var BrowserLocalStorageKeyStore = class extends keystores_1.KeyStore {
      /**
       * @param localStorage defaults to window.localStorage
       * @param prefix defaults to `near-api-js:keystore:`
       */
      constructor(localStorage = window.localStorage, prefix = LOCAL_STORAGE_KEY_PREFIX) {
        super();
        /** @hidden */
        __publicField(this, "localStorage");
        /** @hidden */
        __publicField(this, "prefix");
        this.localStorage = localStorage;
        this.prefix = prefix;
      }
      /**
       * Stores a {@link KeyPair} in local storage.
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       * @param keyPair The key pair to store in local storage
       */
      async setKey(networkId, accountId, keyPair) {
        this.localStorage.setItem(this.storageKeyForSecretKey(networkId, accountId), keyPair.toString());
      }
      /**
       * Gets a {@link KeyPair} from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       * @returns {Promise<KeyPair>}
       */
      async getKey(networkId, accountId) {
        const value = this.localStorage.getItem(this.storageKeyForSecretKey(networkId, accountId));
        if (!value) {
          return null;
        }
        return crypto_1.KeyPair.fromString(value);
      }
      /**
       * Removes a {@link KeyPair} from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       */
      async removeKey(networkId, accountId) {
        this.localStorage.removeItem(this.storageKeyForSecretKey(networkId, accountId));
      }
      /**
       * Removes all items that start with `prefix` from local storage
       */
      async clear() {
        for (const key of this.storageKeys()) {
          if (key.startsWith(this.prefix)) {
            this.localStorage.removeItem(key);
          }
        }
      }
      /**
       * Get the network(s) from local storage
       * @returns {Promise<string[]>}
       */
      async getNetworks() {
        const result = /* @__PURE__ */ new Set();
        for (const key of this.storageKeys()) {
          if (key.startsWith(this.prefix)) {
            const parts = key.substring(this.prefix.length).split(":");
            result.add(parts[1]);
          }
        }
        return Array.from(result.values());
      }
      /**
       * Gets the account(s) from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       */
      async getAccounts(networkId) {
        const result = new Array();
        for (const key of this.storageKeys()) {
          if (key.startsWith(this.prefix)) {
            const parts = key.substring(this.prefix.length).split(":");
            if (parts[1] === networkId) {
              result.push(parts[0]);
            }
          }
        }
        return result;
      }
      /**
       * @hidden
       * Helper function to retrieve a local storage key
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the storage key that's sought
       * @returns {string} An example might be: `near-api-js:keystore:near-friend:default`
       */
      storageKeyForSecretKey(networkId, accountId) {
        return `${this.prefix}${accountId}:${networkId}`;
      }
      /** @hidden */
      *storageKeys() {
        for (let i = 0; i < this.localStorage.length; i++) {
          yield this.localStorage.key(i);
        }
      }
    };
    exports.BrowserLocalStorageKeyStore = BrowserLocalStorageKeyStore;
  }
});

// node_modules/@near-js/keystores-browser/lib/commonjs/multi_contract_browser_local_storage_key_store.cjs
var require_multi_contract_browser_local_storage_key_store = __commonJS({
  "node_modules/@near-js/keystores-browser/lib/commonjs/multi_contract_browser_local_storage_key_store.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiContractBrowserLocalStorageKeyStore = void 0;
    var crypto_1 = require_commonjs3();
    var keystores_1 = require_commonjs4();
    var LOCAL_STORAGE_KEY_PREFIX = "near-api-js:keystore:";
    var MultiContractBrowserLocalStorageKeyStore = class extends keystores_1.MultiContractKeyStore {
      /**
       * @param localStorage defaults to window.localStorage
       * @param prefix defaults to `near-api-js:keystore:`
       */
      constructor(localStorage = window.localStorage, prefix = LOCAL_STORAGE_KEY_PREFIX) {
        super();
        /** @hidden */
        __publicField(this, "localStorage");
        /** @hidden */
        __publicField(this, "prefix");
        this.localStorage = localStorage;
        this.prefix = prefix || LOCAL_STORAGE_KEY_PREFIX;
      }
      /**
       * Stores a {@link utils/key_pair!KeyPair} in local storage.
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       * @param keyPair The key pair to store in local storage
       * @param contractId The contract to store in local storage
       */
      async setKey(networkId, accountId, keyPair, contractId) {
        this.localStorage.setItem(this.storageKeyForSecretKey(networkId, accountId, contractId), keyPair.toString());
      }
      /**
       * Gets a {@link utils/key_pair!KeyPair} from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       * @param contractId The NEAR contract tied to the key pair
       * @returns {Promise<KeyPair>}
       */
      async getKey(networkId, accountId, contractId) {
        const value = this.localStorage.getItem(this.storageKeyForSecretKey(networkId, accountId, contractId));
        if (!value) {
          return null;
        }
        return crypto_1.KeyPair.fromString(value);
      }
      /**
       * Removes a {@link utils/key_pair!KeyPair} from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the key pair
       * @param contractId The NEAR contract tied to the key pair
       */
      async removeKey(networkId, accountId, contractId) {
        this.localStorage.removeItem(this.storageKeyForSecretKey(networkId, accountId, contractId));
      }
      /**
       * Removes all items that start with `prefix` from local storage
       */
      async clear() {
        for (const key of this.storageKeys()) {
          if (key.startsWith(this.prefix)) {
            this.localStorage.removeItem(key);
          }
        }
      }
      /**
       * Get the network(s) from local storage
       * @returns {Promise<string[]>}
       */
      async getNetworks() {
        const result = /* @__PURE__ */ new Set();
        for (const key of this.storageKeys()) {
          if (key.startsWith(this.prefix)) {
            const parts = key.substring(this.prefix.length).split(":");
            result.add(parts[1]);
          }
        }
        return Array.from(result.values());
      }
      /**
       * Gets the account(s) from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       */
      async getAccounts(networkId) {
        const result = [];
        for (const key of this.storageKeys()) {
          if (key.startsWith(this.prefix)) {
            const parts = key.substring(this.prefix.length).split(":");
            if (parts[1] === networkId) {
              result.push(parts[0]);
            }
          }
        }
        return result;
      }
      /**
       * Gets the contract(s) from local storage
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The targeted account.
       */
      async getContracts(networkId, accountId) {
        const result = [];
        for (const key of this.storageKeys()) {
          if (key.startsWith(this.prefix)) {
            const parts = key.substring(this.prefix.length).split(":");
            if (parts[1] === networkId && parts[0] === accountId) {
              result.push(parts[2]);
            }
          }
        }
        return result;
      }
      /**
       * @hidden
       * Helper function to retrieve a local storage key
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account tied to the storage keythat's sought
       * @param contractId The NEAR contract tied to the storage keythat's sought
       * @returns {string} An example might be: `near-api-js:keystore:near-friend:default`
       */
      storageKeyForSecretKey(networkId, accountId, contractId) {
        return `${this.prefix}${accountId}:${networkId}:${contractId}`;
      }
      /** @hidden */
      *storageKeys() {
        for (let i = 0; i < this.localStorage.length; i++) {
          yield this.localStorage.key(i);
        }
      }
    };
    exports.MultiContractBrowserLocalStorageKeyStore = MultiContractBrowserLocalStorageKeyStore;
  }
});

// node_modules/@near-js/keystores-browser/lib/commonjs/index.cjs
var require_commonjs5 = __commonJS({
  "node_modules/@near-js/keystores-browser/lib/commonjs/index.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiContractBrowserLocalStorageKeyStore = exports.BrowserLocalStorageKeyStore = void 0;
    var browser_local_storage_key_store_1 = require_browser_local_storage_key_store();
    Object.defineProperty(exports, "BrowserLocalStorageKeyStore", { enumerable: true, get: function() {
      return browser_local_storage_key_store_1.BrowserLocalStorageKeyStore;
    } });
    var multi_contract_browser_local_storage_key_store_1 = require_multi_contract_browser_local_storage_key_store();
    Object.defineProperty(exports, "MultiContractBrowserLocalStorageKeyStore", { enumerable: true, get: function() {
      return multi_contract_browser_local_storage_key_store_1.MultiContractBrowserLocalStorageKeyStore;
    } });
  }
});

// node_modules/near-api-js/lib/key_stores/browser_local_storage_key_store.js
var require_browser_local_storage_key_store2 = __commonJS({
  "node_modules/near-api-js/lib/key_stores/browser_local_storage_key_store.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserLocalStorageKeyStore = void 0;
    var keystores_browser_1 = require_commonjs5();
    Object.defineProperty(exports, "BrowserLocalStorageKeyStore", { enumerable: true, get: function() {
      return keystores_browser_1.BrowserLocalStorageKeyStore;
    } });
  }
});

// node_modules/near-api-js/lib/key_stores/merge_key_store.js
var require_merge_key_store2 = __commonJS({
  "node_modules/near-api-js/lib/key_stores/merge_key_store.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MergeKeyStore = void 0;
    var keystores_1 = require_commonjs4();
    Object.defineProperty(exports, "MergeKeyStore", { enumerable: true, get: function() {
      return keystores_1.MergeKeyStore;
    } });
  }
});

// node_modules/near-api-js/lib/key_stores/browser-index.js
var require_browser_index = __commonJS({
  "node_modules/near-api-js/lib/key_stores/browser-index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MergeKeyStore = exports.BrowserLocalStorageKeyStore = exports.InMemoryKeyStore = exports.KeyStore = void 0;
    var keystore_1 = require_keystore2();
    Object.defineProperty(exports, "KeyStore", { enumerable: true, get: function() {
      return keystore_1.KeyStore;
    } });
    var in_memory_key_store_1 = require_in_memory_key_store2();
    Object.defineProperty(exports, "InMemoryKeyStore", { enumerable: true, get: function() {
      return in_memory_key_store_1.InMemoryKeyStore;
    } });
    var browser_local_storage_key_store_1 = require_browser_local_storage_key_store2();
    Object.defineProperty(exports, "BrowserLocalStorageKeyStore", { enumerable: true, get: function() {
      return browser_local_storage_key_store_1.BrowserLocalStorageKeyStore;
    } });
    var merge_key_store_1 = require_merge_key_store2();
    Object.defineProperty(exports, "MergeKeyStore", { enumerable: true, get: function() {
      return merge_key_store_1.MergeKeyStore;
    } });
  }
});

// node_modules/@near-js/providers/lib/commonjs/exponential-backoff.cjs
var require_exponential_backoff = __commonJS({
  "node_modules/@near-js/providers/lib/commonjs/exponential-backoff.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exponentialBackoff = void 0;
    async function exponentialBackoff(startWaitTime, retryNumber, waitBackoff, getResult) {
      let waitTime = startWaitTime;
      for (let i = 0; i < retryNumber; i++) {
        const result = await getResult();
        if (result) {
          return result;
        }
        await sleep(waitTime);
        waitTime *= waitBackoff;
      }
      return null;
    }
    exports.exponentialBackoff = exponentialBackoff;
    function sleep(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
  }
});

// node_modules/@near-js/transactions/lib/commonjs/actions.cjs
var require_actions = __commonJS({
  "node_modules/@near-js/transactions/lib/commonjs/actions.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Action = exports.SignedDelegate = exports.DeleteAccount = exports.DeleteKey = exports.AddKey = exports.Stake = exports.Transfer = exports.FunctionCall = exports.DeployContract = exports.CreateAccount = exports.AccessKey = exports.AccessKeyPermission = exports.FullAccessPermission = exports.FunctionCallPermission = void 0;
    var types_1 = require_commonjs();
    var FunctionCallPermission = class {
      constructor({ allowance, receiverId, methodNames }) {
        __publicField(this, "allowance");
        __publicField(this, "receiverId");
        __publicField(this, "methodNames");
        this.allowance = allowance;
        this.receiverId = receiverId;
        this.methodNames = methodNames;
      }
    };
    exports.FunctionCallPermission = FunctionCallPermission;
    var FullAccessPermission = class {
    };
    exports.FullAccessPermission = FullAccessPermission;
    var AccessKeyPermission = class extends types_1.Enum {
      constructor(props) {
        super(props);
        __publicField(this, "enum");
        __publicField(this, "functionCall");
        __publicField(this, "fullAccess");
        for (const [k, v] of Object.entries(props || {})) {
          this[k] = v;
          this.enum = k;
        }
      }
    };
    exports.AccessKeyPermission = AccessKeyPermission;
    var AccessKey = class {
      constructor({ nonce, permission }) {
        __publicField(this, "nonce");
        __publicField(this, "permission");
        this.nonce = nonce;
        this.permission = permission;
      }
    };
    exports.AccessKey = AccessKey;
    var CreateAccount = class {
    };
    exports.CreateAccount = CreateAccount;
    var DeployContract = class {
      constructor({ code }) {
        __publicField(this, "code");
        this.code = code;
      }
    };
    exports.DeployContract = DeployContract;
    var FunctionCall = class {
      constructor({ methodName, args, gas, deposit }) {
        __publicField(this, "methodName");
        __publicField(this, "args");
        __publicField(this, "gas");
        __publicField(this, "deposit");
        this.methodName = methodName;
        this.args = args;
        this.gas = gas;
        this.deposit = deposit;
      }
    };
    exports.FunctionCall = FunctionCall;
    var Transfer = class {
      constructor({ deposit }) {
        __publicField(this, "deposit");
        this.deposit = deposit;
      }
    };
    exports.Transfer = Transfer;
    var Stake = class {
      constructor({ stake, publicKey }) {
        __publicField(this, "stake");
        __publicField(this, "publicKey");
        this.stake = stake;
        this.publicKey = publicKey;
      }
    };
    exports.Stake = Stake;
    var AddKey = class {
      constructor({ publicKey, accessKey }) {
        __publicField(this, "publicKey");
        __publicField(this, "accessKey");
        this.publicKey = publicKey;
        this.accessKey = accessKey;
      }
    };
    exports.AddKey = AddKey;
    var DeleteKey = class {
      constructor({ publicKey }) {
        __publicField(this, "publicKey");
        this.publicKey = publicKey;
      }
    };
    exports.DeleteKey = DeleteKey;
    var DeleteAccount = class {
      constructor({ beneficiaryId }) {
        __publicField(this, "beneficiaryId");
        this.beneficiaryId = beneficiaryId;
      }
    };
    exports.DeleteAccount = DeleteAccount;
    var SignedDelegate = class {
      constructor({ delegateAction, signature }) {
        __publicField(this, "delegateAction");
        __publicField(this, "signature");
        this.delegateAction = delegateAction;
        this.signature = signature;
      }
    };
    exports.SignedDelegate = SignedDelegate;
    var Action = class extends types_1.Enum {
      constructor(props) {
        super(props);
        __publicField(this, "enum");
        __publicField(this, "createAccount");
        __publicField(this, "deployContract");
        __publicField(this, "functionCall");
        __publicField(this, "transfer");
        __publicField(this, "stake");
        __publicField(this, "addKey");
        __publicField(this, "deleteKey");
        __publicField(this, "deleteAccount");
        __publicField(this, "signedDelegate");
        for (const [k, v] of Object.entries(props || {})) {
          this[k] = v;
          this.enum = k;
        }
      }
    };
    exports.Action = Action;
  }
});

// node_modules/@near-js/transactions/lib/commonjs/action_creators.cjs
var require_action_creators = __commonJS({
  "node_modules/@near-js/transactions/lib/commonjs/action_creators.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.actionCreators = exports.stringifyJsonOrBytes = void 0;
    var actions_1 = require_actions();
    function fullAccessKey() {
      return new actions_1.AccessKey({
        nonce: 0n,
        permission: new actions_1.AccessKeyPermission({
          fullAccess: new actions_1.FullAccessPermission()
        })
      });
    }
    function functionCallAccessKey(receiverId, methodNames, allowance) {
      return new actions_1.AccessKey({
        nonce: 0n,
        permission: new actions_1.AccessKeyPermission({
          functionCall: new actions_1.FunctionCallPermission({
            receiverId,
            allowance,
            methodNames
          })
        })
      });
    }
    function createAccount() {
      return new actions_1.Action({ createAccount: new actions_1.CreateAccount() });
    }
    function deployContract(code) {
      return new actions_1.Action({ deployContract: new actions_1.DeployContract({ code }) });
    }
    function stringifyJsonOrBytes(args) {
      const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
      return isUint8Array ? args : Buffer.from(JSON.stringify(args));
    }
    exports.stringifyJsonOrBytes = stringifyJsonOrBytes;
    function functionCall(methodName, args, gas = 0n, deposit = 0n, stringify = stringifyJsonOrBytes, jsContract = false) {
      if (jsContract) {
        return new actions_1.Action({
          functionCall: new actions_1.FunctionCall({ methodName, args, gas, deposit })
        });
      }
      return new actions_1.Action({
        functionCall: new actions_1.FunctionCall({
          methodName,
          args: stringify(args),
          gas,
          deposit
        })
      });
    }
    function transfer(deposit = 0n) {
      return new actions_1.Action({ transfer: new actions_1.Transfer({ deposit }) });
    }
    function stake(stake2 = 0n, publicKey) {
      return new actions_1.Action({ stake: new actions_1.Stake({ stake: stake2, publicKey }) });
    }
    function addKey(publicKey, accessKey) {
      return new actions_1.Action({ addKey: new actions_1.AddKey({ publicKey, accessKey }) });
    }
    function deleteKey(publicKey) {
      return new actions_1.Action({ deleteKey: new actions_1.DeleteKey({ publicKey }) });
    }
    function deleteAccount(beneficiaryId) {
      return new actions_1.Action({ deleteAccount: new actions_1.DeleteAccount({ beneficiaryId }) });
    }
    function signedDelegate({ delegateAction, signature }) {
      return new actions_1.Action({
        signedDelegate: new actions_1.SignedDelegate({ delegateAction, signature })
      });
    }
    exports.actionCreators = {
      addKey,
      createAccount,
      deleteAccount,
      deleteKey,
      deployContract,
      fullAccessKey,
      functionCall,
      functionCallAccessKey,
      signedDelegate,
      stake,
      transfer
    };
  }
});

// node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/types.js
var require_types = __commonJS({
  "node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/types.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    exports.__esModule = true;
    exports.integers = void 0;
    exports.integers = ["u8", "u16", "u32", "u64", "u128", "i8", "i16", "i32", "i64", "i128", "f32", "f64"];
  }
});

// node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/buffer.js
var require_buffer = __commonJS({
  "node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/buffer.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    exports.__esModule = true;
    exports.DecodeBuffer = exports.EncodeBuffer = void 0;
    var EncodeBuffer = (
      /** @class */
      function() {
        function EncodeBuffer2() {
          this.offset = 0;
          this.buffer_size = 256;
          this.buffer = new ArrayBuffer(this.buffer_size);
          this.view = new DataView(this.buffer);
        }
        EncodeBuffer2.prototype.resize_if_necessary = function(needed_space) {
          if (this.buffer_size - this.offset < needed_space) {
            this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
            var new_buffer = new ArrayBuffer(this.buffer_size);
            new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
            this.buffer = new_buffer;
            this.view = new DataView(new_buffer);
          }
        };
        EncodeBuffer2.prototype.get_used_buffer = function() {
          return new Uint8Array(this.buffer).slice(0, this.offset);
        };
        EncodeBuffer2.prototype.store_value = function(value, type) {
          var bSize = type.substring(1);
          var size = parseInt(bSize) / 8;
          this.resize_if_necessary(size);
          var toCall = type[0] === "f" ? "setFloat".concat(bSize) : type[0] === "i" ? "setInt".concat(bSize) : "setUint".concat(bSize);
          this.view[toCall](this.offset, value, true);
          this.offset += size;
        };
        EncodeBuffer2.prototype.store_bytes = function(from) {
          this.resize_if_necessary(from.length);
          new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
          this.offset += from.length;
        };
        return EncodeBuffer2;
      }()
    );
    exports.EncodeBuffer = EncodeBuffer;
    var DecodeBuffer = (
      /** @class */
      function() {
        function DecodeBuffer2(buf) {
          this.offset = 0;
          this.buffer_size = buf.length;
          this.buffer = new ArrayBuffer(buf.length);
          new Uint8Array(this.buffer).set(buf);
          this.view = new DataView(this.buffer);
        }
        DecodeBuffer2.prototype.assert_enough_buffer = function(size) {
          if (this.offset + size > this.buffer.byteLength) {
            throw new Error("Error in schema, the buffer is smaller than expected");
          }
        };
        DecodeBuffer2.prototype.consume_value = function(type) {
          var bSize = type.substring(1);
          var size = parseInt(bSize) / 8;
          this.assert_enough_buffer(size);
          var toCall = type[0] === "f" ? "getFloat".concat(bSize) : type[0] === "i" ? "getInt".concat(bSize) : "getUint".concat(bSize);
          var ret = this.view[toCall](this.offset, true);
          this.offset += size;
          return ret;
        };
        DecodeBuffer2.prototype.consume_bytes = function(size) {
          this.assert_enough_buffer(size);
          var ret = this.buffer.slice(this.offset, this.offset + size);
          this.offset += size;
          return ret;
        };
        return DecodeBuffer2;
      }()
    );
    exports.DecodeBuffer = DecodeBuffer;
  }
});

// node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/utils.js
var require_utils = __commonJS({
  "node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/utils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports.__esModule = true;
    exports.validate_schema = exports.ErrorSchema = exports.expect_enum = exports.expect_same_size = exports.expect_bigint = exports.expect_type = exports.isArrayLike = void 0;
    var types_js_1 = require_types();
    function isArrayLike(value) {
      return Array.isArray(value) || !!value && typeof value === "object" && "length" in value && typeof value.length === "number" && (value.length === 0 || value.length > 0 && value.length - 1 in value);
    }
    exports.isArrayLike = isArrayLike;
    function expect_type(value, type, fieldPath) {
      if (typeof value !== type) {
        throw new Error("Expected ".concat(type, " not ").concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_type = expect_type;
    function expect_bigint(value, fieldPath) {
      var basicType = ["number", "string", "bigint", "boolean"].includes(typeof value);
      var strObject = typeof value === "object" && value !== null && "toString" in value;
      if (!basicType && !strObject) {
        throw new Error("Expected bigint, number, boolean or string not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_bigint = expect_bigint;
    function expect_same_size(length, expected, fieldPath) {
      if (length !== expected) {
        throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_same_size = expect_same_size;
    function expect_enum(value, fieldPath) {
      if (typeof value !== "object" || value === null) {
        throw new Error("Expected object not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_enum = expect_enum;
    var VALID_STRING_TYPES = types_js_1.integers.concat(["bool", "string"]);
    var VALID_OBJECT_KEYS = ["option", "enum", "array", "set", "map", "struct"];
    var ErrorSchema = (
      /** @class */
      function(_super) {
        __extends(ErrorSchema2, _super);
        function ErrorSchema2(schema, expected) {
          var message = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
          return _super.call(this, message) || this;
        }
        return ErrorSchema2;
      }(Error)
    );
    exports.ErrorSchema = ErrorSchema;
    function validate_schema(schema) {
      if (typeof schema === "string" && VALID_STRING_TYPES.includes(schema)) {
        return;
      }
      if (schema && typeof schema === "object") {
        var keys = Object.keys(schema);
        if (keys.length === 1 && VALID_OBJECT_KEYS.includes(keys[0])) {
          var key = keys[0];
          if (key === "option")
            return validate_schema(schema[key]);
          if (key === "enum")
            return validate_enum_schema(schema[key]);
          if (key === "array")
            return validate_array_schema(schema[key]);
          if (key === "set")
            return validate_schema(schema[key]);
          if (key === "map")
            return validate_map_schema(schema[key]);
          if (key === "struct")
            return validate_struct_schema(schema[key]);
        }
      }
      throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(", ") + " or " + VALID_STRING_TYPES.join(", "));
    }
    exports.validate_schema = validate_schema;
    function validate_enum_schema(schema) {
      if (!Array.isArray(schema))
        throw new ErrorSchema(schema, "Array");
      for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
        var sch = schema_1[_i];
        if (typeof sch !== "object" || !("struct" in sch)) {
          throw new Error('Missing "struct" key in enum schema');
        }
        if (typeof sch.struct !== "object" || Object.keys(sch.struct).length !== 1) {
          throw new Error('The "struct" in each enum must have a single key');
        }
        validate_schema({ struct: sch.struct });
      }
    }
    function validate_array_schema(schema) {
      if (typeof schema !== "object")
        throw new ErrorSchema(schema, "{ type, len? }");
      if (schema.len && typeof schema.len !== "number") {
        throw new Error("Invalid schema: ".concat(schema));
      }
      if ("type" in schema)
        return validate_schema(schema.type);
      throw new ErrorSchema(schema, "{ type, len? }");
    }
    function validate_map_schema(schema) {
      if (typeof schema === "object" && "key" in schema && "value" in schema) {
        validate_schema(schema.key);
        validate_schema(schema.value);
      } else {
        throw new ErrorSchema(schema, "{ key, value }");
      }
    }
    function validate_struct_schema(schema) {
      if (typeof schema !== "object")
        throw new ErrorSchema(schema, "object");
      for (var key in schema) {
        validate_schema(schema[key]);
      }
    }
  }
});

// node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/serialize.js
var require_serialize = __commonJS({
  "node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/serialize.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    exports.__esModule = true;
    exports.BorshSerializer = void 0;
    var types_js_1 = require_types();
    var buffer_js_1 = require_buffer();
    var utils = __importStar(require_utils());
    var BorshSerializer = (
      /** @class */
      function() {
        function BorshSerializer2(checkTypes) {
          this.encoded = new buffer_js_1.EncodeBuffer();
          this.fieldPath = ["value"];
          this.checkTypes = checkTypes;
        }
        BorshSerializer2.prototype.encode = function(value, schema) {
          this.encode_value(value, schema);
          return this.encoded.get_used_buffer();
        };
        BorshSerializer2.prototype.encode_value = function(value, schema) {
          if (typeof schema === "string") {
            if (types_js_1.integers.includes(schema))
              return this.encode_integer(value, schema);
            if (schema === "string")
              return this.encode_string(value);
            if (schema === "bool")
              return this.encode_boolean(value);
          }
          if (typeof schema === "object") {
            if ("option" in schema)
              return this.encode_option(value, schema);
            if ("enum" in schema)
              return this.encode_enum(value, schema);
            if ("array" in schema)
              return this.encode_array(value, schema);
            if ("set" in schema)
              return this.encode_set(value, schema);
            if ("map" in schema)
              return this.encode_map(value, schema);
            if ("struct" in schema)
              return this.encode_struct(value, schema);
          }
        };
        BorshSerializer2.prototype.encode_integer = function(value, schema) {
          var size = parseInt(schema.substring(1));
          if (size <= 32 || schema == "f64") {
            this.checkTypes && utils.expect_type(value, "number", this.fieldPath);
            this.encoded.store_value(value, schema);
          } else {
            this.checkTypes && utils.expect_bigint(value, this.fieldPath);
            this.encode_bigint(BigInt(value), size);
          }
        };
        BorshSerializer2.prototype.encode_bigint = function(value, size) {
          var buffer_len = size / 8;
          var buffer = new Uint8Array(buffer_len);
          for (var i = 0; i < buffer_len; i++) {
            buffer[i] = Number(value & BigInt(255));
            value = value >> BigInt(8);
          }
          this.encoded.store_bytes(new Uint8Array(buffer));
        };
        BorshSerializer2.prototype.encode_string = function(value) {
          this.checkTypes && utils.expect_type(value, "string", this.fieldPath);
          var _value = value;
          this.encoded.store_value(_value.length, "u32");
          for (var i = 0; i < _value.length; i++) {
            this.encoded.store_value(_value.charCodeAt(i), "u8");
          }
        };
        BorshSerializer2.prototype.encode_boolean = function(value) {
          this.checkTypes && utils.expect_type(value, "boolean", this.fieldPath);
          this.encoded.store_value(value ? 1 : 0, "u8");
        };
        BorshSerializer2.prototype.encode_option = function(value, schema) {
          if (value === null || value === void 0) {
            this.encoded.store_value(0, "u8");
          } else {
            this.encoded.store_value(1, "u8");
            this.encode_value(value, schema.option);
          }
        };
        BorshSerializer2.prototype.encode_enum = function(value, schema) {
          this.checkTypes && utils.expect_enum(value, this.fieldPath);
          var valueKey = Object.keys(value)[0];
          for (var i = 0; i < schema["enum"].length; i++) {
            var valueSchema = schema["enum"][i];
            if (valueKey === Object.keys(valueSchema.struct)[0]) {
              this.encoded.store_value(i, "u8");
              return this.encode_struct(value, valueSchema);
            }
          }
          throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join(".")));
        };
        BorshSerializer2.prototype.encode_array = function(value, schema) {
          if (utils.isArrayLike(value))
            return this.encode_arraylike(value, schema);
          if (value instanceof ArrayBuffer)
            return this.encode_buffer(value, schema);
          throw new Error("Expected Array-like not ".concat(typeof value, "(").concat(value, ") at ").concat(this.fieldPath.join(".")));
        };
        BorshSerializer2.prototype.encode_arraylike = function(value, schema) {
          if (schema.array.len) {
            utils.expect_same_size(value.length, schema.array.len, this.fieldPath);
          } else {
            this.encoded.store_value(value.length, "u32");
          }
          for (var i = 0; i < value.length; i++) {
            this.encode_value(value[i], schema.array.type);
          }
        };
        BorshSerializer2.prototype.encode_buffer = function(value, schema) {
          if (schema.array.len) {
            utils.expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
          } else {
            this.encoded.store_value(value.byteLength, "u32");
          }
          this.encoded.store_bytes(new Uint8Array(value));
        };
        BorshSerializer2.prototype.encode_set = function(value, schema) {
          this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
          var isSet = value instanceof Set;
          var values = isSet ? Array.from(value.values()) : Object.values(value);
          this.encoded.store_value(values.length, "u32");
          for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value_1 = values_1[_i];
            this.encode_value(value_1, schema.set);
          }
        };
        BorshSerializer2.prototype.encode_map = function(value, schema) {
          this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
          var isMap = value instanceof Map;
          var keys = isMap ? Array.from(value.keys()) : Object.keys(value);
          this.encoded.store_value(keys.length, "u32");
          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            this.encode_value(key, schema.map.key);
            this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
          }
        };
        BorshSerializer2.prototype.encode_struct = function(value, schema) {
          this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
          for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
            var key = _a[_i];
            this.fieldPath.push(key);
            this.encode_value(value[key], schema.struct[key]);
            this.fieldPath.pop();
          }
        };
        return BorshSerializer2;
      }()
    );
    exports.BorshSerializer = BorshSerializer;
  }
});

// node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/deserialize.js
var require_deserialize = __commonJS({
  "node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/deserialize.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    exports.__esModule = true;
    exports.BorshDeserializer = void 0;
    var types_js_1 = require_types();
    var buffer_js_1 = require_buffer();
    var BorshDeserializer = (
      /** @class */
      function() {
        function BorshDeserializer2(bufferArray) {
          this.buffer = new buffer_js_1.DecodeBuffer(bufferArray);
        }
        BorshDeserializer2.prototype.decode = function(schema) {
          return this.decode_value(schema);
        };
        BorshDeserializer2.prototype.decode_value = function(schema) {
          if (typeof schema === "string") {
            if (types_js_1.integers.includes(schema))
              return this.decode_integer(schema);
            if (schema === "string")
              return this.decode_string();
            if (schema === "bool")
              return this.decode_boolean();
          }
          if (typeof schema === "object") {
            if ("option" in schema)
              return this.decode_option(schema);
            if ("enum" in schema)
              return this.decode_enum(schema);
            if ("array" in schema)
              return this.decode_array(schema);
            if ("set" in schema)
              return this.decode_set(schema);
            if ("map" in schema)
              return this.decode_map(schema);
            if ("struct" in schema)
              return this.decode_struct(schema);
          }
          throw new Error("Unsupported type: ".concat(schema));
        };
        BorshDeserializer2.prototype.decode_integer = function(schema) {
          var size = parseInt(schema.substring(1));
          if (size <= 32 || schema == "f64") {
            return this.buffer.consume_value(schema);
          }
          return this.decode_bigint(size, schema.startsWith("i"));
        };
        BorshDeserializer2.prototype.decode_bigint = function(size, signed) {
          if (signed === void 0) {
            signed = false;
          }
          var buffer_len = size / 8;
          var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
          var bits = buffer.reduceRight(function(r, x) {
            return r + x.toString(16).padStart(2, "0");
          }, "");
          if (signed && buffer[buffer_len - 1]) {
            return BigInt.asIntN(size, BigInt("0x".concat(bits)));
          }
          return BigInt("0x".concat(bits));
        };
        BorshDeserializer2.prototype.decode_string = function() {
          var len = this.decode_integer("u32");
          var buffer = new Uint8Array(this.buffer.consume_bytes(len));
          return String.fromCharCode.apply(null, buffer);
        };
        BorshDeserializer2.prototype.decode_boolean = function() {
          return this.buffer.consume_value("u8") > 0;
        };
        BorshDeserializer2.prototype.decode_option = function(schema) {
          var option = this.buffer.consume_value("u8");
          if (option === 1) {
            return this.decode_value(schema.option);
          }
          if (option !== 0) {
            throw new Error("Invalid option ".concat(option));
          }
          return null;
        };
        BorshDeserializer2.prototype.decode_enum = function(schema) {
          var _a;
          var valueIndex = this.buffer.consume_value("u8");
          if (valueIndex > schema["enum"].length) {
            throw new Error("Enum option ".concat(valueIndex, " is not available"));
          }
          var struct = schema["enum"][valueIndex].struct;
          var key = Object.keys(struct)[0];
          return _a = {}, _a[key] = this.decode_value(struct[key]), _a;
        };
        BorshDeserializer2.prototype.decode_array = function(schema) {
          var result = [];
          var len = schema.array.len ? schema.array.len : this.decode_integer("u32");
          for (var i = 0; i < len; ++i) {
            result.push(this.decode_value(schema.array.type));
          }
          return result;
        };
        BorshDeserializer2.prototype.decode_set = function(schema) {
          var len = this.decode_integer("u32");
          var result = /* @__PURE__ */ new Set();
          for (var i = 0; i < len; ++i) {
            result.add(this.decode_value(schema.set));
          }
          return result;
        };
        BorshDeserializer2.prototype.decode_map = function(schema) {
          var len = this.decode_integer("u32");
          var result = /* @__PURE__ */ new Map();
          for (var i = 0; i < len; ++i) {
            var key = this.decode_value(schema.map.key);
            var value = this.decode_value(schema.map.value);
            result.set(key, value);
          }
          return result;
        };
        BorshDeserializer2.prototype.decode_struct = function(schema) {
          var result = {};
          for (var key in schema.struct) {
            result[key] = this.decode_value(schema.struct[key]);
          }
          return result;
        };
        return BorshDeserializer2;
      }()
    );
    exports.BorshDeserializer = BorshDeserializer;
  }
});

// node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@near-js/transactions/node_modules/borsh/lib/cjs/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    exports.__esModule = true;
    exports.deserialize = exports.serialize = void 0;
    var serialize_js_1 = require_serialize();
    var deserialize_js_1 = require_deserialize();
    var utils = __importStar(require_utils());
    function serialize(schema, value, validate) {
      if (validate === void 0) {
        validate = true;
      }
      if (validate)
        utils.validate_schema(schema);
      var serializer = new serialize_js_1.BorshSerializer(validate);
      return serializer.encode(value, schema);
    }
    exports.serialize = serialize;
    function deserialize(schema, buffer, validate) {
      if (validate === void 0) {
        validate = true;
      }
      if (validate)
        utils.validate_schema(schema);
      var deserializer = new deserialize_js_1.BorshDeserializer(buffer);
      return deserializer.decode(schema);
    }
    exports.deserialize = deserialize;
  }
});

// node_modules/@near-js/transactions/lib/commonjs/prefix.cjs
var require_prefix = __commonJS({
  "node_modules/@near-js/transactions/lib/commonjs/prefix.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DelegateActionPrefix = void 0;
    var ACTIONABLE_MESSAGE_BASE = Math.pow(2, 30);
    var NEP = {
      MetaTransactions: 366
    };
    var NEPPrefix = class {
      constructor({ prefix }) {
        __publicField(this, "prefix");
        this.prefix = prefix;
      }
    };
    var ActionableMessagePrefix = class extends NEPPrefix {
      /** Given the NEP number, set the prefix using 2^30 as the offset **/
      constructor(prefix) {
        super({ prefix: ACTIONABLE_MESSAGE_BASE + prefix });
      }
    };
    var DelegateActionPrefix = class extends ActionableMessagePrefix {
      constructor() {
        super(NEP.MetaTransactions);
      }
    };
    exports.DelegateActionPrefix = DelegateActionPrefix;
  }
});

// node_modules/@near-js/transactions/lib/commonjs/schema.cjs
var require_schema = __commonJS({
  "node_modules/@near-js/transactions/lib/commonjs/schema.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SCHEMA = exports.SignedTransaction = exports.Transaction = exports.decodeSignedTransaction = exports.decodeTransaction = exports.encodeTransaction = exports.encodeSignedDelegate = exports.encodeDelegateAction = void 0;
    var borsh_1 = require_cjs();
    var prefix_1 = require_prefix();
    function encodeDelegateAction(delegateAction) {
      return new Uint8Array([
        ...(0, borsh_1.serialize)(exports.SCHEMA.DelegateActionPrefix, new prefix_1.DelegateActionPrefix()),
        ...(0, borsh_1.serialize)(exports.SCHEMA.DelegateAction, delegateAction)
      ]);
    }
    exports.encodeDelegateAction = encodeDelegateAction;
    function encodeSignedDelegate(signedDelegate) {
      return (0, borsh_1.serialize)(exports.SCHEMA.SignedDelegate, signedDelegate);
    }
    exports.encodeSignedDelegate = encodeSignedDelegate;
    function encodeTransaction(transaction) {
      const schema = transaction instanceof SignedTransaction ? exports.SCHEMA.SignedTransaction : exports.SCHEMA.Transaction;
      return (0, borsh_1.serialize)(schema, transaction);
    }
    exports.encodeTransaction = encodeTransaction;
    function decodeTransaction(bytes) {
      return new Transaction((0, borsh_1.deserialize)(exports.SCHEMA.Transaction, bytes));
    }
    exports.decodeTransaction = decodeTransaction;
    function decodeSignedTransaction(bytes) {
      return new SignedTransaction((0, borsh_1.deserialize)(exports.SCHEMA.SignedTransaction, bytes));
    }
    exports.decodeSignedTransaction = decodeSignedTransaction;
    var Transaction = class {
      constructor({ signerId, publicKey, nonce, receiverId, actions, blockHash }) {
        __publicField(this, "signerId");
        __publicField(this, "publicKey");
        __publicField(this, "nonce");
        __publicField(this, "receiverId");
        __publicField(this, "actions");
        __publicField(this, "blockHash");
        this.signerId = signerId;
        this.publicKey = publicKey;
        this.nonce = nonce;
        this.receiverId = receiverId;
        this.actions = actions;
        this.blockHash = blockHash;
      }
      encode() {
        return encodeTransaction(this);
      }
      static decode(bytes) {
        return decodeTransaction(bytes);
      }
    };
    exports.Transaction = Transaction;
    var SignedTransaction = class {
      constructor({ transaction, signature }) {
        __publicField(this, "transaction");
        __publicField(this, "signature");
        this.transaction = transaction;
        this.signature = signature;
      }
      encode() {
        return encodeTransaction(this);
      }
      static decode(bytes) {
        return decodeSignedTransaction(bytes);
      }
    };
    exports.SignedTransaction = SignedTransaction;
    exports.SCHEMA = new class BorshSchema {
      constructor() {
        __publicField(this, "Ed25519Signature", {
          struct: {
            data: { array: { type: "u8", len: 64 } }
          }
        });
        __publicField(this, "Secp256k1Signature", {
          struct: {
            data: { array: { type: "u8", len: 65 } }
          }
        });
        __publicField(this, "Signature", {
          enum: [
            { struct: { ed25519Signature: this.Ed25519Signature } },
            { struct: { secp256k1Signature: this.Secp256k1Signature } }
          ]
        });
        __publicField(this, "Ed25519Data", {
          struct: {
            data: { array: { type: "u8", len: 32 } }
          }
        });
        __publicField(this, "Secp256k1Data", {
          struct: {
            data: { array: { type: "u8", len: 64 } }
          }
        });
        __publicField(this, "PublicKey", {
          enum: [
            { struct: { ed25519Key: this.Ed25519Data } },
            { struct: { secp256k1Key: this.Secp256k1Data } }
          ]
        });
        __publicField(this, "FunctionCallPermission", {
          struct: {
            allowance: { option: "u128" },
            receiverId: "string",
            methodNames: { array: { type: "string" } }
          }
        });
        __publicField(this, "FullAccessPermission", {
          struct: {}
        });
        __publicField(this, "AccessKeyPermission", {
          enum: [
            { struct: { functionCall: this.FunctionCallPermission } },
            { struct: { fullAccess: this.FullAccessPermission } }
          ]
        });
        __publicField(this, "AccessKey", {
          struct: {
            nonce: "u64",
            permission: this.AccessKeyPermission
          }
        });
        __publicField(this, "CreateAccount", {
          struct: {}
        });
        __publicField(this, "DeployContract", {
          struct: {
            code: { array: { type: "u8" } }
          }
        });
        __publicField(this, "FunctionCall", {
          struct: {
            methodName: "string",
            args: { array: { type: "u8" } },
            gas: "u64",
            deposit: "u128"
          }
        });
        __publicField(this, "Transfer", {
          struct: {
            deposit: "u128"
          }
        });
        __publicField(this, "Stake", {
          struct: {
            stake: "u128",
            publicKey: this.PublicKey
          }
        });
        __publicField(this, "AddKey", {
          struct: {
            publicKey: this.PublicKey,
            accessKey: this.AccessKey
          }
        });
        __publicField(this, "DeleteKey", {
          struct: {
            publicKey: this.PublicKey
          }
        });
        __publicField(this, "DeleteAccount", {
          struct: {
            beneficiaryId: "string"
          }
        });
        __publicField(this, "DelegateActionPrefix", {
          struct: {
            prefix: "u32"
          }
        });
        __publicField(this, "ClassicActions", {
          enum: [
            { struct: { createAccount: this.CreateAccount } },
            { struct: { deployContract: this.DeployContract } },
            { struct: { functionCall: this.FunctionCall } },
            { struct: { transfer: this.Transfer } },
            { struct: { stake: this.Stake } },
            { struct: { addKey: this.AddKey } },
            { struct: { deleteKey: this.DeleteKey } },
            { struct: { deleteAccount: this.DeleteAccount } }
          ]
        });
        __publicField(this, "DelegateAction", {
          struct: {
            senderId: "string",
            receiverId: "string",
            actions: { array: { type: this.ClassicActions } },
            nonce: "u64",
            maxBlockHeight: "u64",
            publicKey: this.PublicKey
          }
        });
        __publicField(this, "SignedDelegate", {
          struct: {
            delegateAction: this.DelegateAction,
            signature: this.Signature
          }
        });
        __publicField(this, "Action", {
          enum: [
            { struct: { createAccount: this.CreateAccount } },
            { struct: { deployContract: this.DeployContract } },
            { struct: { functionCall: this.FunctionCall } },
            { struct: { transfer: this.Transfer } },
            { struct: { stake: this.Stake } },
            { struct: { addKey: this.AddKey } },
            { struct: { deleteKey: this.DeleteKey } },
            { struct: { deleteAccount: this.DeleteAccount } },
            { struct: { signedDelegate: this.SignedDelegate } }
          ]
        });
        __publicField(this, "Transaction", {
          struct: {
            signerId: "string",
            publicKey: this.PublicKey,
            nonce: "u64",
            receiverId: "string",
            blockHash: { array: { type: "u8", len: 32 } },
            actions: { array: { type: this.Action } }
          }
        });
        __publicField(this, "SignedTransaction", {
          struct: {
            transaction: this.Transaction,
            signature: this.Signature
          }
        });
      }
    }();
  }
});

// node_modules/@near-js/transactions/lib/commonjs/create_transaction.cjs
var require_create_transaction = __commonJS({
  "node_modules/@near-js/transactions/lib/commonjs/create_transaction.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransaction = void 0;
    var schema_1 = require_schema();
    function createTransaction(signerId, publicKey, receiverId, nonce, actions, blockHash) {
      const txNonce = typeof nonce === "bigint" ? nonce : BigInt(nonce);
      return new schema_1.Transaction({
        signerId,
        publicKey,
        nonce: txNonce,
        receiverId,
        actions,
        blockHash
      });
    }
    exports.createTransaction = createTransaction;
  }
});

// node_modules/@near-js/transactions/lib/commonjs/delegate.cjs
var require_delegate = __commonJS({
  "node_modules/@near-js/transactions/lib/commonjs/delegate.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildDelegateAction = exports.DelegateAction = void 0;
    var action_creators_1 = require_action_creators();
    var { addKey, createAccount, deleteAccount, deleteKey, deployContract, functionCall, stake, transfer } = action_creators_1.actionCreators;
    var DelegateAction = class {
      constructor({ senderId, receiverId, actions, nonce, maxBlockHeight, publicKey }) {
        __publicField(this, "senderId");
        __publicField(this, "receiverId");
        __publicField(this, "actions");
        __publicField(this, "nonce");
        __publicField(this, "maxBlockHeight");
        __publicField(this, "publicKey");
        this.senderId = senderId;
        this.receiverId = receiverId;
        this.actions = actions;
        this.nonce = nonce;
        this.maxBlockHeight = maxBlockHeight;
        this.publicKey = publicKey;
      }
    };
    exports.DelegateAction = DelegateAction;
    function buildDelegateAction({ actions, maxBlockHeight, nonce, publicKey, receiverId, senderId }) {
      return new DelegateAction({
        senderId,
        receiverId,
        actions: actions.map((a) => {
          if (!a.type && !a.params) {
            return a;
          }
          switch (a.type) {
            case "AddKey": {
              const { publicKey: publicKey2, accessKey } = a.params;
              return addKey(publicKey2, accessKey);
            }
            case "CreateAccount": {
              return createAccount(a.params.createAccount);
            }
            case "DeleteAccount": {
              return deleteAccount(a.params.deleteAccount);
            }
            case "DeleteKey": {
              return deleteKey(a.params.publicKey);
            }
            case "DeployContract": {
              return deployContract(a.params.code);
            }
            case "FunctionCall": {
              const { methodName, args, gas, deposit } = a.params;
              return functionCall(methodName, args, gas, deposit);
            }
            case "Stake": {
              return stake(a.params.stake, a.params.publicKey);
            }
            case "Transfer": {
              const { deposit } = a.params;
              return transfer(deposit);
            }
          }
          throw new Error("Unrecognized action");
        }),
        nonce,
        maxBlockHeight,
        publicKey
      });
    }
    exports.buildDelegateAction = buildDelegateAction;
  }
});

// node_modules/@near-js/transactions/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@near-js/transactions/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.anumber = anumber;
    exports.abytes = abytes;
    exports.ahash = ahash;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
  }
});

// node_modules/@near-js/transactions/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@near-js/transactions/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@near-js/transactions/node_modules/@noble/hashes/utils.js
var require_utils2 = __commonJS({
  "node_modules/@near-js/transactions/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.isLE = void 0;
    exports.isBytes = isBytes;
    exports.u8 = u8;
    exports.u32 = u32;
    exports.createView = createView;
    exports.rotr = rotr;
    exports.rotl = rotl;
    exports.byteSwap = byteSwap;
    exports.byteSwap32 = byteSwap32;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.asyncLoop = asyncLoop;
    exports.utf8ToBytes = utf8ToBytes;
    exports.toBytes = toBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.wrapConstructor = wrapConstructor;
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    exports.randomBytes = randomBytes;
    var crypto_1 = require_crypto();
    var _assert_js_1 = require_assert();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
    }
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.abytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("utf8ToBytes expected string, got " + typeof str);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.abytes)(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.abytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return crypto_1.crypto.randomBytes(bytesLength);
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@near-js/transactions/node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@near-js/transactions/node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = void 0;
    exports.setBigUint64 = setBigUint64;
    exports.Chi = Chi;
    exports.Maj = Maj;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils2();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function Chi(a, b, c) {
      return a & b ^ ~a & c;
    }
    function Maj(a, b, c) {
      return a & b ^ a & c ^ b & c;
    }
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.aexists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.aexists)(this);
        (0, _assert_js_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.HashMD = HashMD;
  }
});

// node_modules/@near-js/transactions/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@near-js/transactions/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = exports.SHA256 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils2();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    exports.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@near-js/transactions/lib/commonjs/signature.cjs
var require_signature = __commonJS({
  "node_modules/@near-js/transactions/lib/commonjs/signature.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Signature = void 0;
    var crypto_1 = require_commonjs3();
    var types_1 = require_commonjs();
    function resolveEnumKeyName(keyType) {
      switch (keyType) {
        case crypto_1.KeyType.ED25519: {
          return "ed25519Signature";
        }
        case crypto_1.KeyType.SECP256K1: {
          return "secp256k1Signature";
        }
        default: {
          throw Error(`unknown type ${keyType}`);
        }
      }
    }
    var Signature = class extends types_1.Enum {
      constructor(signature) {
        const keyName = resolveEnumKeyName(signature.keyType);
        super({ [keyName]: signature });
        __publicField(this, "enum");
        __publicField(this, "ed25519Signature");
        __publicField(this, "secp256k1Signature");
        this[keyName] = signature;
        this.enum = keyName;
      }
      get signature() {
        return this.ed25519Signature || this.secp256k1Signature;
      }
      get signatureType() {
        return this.signature.keyType;
      }
      get data() {
        return this.signature.data;
      }
    };
    exports.Signature = Signature;
  }
});

// node_modules/@near-js/transactions/lib/commonjs/sign.cjs
var require_sign = __commonJS({
  "node_modules/@near-js/transactions/lib/commonjs/sign.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signDelegateAction = exports.signTransaction = void 0;
    var sha256_1 = require_sha256();
    var actions_1 = require_actions();
    var create_transaction_1 = require_create_transaction();
    var schema_1 = require_schema();
    var signature_1 = require_signature();
    var crypto_1 = require_commonjs3();
    async function signTransactionObject(transaction, signer, accountId, networkId) {
      const message = (0, schema_1.encodeTransaction)(transaction);
      const hash = new Uint8Array((0, sha256_1.sha256)(message));
      const signature = await signer.signMessage(message, accountId, networkId);
      const keyType = transaction.publicKey.ed25519Key ? crypto_1.KeyType.ED25519 : crypto_1.KeyType.SECP256K1;
      const signedTx = new schema_1.SignedTransaction({
        transaction,
        signature: new signature_1.Signature({ keyType, data: signature.signature })
      });
      return [hash, signedTx];
    }
    async function signTransaction(...args) {
      if (args[0].constructor === schema_1.Transaction) {
        const [transaction, signer, accountId, networkId] = args;
        return signTransactionObject(transaction, signer, accountId, networkId);
      } else {
        const [receiverId, nonce, actions, blockHash, signer, accountId, networkId] = args;
        const publicKey = await signer.getPublicKey(accountId, networkId);
        const transaction = (0, create_transaction_1.createTransaction)(accountId, publicKey, receiverId, nonce, actions, blockHash);
        return signTransactionObject(transaction, signer, accountId, networkId);
      }
    }
    exports.signTransaction = signTransaction;
    async function signDelegateAction({ delegateAction, signer }) {
      const message = (0, schema_1.encodeDelegateAction)(delegateAction);
      const signature = await signer.sign(message);
      const keyType = delegateAction.publicKey.ed25519Key ? crypto_1.KeyType.ED25519 : crypto_1.KeyType.SECP256K1;
      const signedDelegateAction = new actions_1.SignedDelegate({
        delegateAction,
        signature: new signature_1.Signature({
          keyType,
          data: signature
        })
      });
      return {
        hash: new Uint8Array((0, sha256_1.sha256)(message)),
        signedDelegateAction
      };
    }
    exports.signDelegateAction = signDelegateAction;
  }
});

// node_modules/@near-js/transactions/lib/commonjs/index.cjs
var require_commonjs6 = __commonJS({
  "node_modules/@near-js/transactions/lib/commonjs/index.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_action_creators(), exports);
    __exportStar(require_actions(), exports);
    __exportStar(require_create_transaction(), exports);
    __exportStar(require_delegate(), exports);
    __exportStar(require_schema(), exports);
    __exportStar(require_sign(), exports);
    __exportStar(require_signature(), exports);
  }
});

// node_modules/@near-js/providers/lib/commonjs/provider.cjs
var require_provider = __commonJS({
  "node_modules/@near-js/providers/lib/commonjs/provider.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Provider = void 0;
    var Provider = class {
    };
    exports.Provider = Provider;
  }
});

// node_modules/exponential-backoff/dist/options.js
var require_options = __commonJS({
  "node_modules/exponential-backoff/dist/options.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultOptions = {
      delayFirstAttempt: false,
      jitter: "none",
      maxDelay: Infinity,
      numOfAttempts: 10,
      retry: function() {
        return true;
      },
      startingDelay: 100,
      timeMultiple: 2
    };
    function getSanitizedOptions(options) {
      var sanitized = __assign(__assign({}, defaultOptions), options);
      if (sanitized.numOfAttempts < 1) {
        sanitized.numOfAttempts = 1;
      }
      return sanitized;
    }
    exports.getSanitizedOptions = getSanitizedOptions;
  }
});

// node_modules/exponential-backoff/dist/jitter/full/full.jitter.js
var require_full_jitter = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/full/full.jitter.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function fullJitter(delay) {
      var jitteredDelay = Math.random() * delay;
      return Math.round(jitteredDelay);
    }
    exports.fullJitter = fullJitter;
  }
});

// node_modules/exponential-backoff/dist/jitter/no/no.jitter.js
var require_no_jitter = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/no/no.jitter.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function noJitter(delay) {
      return delay;
    }
    exports.noJitter = noJitter;
  }
});

// node_modules/exponential-backoff/dist/jitter/jitter.factory.js
var require_jitter_factory = __commonJS({
  "node_modules/exponential-backoff/dist/jitter/jitter.factory.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var full_jitter_1 = require_full_jitter();
    var no_jitter_1 = require_no_jitter();
    function JitterFactory(options) {
      switch (options.jitter) {
        case "full":
          return full_jitter_1.fullJitter;
        case "none":
        default:
          return no_jitter_1.noJitter;
      }
    }
    exports.JitterFactory = JitterFactory;
  }
});

// node_modules/exponential-backoff/dist/delay/delay.base.js
var require_delay_base = __commonJS({
  "node_modules/exponential-backoff/dist/delay/delay.base.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var jitter_factory_1 = require_jitter_factory();
    var Delay = (
      /** @class */
      function() {
        function Delay2(options) {
          this.options = options;
          this.attempt = 0;
        }
        Delay2.prototype.apply = function() {
          var _this = this;
          return new Promise(function(resolve) {
            return setTimeout(resolve, _this.jitteredDelay);
          });
        };
        Delay2.prototype.setAttemptNumber = function(attempt) {
          this.attempt = attempt;
        };
        Object.defineProperty(Delay2.prototype, "jitteredDelay", {
          get: function() {
            var jitter = jitter_factory_1.JitterFactory(this.options);
            return jitter(this.delay);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Delay2.prototype, "delay", {
          get: function() {
            var constant = this.options.startingDelay;
            var base = this.options.timeMultiple;
            var power = this.numOfDelayedAttempts;
            var delay = constant * Math.pow(base, power);
            return Math.min(delay, this.options.maxDelay);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Delay2.prototype, "numOfDelayedAttempts", {
          get: function() {
            return this.attempt;
          },
          enumerable: true,
          configurable: true
        });
        return Delay2;
      }()
    );
    exports.Delay = Delay;
  }
});

// node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js
var require_skip_first_delay = __commonJS({
  "node_modules/exponential-backoff/dist/delay/skip-first/skip-first.delay.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var delay_base_1 = require_delay_base();
    var SkipFirstDelay = (
      /** @class */
      function(_super) {
        __extends(SkipFirstDelay2, _super);
        function SkipFirstDelay2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        SkipFirstDelay2.prototype.apply = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, this.isFirstAttempt ? true : _super.prototype.apply.call(this)];
            });
          });
        };
        Object.defineProperty(SkipFirstDelay2.prototype, "isFirstAttempt", {
          get: function() {
            return this.attempt === 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(SkipFirstDelay2.prototype, "numOfDelayedAttempts", {
          get: function() {
            return this.attempt - 1;
          },
          enumerable: true,
          configurable: true
        });
        return SkipFirstDelay2;
      }(delay_base_1.Delay)
    );
    exports.SkipFirstDelay = SkipFirstDelay;
  }
});

// node_modules/exponential-backoff/dist/delay/always/always.delay.js
var require_always_delay = __commonJS({
  "node_modules/exponential-backoff/dist/delay/always/always.delay.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var delay_base_1 = require_delay_base();
    var AlwaysDelay = (
      /** @class */
      function(_super) {
        __extends(AlwaysDelay2, _super);
        function AlwaysDelay2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return AlwaysDelay2;
      }(delay_base_1.Delay)
    );
    exports.AlwaysDelay = AlwaysDelay;
  }
});

// node_modules/exponential-backoff/dist/delay/delay.factory.js
var require_delay_factory = __commonJS({
  "node_modules/exponential-backoff/dist/delay/delay.factory.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var skip_first_delay_1 = require_skip_first_delay();
    var always_delay_1 = require_always_delay();
    function DelayFactory(options, attempt) {
      var delay = initDelayClass(options);
      delay.setAttemptNumber(attempt);
      return delay;
    }
    exports.DelayFactory = DelayFactory;
    function initDelayClass(options) {
      if (!options.delayFirstAttempt) {
        return new skip_first_delay_1.SkipFirstDelay(options);
      }
      return new always_delay_1.AlwaysDelay(options);
    }
  }
});

// node_modules/exponential-backoff/dist/backoff.js
var require_backoff = __commonJS({
  "node_modules/exponential-backoff/dist/backoff.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var options_1 = require_options();
    var delay_factory_1 = require_delay_factory();
    function backOff(request, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(this, void 0, void 0, function() {
        var sanitizedOptions, backOff2;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              sanitizedOptions = options_1.getSanitizedOptions(options);
              backOff2 = new BackOff(request, sanitizedOptions);
              return [4, backOff2.execute()];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    }
    exports.backOff = backOff;
    var BackOff = (
      /** @class */
      function() {
        function BackOff2(request, options) {
          this.request = request;
          this.options = options;
          this.attemptNumber = 0;
        }
        BackOff2.prototype.execute = function() {
          return __awaiter(this, void 0, void 0, function() {
            var e_1, shouldRetry;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!!this.attemptLimitReached) return [3, 7];
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 4, , 6]);
                  return [4, this.applyDelay()];
                case 2:
                  _a.sent();
                  return [4, this.request()];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  e_1 = _a.sent();
                  this.attemptNumber++;
                  return [4, this.options.retry(e_1, this.attemptNumber)];
                case 5:
                  shouldRetry = _a.sent();
                  if (!shouldRetry || this.attemptLimitReached) {
                    throw e_1;
                  }
                  return [3, 6];
                case 6:
                  return [3, 0];
                case 7:
                  throw new Error("Something went wrong.");
              }
            });
          });
        };
        Object.defineProperty(BackOff2.prototype, "attemptLimitReached", {
          get: function() {
            return this.attemptNumber >= this.options.numOfAttempts;
          },
          enumerable: true,
          configurable: true
        });
        BackOff2.prototype.applyDelay = function() {
          return __awaiter(this, void 0, void 0, function() {
            var delay;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  delay = delay_factory_1.DelayFactory(this.options, this.attemptNumber);
                  return [4, delay.apply()];
                case 1:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return BackOff2;
      }()
    );
  }
});

// node_modules/@near-js/providers/lib/commonjs/fetch_json.cjs
var require_fetch_json = __commonJS({
  "node_modules/@near-js/providers/lib/commonjs/fetch_json.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fetchJsonRpc = exports.ProviderError = exports.retryConfig = void 0;
    var types_1 = require_commonjs();
    var exponential_backoff_1 = require_backoff();
    var BACKOFF_MULTIPLIER = 1.5;
    var RETRY_NUMBER = 10;
    var RETRY_DELAY = 0;
    function retryConfig(numOfAttempts = RETRY_NUMBER, timeMultiple = BACKOFF_MULTIPLIER, startingDelay = RETRY_DELAY) {
      return {
        numOfAttempts,
        timeMultiple,
        startingDelay,
        retry: (e) => {
          if ([503, 500, 408].includes(e.cause)) {
            return true;
          }
          if (e.toString().includes("FetchError") || e.toString().includes("Failed to fetch")) {
            return true;
          }
          return false;
        }
      };
    }
    exports.retryConfig = retryConfig;
    var ProviderError = class extends Error {
      constructor(message, options) {
        super(message, options);
        __publicField(this, "cause");
        if (options.cause) {
          this.cause = options.cause;
        }
      }
    };
    exports.ProviderError = ProviderError;
    async function fetchJsonRpc(url, json, headers, retryConfig2) {
      const response = await (0, exponential_backoff_1.backOff)(async () => {
        const res = await fetch(url, {
          method: "POST",
          body: JSON.stringify(json),
          headers: { ...headers, "Content-Type": "application/json" }
        });
        const { ok, status } = res;
        if (status === 500) {
          throw new ProviderError("Internal server error", { cause: status });
        } else if (status === 408) {
          throw new ProviderError("Timeout error", { cause: status });
        } else if (status === 400) {
          throw new ProviderError("Request validation error", { cause: status });
        } else if (status === 503) {
          throw new ProviderError(`${url} unavailable`, { cause: status });
        }
        if (!ok) {
          throw new ProviderError(await res.text(), { cause: status });
        }
        return res;
      }, retryConfig2);
      if (!response) {
        throw new types_1.TypedError(`Exceeded ${RETRY_NUMBER} attempts for ${url}.`, "RetriesExceeded");
      }
      return await response.json();
    }
    exports.fetchJsonRpc = fetchJsonRpc;
  }
});

// node_modules/@near-js/providers/lib/commonjs/json-rpc-provider.cjs
var require_json_rpc_provider = __commonJS({
  "node_modules/@near-js/providers/lib/commonjs/json-rpc-provider.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcProvider = void 0;
    var utils_1 = require_commonjs2();
    var types_1 = require_commonjs();
    var transactions_1 = require_commonjs6();
    var provider_1 = require_provider();
    var fetch_json_1 = require_fetch_json();
    var REQUEST_RETRY_NUMBER = 12;
    var REQUEST_RETRY_WAIT = 500;
    var REQUEST_RETRY_WAIT_BACKOFF = 1.5;
    var _nextId = 123;
    var JsonRpcProvider = class extends provider_1.Provider {
      /**
       * @param connectionInfo Connection info
       */
      constructor(connectionInfo, options) {
        super();
        /** @hidden */
        __publicField(this, "connection");
        /** @hidden */
        __publicField(this, "options");
        this.connection = connectionInfo || { url: "" };
        const defaultOptions = {
          retries: REQUEST_RETRY_NUMBER,
          wait: REQUEST_RETRY_WAIT,
          backoff: REQUEST_RETRY_WAIT_BACKOFF
        };
        this.options = Object.assign({}, defaultOptions, options);
      }
      /**
       * Gets the RPC's status
       * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
       */
      async status() {
        return this.sendJsonRpc("status", []);
      }
      /**
       * Sends a signed transaction to the RPC
       *
       * @param signedTransaction The signed transaction being sent
       * @param waitUntil
       */
      async sendTransactionUntil(signedTransaction, waitUntil) {
        const bytes = (0, transactions_1.encodeTransaction)(signedTransaction);
        return this.sendJsonRpc("send_tx", { signed_tx_base64: Buffer.from(bytes).toString("base64"), wait_until: waitUntil });
      }
      /**
       * Sends a signed transaction to the RPC and waits until transaction is fully complete
       * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
       *
       * @param signedTransaction The signed transaction being sent
       */
      async sendTransaction(signedTransaction) {
        return this.sendTransactionUntil(signedTransaction, "EXECUTED_OPTIMISTIC");
      }
      /**
       * Sends a signed transaction to the RPC and immediately returns transaction hash
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
       * @param signedTransaction The signed transaction being sent
       * @returns {Promise<FinalExecutionOutcome>}
       */
      async sendTransactionAsync(signedTransaction) {
        return this.sendTransactionUntil(signedTransaction, "NONE");
      }
      /**
       * Gets a transaction's status from the RPC
       * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
       *
       * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
       * @param accountId The NEAR account that signed the transaction
       * @param waitUntil
       */
      async txStatus(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
        if (typeof txHash === "string") {
          return this.txStatusString(txHash, accountId, waitUntil);
        } else {
          return this.txStatusUint8Array(txHash, accountId, waitUntil);
        }
      }
      async txStatusUint8Array(txHash, accountId, waitUntil) {
        return this.sendJsonRpc("tx", { tx_hash: (0, utils_1.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
      }
      async txStatusString(txHash, accountId, waitUntil) {
        return this.sendJsonRpc("tx", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
      }
      /**
       * Gets a transaction's status from the RPC with receipts
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
       * @param txHash The hash of the transaction
       * @param accountId The NEAR account that signed the transaction
       * @param waitUntil
       * @returns {Promise<FinalExecutionOutcome>}
       */
      async txStatusReceipts(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
        if (typeof txHash === "string") {
          return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
        } else {
          return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: (0, utils_1.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
        }
      }
      /**
       * Query the RPC by passing an {@link "@near-js/types".provider/request.RpcQueryRequest | RpcQueryRequest }
       * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
       *
       * @typeParam T the shape of the returned query response
       */
      async query(...args) {
        let result;
        if (args.length === 1) {
          const { block_id, blockId, ...otherParams } = args[0];
          result = await this.sendJsonRpc("query", { ...otherParams, block_id: block_id || blockId });
        } else {
          const [path, data] = args;
          result = await this.sendJsonRpc("query", [path, data]);
        }
        if (result && result.error) {
          throw new types_1.TypedError(`Querying failed: ${result.error}.
${JSON.stringify(result, null, 2)}`, (0, utils_1.getErrorTypeFromErrorMessage)(result.error, result.error.name));
        }
        return result;
      }
      /**
       * Query for block info from the RPC
       * pass block_id OR finality as blockQuery, not both
       * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
       *
       * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
       */
      async block(blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc("block", { block_id: blockId, finality });
      }
      /**
       * Query changes in block from the RPC
       * pass block_id OR finality as blockQuery, not both
       * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
       */
      async blockChanges(blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", { block_id: blockId, finality });
      }
      /**
       * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
       * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
       *
       * @param chunkId Hash of a chunk ID or shard ID
       */
      async chunk(chunkId) {
        return this.sendJsonRpc("chunk", [chunkId]);
      }
      /**
       * Query validators of the epoch defined by the given block id.
       * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
       *
       * @param blockId Block hash or height, or null for latest.
       */
      async validators(blockId) {
        return this.sendJsonRpc("validators", [blockId]);
      }
      /**
       * Gets the protocol config at a block from RPC
       *
       * @param blockReference specifies the block to get the protocol config for
       */
      async experimental_protocolConfig(blockReference) {
        const { blockId, ...otherParams } = blockReference;
        return await this.sendJsonRpc("EXPERIMENTAL_protocol_config", { ...otherParams, block_id: blockId });
      }
      /**
       * Gets a light client execution proof for verifying execution outcomes
       * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
       */
      async lightClientProof(request) {
        return await this.sendJsonRpc("EXPERIMENTAL_light_client_proof", request);
      }
      /**
       * Returns the next light client block as far in the future as possible from the last known hash
       * to still be able to validate from that hash. This will either return the last block of the
       * next epoch, or the last final known block.
       *
       * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
       */
      async nextLightClientBlock(request) {
        return await this.sendJsonRpc("next_light_client_block", request);
      }
      /**
       * Gets access key changes for a given array of accountIds
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
       * @returns {Promise<ChangeResult>}
       */
      async accessKeyChanges(accountIdArray, blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc("EXPERIMENTAL_changes", {
          changes_type: "all_access_key_changes",
          account_ids: accountIdArray,
          block_id: blockId,
          finality
        });
      }
      /**
       * Gets single access key changes for a given array of access keys
       * pass block_id OR finality as blockQuery, not both
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
       * @returns {Promise<ChangeResult>}
       */
      async singleAccessKeyChanges(accessKeyArray, blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc("EXPERIMENTAL_changes", {
          changes_type: "single_access_key_changes",
          keys: accessKeyArray,
          block_id: blockId,
          finality
        });
      }
      /**
       * Gets account changes for a given array of accountIds
       * pass block_id OR finality as blockQuery, not both
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
       * @returns {Promise<ChangeResult>}
       */
      async accountChanges(accountIdArray, blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc("EXPERIMENTAL_changes", {
          changes_type: "account_changes",
          account_ids: accountIdArray,
          block_id: blockId,
          finality
        });
      }
      /**
       * Gets contract state changes for a given array of accountIds
       * pass block_id OR finality as blockQuery, not both
       * Note: If you pass a keyPrefix it must be base64 encoded
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
       * @returns {Promise<ChangeResult>}
       */
      async contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc("EXPERIMENTAL_changes", {
          changes_type: "data_changes",
          account_ids: accountIdArray,
          key_prefix_base64: keyPrefix,
          block_id: blockId,
          finality
        });
      }
      /**
       * Gets contract code changes for a given array of accountIds
       * pass block_id OR finality as blockQuery, not both
       * Note: Change is returned in a base64 encoded WASM file
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
       * @returns {Promise<ChangeResult>}
       */
      async contractCodeChanges(accountIdArray, blockQuery) {
        const { finality } = blockQuery;
        const { blockId } = blockQuery;
        return this.sendJsonRpc("EXPERIMENTAL_changes", {
          changes_type: "contract_code_changes",
          account_ids: accountIdArray,
          block_id: blockId,
          finality
        });
      }
      /**
       * Returns gas price for a specific block_height or block_hash.
       * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
       *
       * @param blockId Block hash or height, or null for latest.
       */
      async gasPrice(blockId) {
        return await this.sendJsonRpc("gas_price", [blockId]);
      }
      /**
       * Directly call the RPC specifying the method and params
       *
       * @param method RPC method
       * @param params Parameters to the method
       */
      async sendJsonRpc(method, params) {
        var _a;
        const request = {
          method,
          params,
          id: _nextId++,
          jsonrpc: "2.0"
        };
        const response = await (0, fetch_json_1.fetchJsonRpc)(this.connection.url, request, this.connection.headers, (0, fetch_json_1.retryConfig)(this.options.retries, this.options.backoff, this.options.wait));
        if (response.error) {
          if (typeof response.error.data === "object") {
            if (typeof response.error.data.error_message === "string" && typeof response.error.data.error_type === "string") {
              throw new types_1.TypedError(response.error.data.error_message, response.error.data.error_type);
            }
            throw (0, utils_1.parseRpcError)(response.error.data);
          } else {
            const errorMessage = `[${response.error.code}] ${response.error.message}: ${response.error.data}`;
            const errorType = (0, utils_1.getErrorTypeFromErrorMessage)(response.error.data, "");
            if (errorType) {
              throw new types_1.TypedError((0, utils_1.formatError)(errorType, params), errorType);
            }
            throw new types_1.TypedError(errorMessage, response.error.name);
          }
        } else if (typeof ((_a = response.result) == null ? void 0 : _a.error) === "string") {
          const errorType = (0, utils_1.getErrorTypeFromErrorMessage)(response.result.error, "");
          if (errorType) {
            throw new utils_1.ServerError((0, utils_1.formatError)(errorType, params), errorType);
          }
        }
        const { result } = response;
        if (typeof result === "undefined") {
          throw new types_1.TypedError(`Exceeded ${this.options.retries} attempts for request to ${method}.`, "RetriesExceeded");
        }
        return result;
      }
    };
    exports.JsonRpcProvider = JsonRpcProvider;
  }
});

// node_modules/@near-js/providers/lib/commonjs/failover-rpc-provider.cjs
var require_failover_rpc_provider = __commonJS({
  "node_modules/@near-js/providers/lib/commonjs/failover-rpc-provider.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FailoverRpcProvider = void 0;
    var utils_1 = require_commonjs2();
    var types_1 = require_commonjs();
    var provider_1 = require_provider();
    var FailoverRpcProvider = class extends provider_1.Provider {
      /**
       * @param providers list of providers
       */
      constructor(providers) {
        super();
        /** @hidden */
        __publicField(this, "providers");
        __publicField(this, "currentProviderIndex");
        if (providers.length === 0) {
          throw new Error("At least one provider must be specified");
        }
        this.providers = providers;
        this.currentProviderIndex = 0;
      }
      switchToNextProvider() {
        if (this.providers.length === 1)
          return;
        if (this.providers.length - 1 <= this.currentProviderIndex) {
          this.currentProviderIndex = 0;
        } else {
          this.currentProviderIndex += 1;
        }
        utils_1.Logger.debug(`Switched to provider at the index ${this.currentProviderIndex}`);
      }
      get currentProvider() {
        const provider = this.providers[this.currentProviderIndex];
        if (!provider)
          throw new Error(`Provider wasn't found at index ${this.currentProviderIndex}`);
        return provider;
      }
      async withBackoff(getResult) {
        for (let i = 0; i < this.providers.length; i++) {
          try {
            const result = await getResult(this.currentProvider);
            if (result)
              return result;
          } catch (e) {
            console.error(e);
            this.switchToNextProvider();
          }
        }
        throw new types_1.TypedError(`Exceeded ${this.providers.length} providers to execute request`, "RetriesExceeded");
      }
      /**
       * Gets the RPC's status
       * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
       */
      async status() {
        return this.withBackoff((currentProvider) => currentProvider.status());
      }
      async sendTransactionUntil(signedTransaction, waitUntil) {
        return this.withBackoff((currentProvider) => currentProvider.sendTransactionUntil(signedTransaction, waitUntil));
      }
      /**
       * Sends a signed transaction to the RPC and waits until transaction is fully complete
       * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
       *
       * @param signedTransaction The signed transaction being sent
       */
      async sendTransaction(signedTransaction) {
        return this.withBackoff((currentProvider) => currentProvider.sendTransaction(signedTransaction));
      }
      /**
       * Sends a signed transaction to the RPC and immediately returns transaction hash
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
       * @param signedTransaction The signed transaction being sent
       * @returns {Promise<FinalExecutionOutcome>}
       */
      async sendTransactionAsync(signedTransaction) {
        return this.withBackoff((currentProvider) => currentProvider.sendTransactionAsync(signedTransaction));
      }
      /**
       * Gets a transaction's status from the RPC
       * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
       *
       * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
       * @param accountId The NEAR account that signed the transaction
       */
      async txStatus(txHash, accountId, waitUntil) {
        return this.withBackoff((currentProvider) => currentProvider.txStatus(txHash, accountId, waitUntil));
      }
      /**
       * Gets a transaction's status from the RPC with receipts
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
       * @param txHash The hash of the transaction
       * @param accountId The NEAR account that signed the transaction
       * @returns {Promise<FinalExecutionOutcome>}
       */
      async txStatusReceipts(txHash, accountId, waitUntil) {
        return this.withBackoff((currentProvider) => currentProvider.txStatusReceipts(txHash, accountId, waitUntil));
      }
      async query(paramsOrPath, data) {
        if (data) {
          return this.withBackoff((currentProvider) => currentProvider.query(paramsOrPath, data));
        }
        return this.withBackoff((currentProvider) => currentProvider.query(paramsOrPath));
      }
      /**
       * Query for block info from the RPC
       * pass block_id OR finality as blockQuery, not both
       * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
       *
       * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
       */
      async block(blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.block(blockQuery));
      }
      /**
       * Query changes in block from the RPC
       * pass block_id OR finality as blockQuery, not both
       * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
       */
      async blockChanges(blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.blockChanges(blockQuery));
      }
      /**
       * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
       * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
       *
       * @param chunkId Hash of a chunk ID or shard ID
       */
      async chunk(chunkId) {
        return this.withBackoff((currentProvider) => currentProvider.chunk(chunkId));
      }
      /**
       * Query validators of the epoch defined by the given block id.
       * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
       *
       * @param blockId Block hash or height, or null for latest.
       */
      async validators(blockId) {
        return this.withBackoff((currentProvider) => currentProvider.validators(blockId));
      }
      /**
       * Gets the protocol config at a block from RPC
       *
       * @param blockReference specifies the block to get the protocol config for
       */
      async experimental_protocolConfig(blockReference) {
        return this.withBackoff((currentProvider) => currentProvider.experimental_protocolConfig(blockReference));
      }
      /**
       * Gets a light client execution proof for verifying execution outcomes
       * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
       */
      async lightClientProof(request) {
        return this.withBackoff((currentProvider) => currentProvider.lightClientProof(request));
      }
      /**
       * Returns the next light client block as far in the future as possible from the last known hash
       * to still be able to validate from that hash. This will either return the last block of the
       * next epoch, or the last final known block.
       *
       * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
       */
      async nextLightClientBlock(request) {
        return this.withBackoff((currentProvider) => currentProvider.nextLightClientBlock(request));
      }
      /**
       * Gets access key changes for a given array of accountIds
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
       * @returns {Promise<ChangeResult>}
       */
      async accessKeyChanges(accountIdArray, blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.accessKeyChanges(accountIdArray, blockQuery));
      }
      /**
       * Gets single access key changes for a given array of access keys
       * pass block_id OR finality as blockQuery, not both
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
       * @returns {Promise<ChangeResult>}
       */
      async singleAccessKeyChanges(accessKeyArray, blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.singleAccessKeyChanges(accessKeyArray, blockQuery));
      }
      /**
       * Gets account changes for a given array of accountIds
       * pass block_id OR finality as blockQuery, not both
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
       * @returns {Promise<ChangeResult>}
       */
      async accountChanges(accountIdArray, blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.accountChanges(accountIdArray, blockQuery));
      }
      /**
       * Gets contract state changes for a given array of accountIds
       * pass block_id OR finality as blockQuery, not both
       * Note: If you pass a keyPrefix it must be base64 encoded
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
       * @returns {Promise<ChangeResult>}
       */
      async contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
        return this.withBackoff((currentProvider) => currentProvider.contractStateChanges(accountIdArray, blockQuery, keyPrefix));
      }
      /**
       * Gets contract code changes for a given array of accountIds
       * pass block_id OR finality as blockQuery, not both
       * Note: Change is returned in a base64 encoded WASM file
       * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
       * @returns {Promise<ChangeResult>}
       */
      async contractCodeChanges(accountIdArray, blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.contractCodeChanges(accountIdArray, blockQuery));
      }
      /**
       * Returns gas price for a specific block_height or block_hash.
       * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
       *
       * @param blockId Block hash or height, or null for latest.
       */
      async gasPrice(blockId) {
        return this.withBackoff((currentProvider) => currentProvider.gasPrice(blockId));
      }
    };
    exports.FailoverRpcProvider = FailoverRpcProvider;
  }
});

// node_modules/@near-js/providers/lib/commonjs/index.cjs
var require_commonjs7 = __commonJS({
  "node_modules/@near-js/providers/lib/commonjs/index.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Provider = exports.FailoverRpcProvider = exports.JsonRpcProvider = exports.exponentialBackoff = void 0;
    var exponential_backoff_1 = require_exponential_backoff();
    Object.defineProperty(exports, "exponentialBackoff", { enumerable: true, get: function() {
      return exponential_backoff_1.exponentialBackoff;
    } });
    var json_rpc_provider_1 = require_json_rpc_provider();
    Object.defineProperty(exports, "JsonRpcProvider", { enumerable: true, get: function() {
      return json_rpc_provider_1.JsonRpcProvider;
    } });
    var failover_rpc_provider_1 = require_failover_rpc_provider();
    Object.defineProperty(exports, "FailoverRpcProvider", { enumerable: true, get: function() {
      return failover_rpc_provider_1.FailoverRpcProvider;
    } });
    var provider_1 = require_provider();
    Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
      return provider_1.Provider;
    } });
  }
});

// node_modules/near-api-js/lib/providers/provider.js
var require_provider2 = __commonJS({
  "node_modules/near-api-js/lib/providers/provider.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FinalExecutionStatusBasic = exports.ExecutionStatusBasic = exports.IdType = exports.Provider = exports.getTransactionLastResult = void 0;
    var utils_1 = require_commonjs2();
    Object.defineProperty(exports, "getTransactionLastResult", { enumerable: true, get: function() {
      return utils_1.getTransactionLastResult;
    } });
    var providers_1 = require_commonjs7();
    Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
      return providers_1.Provider;
    } });
    var types_1 = require_commonjs();
    Object.defineProperty(exports, "IdType", { enumerable: true, get: function() {
      return types_1.IdType;
    } });
    Object.defineProperty(exports, "ExecutionStatusBasic", { enumerable: true, get: function() {
      return types_1.ExecutionStatusBasic;
    } });
    Object.defineProperty(exports, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
      return types_1.FinalExecutionStatusBasic;
    } });
  }
});

// node_modules/near-api-js/lib/providers/json-rpc-provider.js
var require_json_rpc_provider2 = __commonJS({
  "node_modules/near-api-js/lib/providers/json-rpc-provider.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcProvider = exports.TypedError = exports.ErrorContext = void 0;
    var types_1 = require_commonjs();
    Object.defineProperty(exports, "ErrorContext", { enumerable: true, get: function() {
      return types_1.ErrorContext;
    } });
    Object.defineProperty(exports, "TypedError", { enumerable: true, get: function() {
      return types_1.TypedError;
    } });
    var providers_1 = require_commonjs7();
    Object.defineProperty(exports, "JsonRpcProvider", { enumerable: true, get: function() {
      return providers_1.JsonRpcProvider;
    } });
  }
});

// node_modules/near-api-js/lib/providers/failover-rpc-provider.js
var require_failover_rpc_provider2 = __commonJS({
  "node_modules/near-api-js/lib/providers/failover-rpc-provider.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FailoverRpcProvider = void 0;
    var providers_1 = require_commonjs7();
    Object.defineProperty(exports, "FailoverRpcProvider", { enumerable: true, get: function() {
      return providers_1.FailoverRpcProvider;
    } });
  }
});

// node_modules/near-api-js/lib/providers/index.js
var require_providers = __commonJS({
  "node_modules/near-api-js/lib/providers/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorContext = exports.TypedError = exports.getTransactionLastResult = exports.FinalExecutionStatusBasic = exports.FailoverRpcProvider = exports.JsonRpcProvider = exports.Provider = void 0;
    var provider_1 = require_provider2();
    Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
      return provider_1.Provider;
    } });
    Object.defineProperty(exports, "getTransactionLastResult", { enumerable: true, get: function() {
      return provider_1.getTransactionLastResult;
    } });
    Object.defineProperty(exports, "FinalExecutionStatusBasic", { enumerable: true, get: function() {
      return provider_1.FinalExecutionStatusBasic;
    } });
    var json_rpc_provider_1 = require_json_rpc_provider2();
    Object.defineProperty(exports, "JsonRpcProvider", { enumerable: true, get: function() {
      return json_rpc_provider_1.JsonRpcProvider;
    } });
    Object.defineProperty(exports, "TypedError", { enumerable: true, get: function() {
      return json_rpc_provider_1.TypedError;
    } });
    Object.defineProperty(exports, "ErrorContext", { enumerable: true, get: function() {
      return json_rpc_provider_1.ErrorContext;
    } });
    var failover_rpc_provider_1 = require_failover_rpc_provider2();
    Object.defineProperty(exports, "FailoverRpcProvider", { enumerable: true, get: function() {
      return failover_rpc_provider_1.FailoverRpcProvider;
    } });
  }
});

// node_modules/near-api-js/node_modules/borsh/lib/cjs/types.js
var require_types2 = __commonJS({
  "node_modules/near-api-js/node_modules/borsh/lib/cjs/types.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    exports.__esModule = true;
    exports.integers = void 0;
    exports.integers = ["u8", "u16", "u32", "u64", "u128", "i8", "i16", "i32", "i64", "i128", "f32", "f64"];
  }
});

// node_modules/near-api-js/node_modules/borsh/lib/cjs/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/near-api-js/node_modules/borsh/lib/cjs/buffer.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    exports.__esModule = true;
    exports.DecodeBuffer = exports.EncodeBuffer = void 0;
    var EncodeBuffer = (
      /** @class */
      function() {
        function EncodeBuffer2() {
          this.offset = 0;
          this.buffer_size = 256;
          this.buffer = new ArrayBuffer(this.buffer_size);
          this.view = new DataView(this.buffer);
        }
        EncodeBuffer2.prototype.resize_if_necessary = function(needed_space) {
          if (this.buffer_size - this.offset < needed_space) {
            this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
            var new_buffer = new ArrayBuffer(this.buffer_size);
            new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
            this.buffer = new_buffer;
            this.view = new DataView(new_buffer);
          }
        };
        EncodeBuffer2.prototype.get_used_buffer = function() {
          return new Uint8Array(this.buffer).slice(0, this.offset);
        };
        EncodeBuffer2.prototype.store_value = function(value, type) {
          var bSize = type.substring(1);
          var size = parseInt(bSize) / 8;
          this.resize_if_necessary(size);
          var toCall = type[0] === "f" ? "setFloat".concat(bSize) : type[0] === "i" ? "setInt".concat(bSize) : "setUint".concat(bSize);
          this.view[toCall](this.offset, value, true);
          this.offset += size;
        };
        EncodeBuffer2.prototype.store_bytes = function(from) {
          this.resize_if_necessary(from.length);
          new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
          this.offset += from.length;
        };
        return EncodeBuffer2;
      }()
    );
    exports.EncodeBuffer = EncodeBuffer;
    var DecodeBuffer = (
      /** @class */
      function() {
        function DecodeBuffer2(buf) {
          this.offset = 0;
          this.buffer_size = buf.length;
          this.buffer = new ArrayBuffer(buf.length);
          new Uint8Array(this.buffer).set(buf);
          this.view = new DataView(this.buffer);
        }
        DecodeBuffer2.prototype.assert_enough_buffer = function(size) {
          if (this.offset + size > this.buffer.byteLength) {
            throw new Error("Error in schema, the buffer is smaller than expected");
          }
        };
        DecodeBuffer2.prototype.consume_value = function(type) {
          var bSize = type.substring(1);
          var size = parseInt(bSize) / 8;
          this.assert_enough_buffer(size);
          var toCall = type[0] === "f" ? "getFloat".concat(bSize) : type[0] === "i" ? "getInt".concat(bSize) : "getUint".concat(bSize);
          var ret = this.view[toCall](this.offset, true);
          this.offset += size;
          return ret;
        };
        DecodeBuffer2.prototype.consume_bytes = function(size) {
          this.assert_enough_buffer(size);
          var ret = this.buffer.slice(this.offset, this.offset + size);
          this.offset += size;
          return ret;
        };
        return DecodeBuffer2;
      }()
    );
    exports.DecodeBuffer = DecodeBuffer;
  }
});

// node_modules/near-api-js/node_modules/borsh/lib/cjs/utils.js
var require_utils3 = __commonJS({
  "node_modules/near-api-js/node_modules/borsh/lib/cjs/utils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports.__esModule = true;
    exports.validate_schema = exports.ErrorSchema = exports.expect_enum = exports.expect_same_size = exports.expect_bigint = exports.expect_type = exports.isArrayLike = void 0;
    var types_js_1 = require_types2();
    function isArrayLike(value) {
      return Array.isArray(value) || !!value && typeof value === "object" && "length" in value && typeof value.length === "number" && (value.length === 0 || value.length > 0 && value.length - 1 in value);
    }
    exports.isArrayLike = isArrayLike;
    function expect_type(value, type, fieldPath) {
      if (typeof value !== type) {
        throw new Error("Expected ".concat(type, " not ").concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_type = expect_type;
    function expect_bigint(value, fieldPath) {
      var basicType = ["number", "string", "bigint", "boolean"].includes(typeof value);
      var strObject = typeof value === "object" && value !== null && "toString" in value;
      if (!basicType && !strObject) {
        throw new Error("Expected bigint, number, boolean or string not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_bigint = expect_bigint;
    function expect_same_size(length, expected, fieldPath) {
      if (length !== expected) {
        throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_same_size = expect_same_size;
    function expect_enum(value, fieldPath) {
      if (typeof value !== "object" || value === null) {
        throw new Error("Expected object not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_enum = expect_enum;
    var VALID_STRING_TYPES = types_js_1.integers.concat(["bool", "string"]);
    var VALID_OBJECT_KEYS = ["option", "enum", "array", "set", "map", "struct"];
    var ErrorSchema = (
      /** @class */
      function(_super) {
        __extends(ErrorSchema2, _super);
        function ErrorSchema2(schema, expected) {
          var message = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
          return _super.call(this, message) || this;
        }
        return ErrorSchema2;
      }(Error)
    );
    exports.ErrorSchema = ErrorSchema;
    function validate_schema(schema) {
      if (typeof schema === "string" && VALID_STRING_TYPES.includes(schema)) {
        return;
      }
      if (schema && typeof schema === "object") {
        var keys = Object.keys(schema);
        if (keys.length === 1 && VALID_OBJECT_KEYS.includes(keys[0])) {
          var key = keys[0];
          if (key === "option")
            return validate_schema(schema[key]);
          if (key === "enum")
            return validate_enum_schema(schema[key]);
          if (key === "array")
            return validate_array_schema(schema[key]);
          if (key === "set")
            return validate_schema(schema[key]);
          if (key === "map")
            return validate_map_schema(schema[key]);
          if (key === "struct")
            return validate_struct_schema(schema[key]);
        }
      }
      throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(", ") + " or " + VALID_STRING_TYPES.join(", "));
    }
    exports.validate_schema = validate_schema;
    function validate_enum_schema(schema) {
      if (!Array.isArray(schema))
        throw new ErrorSchema(schema, "Array");
      for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
        var sch = schema_1[_i];
        if (typeof sch !== "object" || !("struct" in sch)) {
          throw new Error('Missing "struct" key in enum schema');
        }
        if (typeof sch.struct !== "object" || Object.keys(sch.struct).length !== 1) {
          throw new Error('The "struct" in each enum must have a single key');
        }
        validate_schema({ struct: sch.struct });
      }
    }
    function validate_array_schema(schema) {
      if (typeof schema !== "object")
        throw new ErrorSchema(schema, "{ type, len? }");
      if (schema.len && typeof schema.len !== "number") {
        throw new Error("Invalid schema: ".concat(schema));
      }
      if ("type" in schema)
        return validate_schema(schema.type);
      throw new ErrorSchema(schema, "{ type, len? }");
    }
    function validate_map_schema(schema) {
      if (typeof schema === "object" && "key" in schema && "value" in schema) {
        validate_schema(schema.key);
        validate_schema(schema.value);
      } else {
        throw new ErrorSchema(schema, "{ key, value }");
      }
    }
    function validate_struct_schema(schema) {
      if (typeof schema !== "object")
        throw new ErrorSchema(schema, "object");
      for (var key in schema) {
        validate_schema(schema[key]);
      }
    }
  }
});

// node_modules/near-api-js/node_modules/borsh/lib/cjs/serialize.js
var require_serialize2 = __commonJS({
  "node_modules/near-api-js/node_modules/borsh/lib/cjs/serialize.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    exports.__esModule = true;
    exports.BorshSerializer = void 0;
    var types_js_1 = require_types2();
    var buffer_js_1 = require_buffer2();
    var utils = __importStar(require_utils3());
    var BorshSerializer = (
      /** @class */
      function() {
        function BorshSerializer2(checkTypes) {
          this.encoded = new buffer_js_1.EncodeBuffer();
          this.fieldPath = ["value"];
          this.checkTypes = checkTypes;
        }
        BorshSerializer2.prototype.encode = function(value, schema) {
          this.encode_value(value, schema);
          return this.encoded.get_used_buffer();
        };
        BorshSerializer2.prototype.encode_value = function(value, schema) {
          if (typeof schema === "string") {
            if (types_js_1.integers.includes(schema))
              return this.encode_integer(value, schema);
            if (schema === "string")
              return this.encode_string(value);
            if (schema === "bool")
              return this.encode_boolean(value);
          }
          if (typeof schema === "object") {
            if ("option" in schema)
              return this.encode_option(value, schema);
            if ("enum" in schema)
              return this.encode_enum(value, schema);
            if ("array" in schema)
              return this.encode_array(value, schema);
            if ("set" in schema)
              return this.encode_set(value, schema);
            if ("map" in schema)
              return this.encode_map(value, schema);
            if ("struct" in schema)
              return this.encode_struct(value, schema);
          }
        };
        BorshSerializer2.prototype.encode_integer = function(value, schema) {
          var size = parseInt(schema.substring(1));
          if (size <= 32 || schema == "f64") {
            this.checkTypes && utils.expect_type(value, "number", this.fieldPath);
            this.encoded.store_value(value, schema);
          } else {
            this.checkTypes && utils.expect_bigint(value, this.fieldPath);
            this.encode_bigint(BigInt(value), size);
          }
        };
        BorshSerializer2.prototype.encode_bigint = function(value, size) {
          var buffer_len = size / 8;
          var buffer = new Uint8Array(buffer_len);
          for (var i = 0; i < buffer_len; i++) {
            buffer[i] = Number(value & BigInt(255));
            value = value >> BigInt(8);
          }
          this.encoded.store_bytes(new Uint8Array(buffer));
        };
        BorshSerializer2.prototype.encode_string = function(value) {
          this.checkTypes && utils.expect_type(value, "string", this.fieldPath);
          var _value = value;
          this.encoded.store_value(_value.length, "u32");
          for (var i = 0; i < _value.length; i++) {
            this.encoded.store_value(_value.charCodeAt(i), "u8");
          }
        };
        BorshSerializer2.prototype.encode_boolean = function(value) {
          this.checkTypes && utils.expect_type(value, "boolean", this.fieldPath);
          this.encoded.store_value(value ? 1 : 0, "u8");
        };
        BorshSerializer2.prototype.encode_option = function(value, schema) {
          if (value === null || value === void 0) {
            this.encoded.store_value(0, "u8");
          } else {
            this.encoded.store_value(1, "u8");
            this.encode_value(value, schema.option);
          }
        };
        BorshSerializer2.prototype.encode_enum = function(value, schema) {
          this.checkTypes && utils.expect_enum(value, this.fieldPath);
          var valueKey = Object.keys(value)[0];
          for (var i = 0; i < schema["enum"].length; i++) {
            var valueSchema = schema["enum"][i];
            if (valueKey === Object.keys(valueSchema.struct)[0]) {
              this.encoded.store_value(i, "u8");
              return this.encode_struct(value, valueSchema);
            }
          }
          throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join(".")));
        };
        BorshSerializer2.prototype.encode_array = function(value, schema) {
          if (utils.isArrayLike(value))
            return this.encode_arraylike(value, schema);
          if (value instanceof ArrayBuffer)
            return this.encode_buffer(value, schema);
          throw new Error("Expected Array-like not ".concat(typeof value, "(").concat(value, ") at ").concat(this.fieldPath.join(".")));
        };
        BorshSerializer2.prototype.encode_arraylike = function(value, schema) {
          if (schema.array.len) {
            utils.expect_same_size(value.length, schema.array.len, this.fieldPath);
          } else {
            this.encoded.store_value(value.length, "u32");
          }
          for (var i = 0; i < value.length; i++) {
            this.encode_value(value[i], schema.array.type);
          }
        };
        BorshSerializer2.prototype.encode_buffer = function(value, schema) {
          if (schema.array.len) {
            utils.expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
          } else {
            this.encoded.store_value(value.byteLength, "u32");
          }
          this.encoded.store_bytes(new Uint8Array(value));
        };
        BorshSerializer2.prototype.encode_set = function(value, schema) {
          this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
          var isSet = value instanceof Set;
          var values = isSet ? Array.from(value.values()) : Object.values(value);
          this.encoded.store_value(values.length, "u32");
          for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value_1 = values_1[_i];
            this.encode_value(value_1, schema.set);
          }
        };
        BorshSerializer2.prototype.encode_map = function(value, schema) {
          this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
          var isMap = value instanceof Map;
          var keys = isMap ? Array.from(value.keys()) : Object.keys(value);
          this.encoded.store_value(keys.length, "u32");
          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            this.encode_value(key, schema.map.key);
            this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
          }
        };
        BorshSerializer2.prototype.encode_struct = function(value, schema) {
          this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
          for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
            var key = _a[_i];
            this.fieldPath.push(key);
            this.encode_value(value[key], schema.struct[key]);
            this.fieldPath.pop();
          }
        };
        return BorshSerializer2;
      }()
    );
    exports.BorshSerializer = BorshSerializer;
  }
});

// node_modules/near-api-js/node_modules/borsh/lib/cjs/deserialize.js
var require_deserialize2 = __commonJS({
  "node_modules/near-api-js/node_modules/borsh/lib/cjs/deserialize.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    exports.__esModule = true;
    exports.BorshDeserializer = void 0;
    var types_js_1 = require_types2();
    var buffer_js_1 = require_buffer2();
    var BorshDeserializer = (
      /** @class */
      function() {
        function BorshDeserializer2(bufferArray) {
          this.buffer = new buffer_js_1.DecodeBuffer(bufferArray);
        }
        BorshDeserializer2.prototype.decode = function(schema) {
          return this.decode_value(schema);
        };
        BorshDeserializer2.prototype.decode_value = function(schema) {
          if (typeof schema === "string") {
            if (types_js_1.integers.includes(schema))
              return this.decode_integer(schema);
            if (schema === "string")
              return this.decode_string();
            if (schema === "bool")
              return this.decode_boolean();
          }
          if (typeof schema === "object") {
            if ("option" in schema)
              return this.decode_option(schema);
            if ("enum" in schema)
              return this.decode_enum(schema);
            if ("array" in schema)
              return this.decode_array(schema);
            if ("set" in schema)
              return this.decode_set(schema);
            if ("map" in schema)
              return this.decode_map(schema);
            if ("struct" in schema)
              return this.decode_struct(schema);
          }
          throw new Error("Unsupported type: ".concat(schema));
        };
        BorshDeserializer2.prototype.decode_integer = function(schema) {
          var size = parseInt(schema.substring(1));
          if (size <= 32 || schema == "f64") {
            return this.buffer.consume_value(schema);
          }
          return this.decode_bigint(size, schema.startsWith("i"));
        };
        BorshDeserializer2.prototype.decode_bigint = function(size, signed) {
          if (signed === void 0) {
            signed = false;
          }
          var buffer_len = size / 8;
          var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
          var bits = buffer.reduceRight(function(r, x) {
            return r + x.toString(16).padStart(2, "0");
          }, "");
          if (signed && buffer[buffer_len - 1]) {
            return BigInt.asIntN(size, BigInt("0x".concat(bits)));
          }
          return BigInt("0x".concat(bits));
        };
        BorshDeserializer2.prototype.decode_string = function() {
          var len = this.decode_integer("u32");
          var buffer = new Uint8Array(this.buffer.consume_bytes(len));
          return String.fromCharCode.apply(null, buffer);
        };
        BorshDeserializer2.prototype.decode_boolean = function() {
          return this.buffer.consume_value("u8") > 0;
        };
        BorshDeserializer2.prototype.decode_option = function(schema) {
          var option = this.buffer.consume_value("u8");
          if (option === 1) {
            return this.decode_value(schema.option);
          }
          if (option !== 0) {
            throw new Error("Invalid option ".concat(option));
          }
          return null;
        };
        BorshDeserializer2.prototype.decode_enum = function(schema) {
          var _a;
          var valueIndex = this.buffer.consume_value("u8");
          if (valueIndex > schema["enum"].length) {
            throw new Error("Enum option ".concat(valueIndex, " is not available"));
          }
          var struct = schema["enum"][valueIndex].struct;
          var key = Object.keys(struct)[0];
          return _a = {}, _a[key] = this.decode_value(struct[key]), _a;
        };
        BorshDeserializer2.prototype.decode_array = function(schema) {
          var result = [];
          var len = schema.array.len ? schema.array.len : this.decode_integer("u32");
          for (var i = 0; i < len; ++i) {
            result.push(this.decode_value(schema.array.type));
          }
          return result;
        };
        BorshDeserializer2.prototype.decode_set = function(schema) {
          var len = this.decode_integer("u32");
          var result = /* @__PURE__ */ new Set();
          for (var i = 0; i < len; ++i) {
            result.add(this.decode_value(schema.set));
          }
          return result;
        };
        BorshDeserializer2.prototype.decode_map = function(schema) {
          var len = this.decode_integer("u32");
          var result = /* @__PURE__ */ new Map();
          for (var i = 0; i < len; ++i) {
            var key = this.decode_value(schema.map.key);
            var value = this.decode_value(schema.map.value);
            result.set(key, value);
          }
          return result;
        };
        BorshDeserializer2.prototype.decode_struct = function(schema) {
          var result = {};
          for (var key in schema.struct) {
            result[key] = this.decode_value(schema.struct[key]);
          }
          return result;
        };
        return BorshDeserializer2;
      }()
    );
    exports.BorshDeserializer = BorshDeserializer;
  }
});

// node_modules/near-api-js/node_modules/borsh/lib/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/near-api-js/node_modules/borsh/lib/cjs/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    exports.__esModule = true;
    exports.deserialize = exports.serialize = void 0;
    var serialize_js_1 = require_serialize2();
    var deserialize_js_1 = require_deserialize2();
    var utils = __importStar(require_utils3());
    function serialize(schema, value, validate) {
      if (validate === void 0) {
        validate = true;
      }
      if (validate)
        utils.validate_schema(schema);
      var serializer = new serialize_js_1.BorshSerializer(validate);
      return serializer.encode(value, schema);
    }
    exports.serialize = serialize;
    function deserialize(schema, buffer, validate) {
      if (validate === void 0) {
        validate = true;
      }
      if (validate)
        utils.validate_schema(schema);
      var deserializer = new deserialize_js_1.BorshDeserializer(buffer);
      return deserializer.decode(schema);
    }
    exports.deserialize = deserialize;
  }
});

// node_modules/near-api-js/lib/utils/serialize.js
var require_serialize3 = __commonJS({
  "node_modules/near-api-js/lib/utils/serialize.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base_decode = exports.base_encode = exports.deserialize = exports.serialize = void 0;
    var borsh_1 = require_cjs2();
    Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
      return borsh_1.serialize;
    } });
    Object.defineProperty(exports, "deserialize", { enumerable: true, get: function() {
      return borsh_1.deserialize;
    } });
    var utils_1 = require_commonjs2();
    Object.defineProperty(exports, "base_encode", { enumerable: true, get: function() {
      return utils_1.baseEncode;
    } });
    Object.defineProperty(exports, "base_decode", { enumerable: true, get: function() {
      return utils_1.baseDecode;
    } });
  }
});

// node_modules/near-api-js/lib/utils/enums.js
var require_enums = __commonJS({
  "node_modules/near-api-js/lib/utils/enums.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Enum = void 0;
    var types_1 = require_commonjs();
    Object.defineProperty(exports, "Enum", { enumerable: true, get: function() {
      return types_1.Enum;
    } });
  }
});

// node_modules/near-api-js/lib/utils/format.js
var require_format = __commonJS({
  "node_modules/near-api-js/lib/utils/format.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseNearAmount = exports.formatNearAmount = exports.NEAR_NOMINATION_EXP = exports.NEAR_NOMINATION = void 0;
    var utils_1 = require_commonjs2();
    Object.defineProperty(exports, "NEAR_NOMINATION", { enumerable: true, get: function() {
      return utils_1.NEAR_NOMINATION;
    } });
    Object.defineProperty(exports, "NEAR_NOMINATION_EXP", { enumerable: true, get: function() {
      return utils_1.NEAR_NOMINATION_EXP;
    } });
    Object.defineProperty(exports, "formatNearAmount", { enumerable: true, get: function() {
      return utils_1.formatNearAmount;
    } });
    Object.defineProperty(exports, "parseNearAmount", { enumerable: true, get: function() {
      return utils_1.parseNearAmount;
    } });
  }
});

// node_modules/near-api-js/lib/utils/rpc_errors.js
var require_rpc_errors = __commonJS({
  "node_modules/near-api-js/lib/utils/rpc_errors.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerError = exports.getErrorTypeFromErrorMessage = exports.formatError = exports.parseResultError = exports.parseRpcError = void 0;
    var utils_1 = require_commonjs2();
    Object.defineProperty(exports, "parseRpcError", { enumerable: true, get: function() {
      return utils_1.parseRpcError;
    } });
    Object.defineProperty(exports, "parseResultError", { enumerable: true, get: function() {
      return utils_1.parseResultError;
    } });
    Object.defineProperty(exports, "formatError", { enumerable: true, get: function() {
      return utils_1.formatError;
    } });
    Object.defineProperty(exports, "getErrorTypeFromErrorMessage", { enumerable: true, get: function() {
      return utils_1.getErrorTypeFromErrorMessage;
    } });
    Object.defineProperty(exports, "ServerError", { enumerable: true, get: function() {
      return utils_1.ServerError;
    } });
  }
});

// node_modules/near-api-js/lib/utils/logger.js
var require_logger = __commonJS({
  "node_modules/near-api-js/lib/utils/logger.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = void 0;
    var utils_1 = require_commonjs2();
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return utils_1.Logger;
    } });
  }
});

// node_modules/near-api-js/lib/utils/index.js
var require_utils4 = __commonJS({
  "node_modules/near-api-js/lib/utils/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = exports.rpc_errors = exports.KeyPairEd25519 = exports.KeyPair = exports.PublicKey = exports.format = exports.enums = exports.serialize = exports.key_pair = void 0;
    var key_pair = __importStar(require_key_pair());
    exports.key_pair = key_pair;
    var serialize = __importStar(require_serialize3());
    exports.serialize = serialize;
    var enums = __importStar(require_enums());
    exports.enums = enums;
    var format = __importStar(require_format());
    exports.format = format;
    var rpc_errors = __importStar(require_rpc_errors());
    exports.rpc_errors = rpc_errors;
    var key_pair_1 = require_key_pair();
    Object.defineProperty(exports, "PublicKey", { enumerable: true, get: function() {
      return key_pair_1.PublicKey;
    } });
    Object.defineProperty(exports, "KeyPair", { enumerable: true, get: function() {
      return key_pair_1.KeyPair;
    } });
    Object.defineProperty(exports, "KeyPairEd25519", { enumerable: true, get: function() {
      return key_pair_1.KeyPairEd25519;
    } });
    var logger_1 = require_logger();
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
  }
});

// node_modules/near-api-js/lib/transaction.js
var require_transaction = __commonJS({
  "node_modules/near-api-js/lib/transaction.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transfer = exports.stake = exports.functionCallAccessKey = exports.functionCall = exports.fullAccessKey = exports.deployContract = exports.deleteKey = exports.deleteAccount = exports.createAccount = exports.addKey = exports.encodeTransaction = exports.encodeDelegateAction = exports.encodeSignedDelegate = exports.Transaction = exports.SignedTransaction = exports.Signature = exports.signTransaction = exports.createTransaction = exports.SCHEMA = exports.Transfer = exports.Stake = exports.FunctionCallPermission = exports.FunctionCall = exports.FullAccessPermission = exports.DeployContract = exports.DeleteKey = exports.DeleteAccount = exports.CreateAccount = exports.AddKey = exports.AccessKeyPermission = exports.AccessKey = exports.Action = exports.stringifyJsonOrBytes = void 0;
    var transactions_1 = require_commonjs6();
    Object.defineProperty(exports, "stringifyJsonOrBytes", { enumerable: true, get: function() {
      return transactions_1.stringifyJsonOrBytes;
    } });
    Object.defineProperty(exports, "Action", { enumerable: true, get: function() {
      return transactions_1.Action;
    } });
    Object.defineProperty(exports, "AccessKey", { enumerable: true, get: function() {
      return transactions_1.AccessKey;
    } });
    Object.defineProperty(exports, "AccessKeyPermission", { enumerable: true, get: function() {
      return transactions_1.AccessKeyPermission;
    } });
    Object.defineProperty(exports, "AddKey", { enumerable: true, get: function() {
      return transactions_1.AddKey;
    } });
    Object.defineProperty(exports, "CreateAccount", { enumerable: true, get: function() {
      return transactions_1.CreateAccount;
    } });
    Object.defineProperty(exports, "DeleteAccount", { enumerable: true, get: function() {
      return transactions_1.DeleteAccount;
    } });
    Object.defineProperty(exports, "DeleteKey", { enumerable: true, get: function() {
      return transactions_1.DeleteKey;
    } });
    Object.defineProperty(exports, "DeployContract", { enumerable: true, get: function() {
      return transactions_1.DeployContract;
    } });
    Object.defineProperty(exports, "FullAccessPermission", { enumerable: true, get: function() {
      return transactions_1.FullAccessPermission;
    } });
    Object.defineProperty(exports, "FunctionCall", { enumerable: true, get: function() {
      return transactions_1.FunctionCall;
    } });
    Object.defineProperty(exports, "FunctionCallPermission", { enumerable: true, get: function() {
      return transactions_1.FunctionCallPermission;
    } });
    Object.defineProperty(exports, "Stake", { enumerable: true, get: function() {
      return transactions_1.Stake;
    } });
    Object.defineProperty(exports, "Transfer", { enumerable: true, get: function() {
      return transactions_1.Transfer;
    } });
    Object.defineProperty(exports, "SCHEMA", { enumerable: true, get: function() {
      return transactions_1.SCHEMA;
    } });
    Object.defineProperty(exports, "createTransaction", { enumerable: true, get: function() {
      return transactions_1.createTransaction;
    } });
    Object.defineProperty(exports, "signTransaction", { enumerable: true, get: function() {
      return transactions_1.signTransaction;
    } });
    Object.defineProperty(exports, "Signature", { enumerable: true, get: function() {
      return transactions_1.Signature;
    } });
    Object.defineProperty(exports, "SignedTransaction", { enumerable: true, get: function() {
      return transactions_1.SignedTransaction;
    } });
    Object.defineProperty(exports, "Transaction", { enumerable: true, get: function() {
      return transactions_1.Transaction;
    } });
    Object.defineProperty(exports, "encodeSignedDelegate", { enumerable: true, get: function() {
      return transactions_1.encodeSignedDelegate;
    } });
    Object.defineProperty(exports, "encodeDelegateAction", { enumerable: true, get: function() {
      return transactions_1.encodeDelegateAction;
    } });
    Object.defineProperty(exports, "encodeTransaction", { enumerable: true, get: function() {
      return transactions_1.encodeTransaction;
    } });
    var transactions_2 = require_commonjs6();
    var addKey = (publicKey, accessKey) => transactions_2.actionCreators.addKey(publicKey, accessKey);
    exports.addKey = addKey;
    var createAccount = () => transactions_2.actionCreators.createAccount();
    exports.createAccount = createAccount;
    var deleteAccount = (beneficiaryId) => transactions_2.actionCreators.deleteAccount(beneficiaryId);
    exports.deleteAccount = deleteAccount;
    var deleteKey = (publicKey) => transactions_2.actionCreators.deleteKey(publicKey);
    exports.deleteKey = deleteKey;
    var deployContract = (code) => transactions_2.actionCreators.deployContract(code);
    exports.deployContract = deployContract;
    var fullAccessKey = () => transactions_2.actionCreators.fullAccessKey();
    exports.fullAccessKey = fullAccessKey;
    var functionCall = (methodName, args, gas, deposit, stringify, jsContract) => transactions_2.actionCreators.functionCall(methodName, args, gas, deposit, stringify, jsContract);
    exports.functionCall = functionCall;
    var functionCallAccessKey = (receiverId, methodNames, allowance) => transactions_2.actionCreators.functionCallAccessKey(receiverId, methodNames, allowance);
    exports.functionCallAccessKey = functionCallAccessKey;
    var stake = (stake2, publicKey) => transactions_2.actionCreators.stake(stake2, publicKey);
    exports.stake = stake;
    var transfer = (deposit) => transactions_2.actionCreators.transfer(deposit);
    exports.transfer = transfer;
  }
});

// node_modules/near-api-js/lib/validators.js
var require_validators = __commonJS({
  "node_modules/near-api-js/lib/validators.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findSeatPrice = exports.diffEpochValidators = void 0;
    var utils_1 = require_commonjs2();
    Object.defineProperty(exports, "diffEpochValidators", { enumerable: true, get: function() {
      return utils_1.diffEpochValidators;
    } });
    Object.defineProperty(exports, "findSeatPrice", { enumerable: true, get: function() {
      return utils_1.findSeatPrice;
    } });
  }
});

// node_modules/@near-js/accounts/lib/commonjs/utils.cjs
var require_utils5 = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/utils.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.viewFunction = exports.viewState = exports.encodeJSContractArgs = exports.validateArgs = void 0;
    var types_1 = require_commonjs();
    var utils_1 = require_commonjs2();
    function parseJsonFromRawResponse(response) {
      return JSON.parse(Buffer.from(response).toString());
    }
    function bytesJsonStringify(input) {
      return Buffer.from(JSON.stringify(input));
    }
    function validateArgs(args) {
      const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
      if (isUint8Array) {
        return;
      }
      if (Array.isArray(args) || typeof args !== "object") {
        throw new types_1.PositionalArgsError();
      }
    }
    exports.validateArgs = validateArgs;
    function encodeJSContractArgs(contractId, method, args) {
      return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);
    }
    exports.encodeJSContractArgs = encodeJSContractArgs;
    async function viewState(connection, accountId, prefix, blockQuery = { finality: "optimistic" }) {
      const { values } = await connection.provider.query({
        request_type: "view_state",
        ...blockQuery,
        account_id: accountId,
        prefix_base64: Buffer.from(prefix).toString("base64")
      });
      return values.map(({ key, value }) => ({
        key: Buffer.from(key, "base64"),
        value: Buffer.from(value, "base64")
      }));
    }
    exports.viewState = viewState;
    async function viewFunction(connection, { contractId, methodName, args = {}, parse = parseJsonFromRawResponse, stringify = bytesJsonStringify, jsContract = false, blockQuery = { finality: "optimistic" } }) {
      let encodedArgs;
      validateArgs(args);
      if (jsContract) {
        encodedArgs = encodeJSContractArgs(contractId, methodName, Object.keys(args).length > 0 ? JSON.stringify(args) : "");
      } else {
        encodedArgs = stringify(args);
      }
      const result = await connection.provider.query({
        request_type: "call_function",
        ...blockQuery,
        account_id: jsContract ? connection.jsvmAccountId : contractId,
        method_name: jsContract ? "view_js_contract" : methodName,
        args_base64: encodedArgs.toString("base64")
      });
      if (result.logs) {
        (0, utils_1.printTxOutcomeLogs)({ contractId, logs: result.logs });
      }
      return result.result && result.result.length > 0 && parse(Buffer.from(result.result));
    }
    exports.viewFunction = viewFunction;
  }
});

// node_modules/@near-js/accounts/lib/commonjs/account.cjs
var require_account = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/account.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Account = void 0;
    var crypto_1 = require_commonjs3();
    var providers_1 = require_commonjs7();
    var transactions_1 = require_commonjs6();
    var types_1 = require_commonjs();
    var utils_1 = require_commonjs2();
    var utils_2 = require_utils5();
    var { addKey, createAccount, deleteAccount, deleteKey, deployContract, fullAccessKey, functionCall, functionCallAccessKey, stake, transfer } = transactions_1.actionCreators;
    var TX_NONCE_RETRY_NUMBER = 12;
    var TX_NONCE_RETRY_WAIT = 500;
    var TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;
    var Account = class _Account {
      constructor(connection, accountId) {
        __publicField(this, "connection");
        __publicField(this, "accountId");
        /** @hidden */
        __publicField(this, "accessKeyByPublicKeyCache", {});
        this.connection = connection;
        this.accountId = accountId;
      }
      getConnection() {
        return this.connection;
      }
      /**
       * Returns basic NEAR account information via the `view_account` RPC query method
       * @see [https://docs.near.org/api/rpc/contracts#view-account](https://docs.near.org/api/rpc/contracts#view-account)
       */
      async state() {
        return this.connection.provider.query({
          request_type: "view_account",
          account_id: this.accountId,
          finality: "optimistic"
        });
      }
      /**
       * Create a signed transaction which can be broadcast to the network
       * @param receiverId NEAR account receiving the transaction
       * @param actions list of actions to perform as part of the transaction
       * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}
       */
      async signTransaction(receiverId, actions) {
        const accessKeyInfo = await this.findAccessKey(receiverId, actions);
        if (!accessKeyInfo) {
          throw new types_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, "KeyNotFound");
        }
        const { accessKey } = accessKeyInfo;
        const block = await this.connection.provider.block({ finality: "final" });
        const blockHash = block.header.hash;
        const nonce = accessKey.nonce + 1n;
        return await (0, transactions_1.signTransaction)(receiverId, nonce, actions, (0, utils_1.baseDecode)(blockHash), this.connection.signer, this.accountId, this.connection.networkId);
      }
      /**
       * Sign a transaction to perform a list of actions and broadcast it using the RPC API.
       * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider | JsonRpcProvider }
       *
       * @param options The options for signing and sending the transaction.
       * @param options.receiverId The NEAR account ID of the transaction receiver.
       * @param options.actions The list of actions to be performed in the transaction.
       * @param options.returnError Whether to return an error if the transaction fails.
       * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
       */
      async signAndSendTransaction({ receiverId, actions, returnError }) {
        let txHash, signedTx;
        const result = await (0, providers_1.exponentialBackoff)(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, async () => {
          [txHash, signedTx] = await this.signTransaction(receiverId, actions);
          const publicKey = signedTx.transaction.publicKey;
          try {
            return await this.connection.provider.sendTransaction(signedTx);
          } catch (error) {
            if (error.type === "InvalidNonce") {
              utils_1.Logger.warn(`Retrying transaction ${receiverId}:${(0, utils_1.baseEncode)(txHash)} with new nonce.`);
              delete this.accessKeyByPublicKeyCache[publicKey.toString()];
              return null;
            }
            if (error.type === "Expired") {
              utils_1.Logger.warn(`Retrying transaction ${receiverId}:${(0, utils_1.baseEncode)(txHash)} due to expired block hash`);
              return null;
            }
            error.context = new types_1.ErrorContext((0, utils_1.baseEncode)(txHash));
            throw error;
          }
        });
        if (!result) {
          throw new types_1.TypedError("nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.", "RetriesExceeded");
        }
        (0, utils_1.printTxOutcomeLogsAndFailures)({ contractId: signedTx.transaction.receiverId, outcome: result });
        if (!returnError && typeof result.status === "object" && typeof result.status.Failure === "object" && result.status.Failure !== null) {
          if (result.status.Failure.error_message && result.status.Failure.error_type) {
            throw new types_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);
          } else {
            throw (0, utils_1.parseResultError)(result);
          }
        }
        return result;
      }
      /**
       * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link "@near-js/keystores".keystore.KeyStore | Keystore}.
       *
       * @todo Find matching access key based on transaction (i.e. receiverId and actions)
       *
       * @param receiverId currently unused (see todo)
       * @param actions currently unused (see todo)
       * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async findAccessKey(receiverId, actions) {
        const publicKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        if (!publicKey) {
          throw new types_1.TypedError(`no matching key pair found in ${this.connection.signer}`, "PublicKeyNotFound");
        }
        const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];
        if (cachedAccessKey !== void 0) {
          return { publicKey, accessKey: cachedAccessKey };
        }
        try {
          const rawAccessKey = await this.connection.provider.query({
            request_type: "view_access_key",
            account_id: this.accountId,
            public_key: publicKey.toString(),
            finality: "optimistic"
          });
          const accessKey = {
            ...rawAccessKey,
            nonce: BigInt(rawAccessKey.nonce || 0)
          };
          if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {
            return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };
          }
          this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;
          return { publicKey, accessKey };
        } catch (e) {
          if (e.type == "AccessKeyDoesNotExist") {
            return null;
          }
          throw e;
        }
      }
      /**
       * Create a new account and deploy a contract to it
       *
       * @param contractId NEAR account where the contract is deployed
       * @param publicKey The public key to add to the created contract account
       * @param data The compiled contract code
       * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking
       */
      async createAndDeployContract(contractId, publicKey, data, amount) {
        const accessKey = fullAccessKey();
        await this.signAndSendTransaction({
          receiverId: contractId,
          actions: [createAccount(), transfer(amount), addKey(crypto_1.PublicKey.from(publicKey), accessKey), deployContract(data)]
        });
        const contractAccount = new _Account(this.connection, contractId);
        return contractAccount;
      }
      /**
       * @param receiverId NEAR account receiving Ⓝ
       * @param amount Amount to send in yoctoⓃ
       */
      async sendMoney(receiverId, amount) {
        return this.signAndSendTransaction({
          receiverId,
          actions: [transfer(amount)]
        });
      }
      /**
       * @param newAccountId NEAR account name to be created
       * @param publicKey A public key created from the masterAccount
       */
      async createAccount(newAccountId, publicKey, amount) {
        const accessKey = fullAccessKey();
        return this.signAndSendTransaction({
          receiverId: newAccountId,
          actions: [createAccount(), transfer(amount), addKey(crypto_1.PublicKey.from(publicKey), accessKey)]
        });
      }
      /**
       * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted
       */
      async deleteAccount(beneficiaryId) {
        utils_1.Logger.log("Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting.");
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [deleteAccount(beneficiaryId)]
        });
      }
      /**
       * @param data The compiled contract code
       */
      async deployContract(data) {
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [deployContract(data)]
        });
      }
      /** @hidden */
      encodeJSContractArgs(contractId, method, args) {
        return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);
      }
      /**
        * Execute a function call.
        * @param options The options for the function call.
        * @param options.contractId The NEAR account ID of the smart contract.
        * @param options.methodName The name of the method to be called on the smart contract.
        * @param options.args The arguments to be passed to the method.
        * @param options.gas The maximum amount of gas to be used for the function call.
        * @param options.attachedDeposit The amount of NEAR tokens to be attached to the function call.
        * @param options.walletMeta Metadata for wallet integration.
        * @param options.walletCallbackUrl The callback URL for wallet integration.
        * @param options.stringify A function to convert input arguments into bytes array
        * @param options.jsContract Whether the contract is from JS SDK, automatically encodes args from JS SDK to binary.
        * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the function call.
        */
      async functionCall({ contractId, methodName, args = {}, gas = utils_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify, jsContract }) {
        this.validateArgs(args);
        let functionCallArgs;
        if (jsContract) {
          const encodedArgs = this.encodeJSContractArgs(contractId, methodName, JSON.stringify(args));
          functionCallArgs = ["call_js_contract", encodedArgs, gas, attachedDeposit, null, true];
        } else {
          const stringifyArg = stringify === void 0 ? transactions_1.stringifyJsonOrBytes : stringify;
          functionCallArgs = [methodName, args, gas, attachedDeposit, stringifyArg, false];
        }
        return this.signAndSendTransaction({
          receiverId: jsContract ? this.connection.jsvmAccountId : contractId,
          // eslint-disable-next-line prefer-spread
          actions: [functionCall.apply(void 0, functionCallArgs)],
          walletMeta,
          walletCallbackUrl
        });
      }
      /**
       * @see [https://docs.near.org/concepts/basics/accounts/access-keys](https://docs.near.org/concepts/basics/accounts/access-keys)
       * @todo expand this API to support more options.
       * @param publicKey A public key to be associated with the contract
       * @param contractId NEAR account where the contract is deployed
       * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.
       * @param amount Payment in yoctoⓃ that is sent to the contract during this function call
       */
      async addKey(publicKey, contractId, methodNames, amount) {
        if (!methodNames) {
          methodNames = [];
        }
        if (!Array.isArray(methodNames)) {
          methodNames = [methodNames];
        }
        let accessKey;
        if (!contractId) {
          accessKey = fullAccessKey();
        } else {
          accessKey = functionCallAccessKey(contractId, methodNames, amount);
        }
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [addKey(crypto_1.PublicKey.from(publicKey), accessKey)]
        });
      }
      /**
       * @param publicKey The public key to be deleted
       * @returns {Promise<FinalExecutionOutcome>}
       */
      async deleteKey(publicKey) {
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [deleteKey(crypto_1.PublicKey.from(publicKey))]
        });
      }
      /**
       * @see [https://near-nodes.io/validator/staking-and-delegation](https://near-nodes.io/validator/staking-and-delegation)
       *
       * @param publicKey The public key for the account that's staking
       * @param amount The account to stake in yoctoⓃ
       */
      async stake(publicKey, amount) {
        return this.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [stake(amount, crypto_1.PublicKey.from(publicKey))]
        });
      }
      /**
       * Compose and sign a SignedDelegate action to be executed in a transaction on behalf of this Account instance
       *
       * @param options Options for the transaction.
       * @param options.actions Actions to be included in the meta transaction
       * @param options.blockHeightTtl Number of blocks past the current block height for which the SignedDelegate action may be included in a meta transaction
       * @param options.receiverId Receiver account of the meta transaction
       */
      async signedDelegate({ actions, blockHeightTtl, receiverId }) {
        const { provider, signer } = this.connection;
        const { header } = await provider.block({ finality: "final" });
        const { accessKey, publicKey } = await this.findAccessKey(null, null);
        const delegateAction = (0, transactions_1.buildDelegateAction)({
          actions,
          maxBlockHeight: BigInt(header.height) + BigInt(blockHeightTtl),
          nonce: BigInt(accessKey.nonce) + 1n,
          publicKey,
          receiverId,
          senderId: this.accountId
        });
        const { signedDelegateAction } = await (0, transactions_1.signDelegateAction)({
          delegateAction,
          signer: {
            sign: async (message) => {
              const { signature } = await signer.signMessage(message, delegateAction.senderId, this.connection.networkId);
              return signature;
            }
          }
        });
        return signedDelegateAction;
      }
      /** @hidden */
      validateArgs(args) {
        const isUint8Array = args.byteLength !== void 0 && args.byteLength === args.length;
        if (isUint8Array) {
          return;
        }
        if (Array.isArray(args) || typeof args !== "object") {
          throw new types_1.PositionalArgsError();
        }
      }
      /**
       * Invoke a contract view function using the RPC API.
       * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)
       *
       * @param options Function call options.
       * @param options.contractId NEAR account where the contract is deployed
       * @param options.methodName The view-only method (no state mutations) name on the contract as it is written in the contract code
       * @param options.args Any arguments to the view contract method, wrapped in JSON
       * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.
       * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.
       * @param options.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.
       * @param options.blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
       * @returns {Promise<any>}
       */
      async viewFunction(options) {
        return await (0, utils_2.viewFunction)(this.connection, options);
      }
      /**
       * Returns the state (key value pairs) of this account's contract based on the key prefix.
       * Pass an empty string for prefix if you would like to return the entire state.
       * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)
       *
       * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.
       * @param blockQuery specifies which block to query state at. By default returns last "optimistic" block (i.e. not necessarily finalized).
       */
      async viewState(prefix, blockQuery = { finality: "optimistic" }) {
        return await (0, utils_2.viewState)(this.connection, this.accountId, prefix, blockQuery);
      }
      /**
       * Get all access keys for the account
       * @see [https://docs.near.org/api/rpc/access-keys#view-access-key-list](https://docs.near.org/api/rpc/access-keys#view-access-key-list)
       */
      async getAccessKeys() {
        var _a;
        const response = await this.connection.provider.query({
          request_type: "view_access_key_list",
          account_id: this.accountId,
          finality: "optimistic"
        });
        return (_a = response == null ? void 0 : response.keys) == null ? void 0 : _a.map((key) => ({ ...key, access_key: { ...key.access_key, nonce: BigInt(key.access_key.nonce) } }));
      }
      /**
       * Returns a list of authorized apps
       * @todo update the response value to return all the different keys, not just app keys.
       */
      async getAccountDetails() {
        const accessKeys = await this.getAccessKeys();
        const authorizedApps = accessKeys.filter((item) => item.access_key.permission !== "FullAccess").map((item) => {
          const perm = item.access_key.permission;
          return {
            contractId: perm.FunctionCall.receiver_id,
            amount: perm.FunctionCall.allowance,
            publicKey: item.public_key
          };
        });
        return { authorizedApps };
      }
      /**
       * Returns calculated account balance
       */
      async getAccountBalance() {
        const protocolConfig = await this.connection.provider.experimental_protocolConfig({ finality: "final" });
        const state = await this.state();
        const costPerByte = BigInt(protocolConfig.runtime_config.storage_amount_per_byte);
        const stateStaked = BigInt(state.storage_usage) * costPerByte;
        const staked = BigInt(state.locked);
        const totalBalance = BigInt(state.amount) + staked;
        const availableBalance = totalBalance - (staked > stateStaked ? staked : stateStaked);
        return {
          total: totalBalance.toString(),
          stateStaked: stateStaked.toString(),
          staked: staked.toString(),
          available: availableBalance.toString()
        };
      }
      /**
       * Returns the NEAR tokens balance and validators of a given account that is delegated to the staking pools that are part of the validators set in the current epoch.
       *
       * NOTE: If the tokens are delegated to a staking pool that is currently on pause or does not have enough tokens to participate in validation, they won't be accounted for.
       * @returns {Promise<ActiveDelegatedStakeBalance>}
       */
      async getActiveDelegatedStakeBalance() {
        const block = await this.connection.provider.block({ finality: "final" });
        const blockHash = block.header.hash;
        const epochId = block.header.epoch_id;
        const { current_validators, next_validators, current_proposals } = await this.connection.provider.validators(epochId);
        const pools = /* @__PURE__ */ new Set();
        [...current_validators, ...next_validators, ...current_proposals].forEach((validator) => pools.add(validator.account_id));
        const uniquePools = [...pools];
        const promises = uniquePools.map((validator) => this.viewFunction({
          contractId: validator,
          methodName: "get_account_total_balance",
          args: { account_id: this.accountId },
          blockQuery: { blockId: blockHash }
        }));
        const results = await Promise.allSettled(promises);
        const hasTimeoutError = results.some((result) => {
          if (result.status === "rejected" && result.reason.type === "TimeoutError") {
            return true;
          }
          return false;
        });
        if (hasTimeoutError) {
          throw new Error("Failed to get delegated stake balance");
        }
        const summary = results.reduce((result, state, index) => {
          const validatorId = uniquePools[index];
          if (state.status === "fulfilled") {
            const currentBN = BigInt(state.value);
            if (currentBN !== 0n) {
              return {
                ...result,
                stakedValidators: [...result.stakedValidators, { validatorId, amount: currentBN.toString() }],
                total: result.total + currentBN
              };
            }
          }
          if (state.status === "rejected") {
            return {
              ...result,
              failedValidators: [...result.failedValidators, { validatorId, error: state.reason }]
            };
          }
          return result;
        }, { stakedValidators: [], failedValidators: [], total: 0n });
        return {
          ...summary,
          total: summary.total.toString()
        };
      }
    };
    exports.Account = Account;
  }
});

// node_modules/@near-js/accounts/lib/commonjs/constants.cjs
var require_constants = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/constants.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;
    var utils_1 = require_commonjs2();
    exports.MULTISIG_STORAGE_KEY = "__multisigRequest";
    exports.MULTISIG_ALLOWANCE = BigInt((0, utils_1.parseNearAmount)("1"));
    exports.MULTISIG_GAS = 100000000000000n;
    exports.MULTISIG_DEPOSIT = 0n;
    exports.MULTISIG_CHANGE_METHODS = ["add_request", "add_request_and_confirm", "delete_request", "confirm"];
    exports.MULTISIG_CONFIRM_METHODS = ["confirm"];
  }
});

// node_modules/@near-js/accounts/lib/commonjs/types.cjs
var require_types3 = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/types.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = void 0;
    var MultisigDeleteRequestRejectionError;
    (function(MultisigDeleteRequestRejectionError2) {
      MultisigDeleteRequestRejectionError2["CANNOT_DESERIALIZE_STATE"] = "Cannot deserialize the contract state";
      MultisigDeleteRequestRejectionError2["MULTISIG_NOT_INITIALIZED"] = "Smart contract panicked: Multisig contract should be initialized before usage";
      MultisigDeleteRequestRejectionError2["NO_SUCH_REQUEST"] = "Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'";
      MultisigDeleteRequestRejectionError2["REQUEST_COOLDOWN_ERROR"] = "Request cannot be deleted immediately after creation.";
      MultisigDeleteRequestRejectionError2["METHOD_NOT_FOUND"] = "Contract method is not found";
    })(MultisigDeleteRequestRejectionError || (exports.MultisigDeleteRequestRejectionError = MultisigDeleteRequestRejectionError = {}));
    var MultisigStateStatus;
    (function(MultisigStateStatus2) {
      MultisigStateStatus2[MultisigStateStatus2["INVALID_STATE"] = 0] = "INVALID_STATE";
      MultisigStateStatus2[MultisigStateStatus2["STATE_NOT_INITIALIZED"] = 1] = "STATE_NOT_INITIALIZED";
      MultisigStateStatus2[MultisigStateStatus2["VALID_STATE"] = 2] = "VALID_STATE";
      MultisigStateStatus2[MultisigStateStatus2["UNKNOWN_STATE"] = 3] = "UNKNOWN_STATE";
    })(MultisigStateStatus || (exports.MultisigStateStatus = MultisigStateStatus = {}));
  }
});

// node_modules/@near-js/accounts/lib/commonjs/account_multisig.cjs
var require_account_multisig = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/account_multisig.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountMultisig = void 0;
    var transactions_1 = require_commonjs6();
    var utils_1 = require_commonjs2();
    var account_1 = require_account();
    var constants_1 = require_constants();
    var types_1 = require_types3();
    var { deployContract, functionCall } = transactions_1.actionCreators;
    var MultisigCodeStatus;
    (function(MultisigCodeStatus2) {
      MultisigCodeStatus2[MultisigCodeStatus2["INVALID_CODE"] = 0] = "INVALID_CODE";
      MultisigCodeStatus2[MultisigCodeStatus2["VALID_CODE"] = 1] = "VALID_CODE";
      MultisigCodeStatus2[MultisigCodeStatus2["UNKNOWN_CODE"] = 2] = "UNKNOWN_CODE";
    })(MultisigCodeStatus || (MultisigCodeStatus = {}));
    var storageFallback = {
      [constants_1.MULTISIG_STORAGE_KEY]: null
    };
    var AccountMultisig = class extends account_1.Account {
      /**
       * Constructs an instance of the `AccountMultisig` class.
       * @param connection The NEAR connection object.
       * @param accountId The NEAR account ID.
       * @param options Additional options for the multisig account.
       * @param options.storage Storage to store data related to multisig operations.
       * @param options.onAddRequestResult Callback function to handle the result of adding a request.
       */
      constructor(connection, accountId, options) {
        super(connection, accountId);
        __publicField(this, "storage");
        __publicField(this, "onAddRequestResult");
        this.storage = options.storage;
        this.onAddRequestResult = options.onAddRequestResult;
      }
      /**
       * Sign and send a transaction with the multisig account as the sender.
       * @param receiverId - The NEAR account ID of the transaction receiver.
       * @param actions - The list of actions to be included in the transaction.
       * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
       */
      async signAndSendTransactionWithAccount(receiverId, actions) {
        return super.signAndSendTransaction({ receiverId, actions });
      }
      /**
       * Sign and send a multisig transaction to add a request and confirm it.
       * @param options Options for the multisig transaction.
       * @param options.receiverId The NEAR account ID of the transaction receiver.
       * @param options.actions The list of actions to be included in the transaction.
       * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
       */
      async signAndSendTransaction({ receiverId, actions }) {
        const { accountId } = this;
        const args = Buffer.from(JSON.stringify({
          request: {
            receiver_id: receiverId,
            actions: convertActions(actions, accountId, receiverId)
          }
        }));
        let result;
        try {
          result = await super.signAndSendTransaction({
            receiverId: accountId,
            actions: [
              functionCall("add_request_and_confirm", args, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)
            ]
          });
        } catch (e) {
          if (e.toString().includes("Account has too many active requests. Confirm or delete some")) {
            await this.deleteUnconfirmedRequests();
            return await this.signAndSendTransaction({ receiverId, actions });
          }
          throw e;
        }
        if (!result.status) {
          throw new Error("Request failed");
        }
        const status = { ...result.status };
        if (!status.SuccessValue || typeof status.SuccessValue !== "string") {
          throw new Error("Request failed");
        }
        this.setRequest({
          accountId,
          actions,
          requestId: parseInt(Buffer.from(status.SuccessValue, "base64").toString("ascii"), 10)
        });
        if (this.onAddRequestResult) {
          await this.onAddRequestResult(result);
        }
        this.deleteUnconfirmedRequests();
        return result;
      }
      /**
       * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state
       * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.
       * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.
       * @param contractBytes The bytecode of the multisig contract.
       * @returns {Promise<{ codeStatus: MultisigCodeStatus; stateStatus: MultisigStateStatus }>} A promise that resolves to the status of the code and state.
       */
      async checkMultisigCodeAndStateStatus(contractBytes) {
        const u32_max = 4294967295;
        const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;
        try {
          if (contractBytes) {
            await super.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [
                deployContract(contractBytes),
                functionCall("delete_request", { request_id: u32_max }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)
              ]
            });
          } else {
            await this.deleteRequest(u32_max);
          }
          return { codeStatus: MultisigCodeStatus.VALID_CODE, stateStatus: types_1.MultisigStateStatus.VALID_STATE };
        } catch (e) {
          if (new RegExp(types_1.MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {
            return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.INVALID_STATE };
          } else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {
            return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.STATE_NOT_INITIALIZED };
          } else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {
            return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.VALID_STATE };
          } else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {
            return { codeStatus: MultisigCodeStatus.INVALID_CODE, stateStatus: types_1.MultisigStateStatus.UNKNOWN_STATE };
          }
          throw e;
        }
      }
      /**
       * Delete a multisig request by its ID.
       * @param request_id The ID of the multisig request to be deleted.
       * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deletion.
       */
      deleteRequest(request_id) {
        return super.signAndSendTransaction({
          receiverId: this.accountId,
          actions: [functionCall("delete_request", { request_id }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]
        });
      }
      /**
       * Delete all multisig requests associated with the account.
       * @returns {Promise<void>} A promise that resolves when all requests are deleted.
       */
      async deleteAllRequests() {
        const request_ids = await this.getRequestIds();
        if (request_ids.length) {
          await Promise.all(request_ids.map((id) => this.deleteRequest(id)));
        }
      }
      /**
       * Delete unconfirmed multisig requests associated with the account.
       * @returns {Promise<void>} A promise that resolves when unconfirmed requests are deleted.
       */
      async deleteUnconfirmedRequests() {
        const request_ids = await this.getRequestIds();
        const { requestId } = this.getRequest();
        for (const requestIdToDelete of request_ids) {
          if (requestIdToDelete == requestId) {
            continue;
          }
          try {
            await super.signAndSendTransaction({
              receiverId: this.accountId,
              actions: [functionCall("delete_request", { request_id: requestIdToDelete }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]
            });
          } catch (e) {
            utils_1.Logger.warn("Attempt to delete an earlier request before 15 minutes failed. Will try again.");
          }
        }
      }
      // helpers
      async getRequestIds() {
        return this.viewFunction({
          contractId: this.accountId,
          methodName: "list_request_ids"
        });
      }
      getRequest() {
        if (this.storage) {
          return JSON.parse(this.storage.getItem(constants_1.MULTISIG_STORAGE_KEY) || "{}");
        }
        return storageFallback[constants_1.MULTISIG_STORAGE_KEY];
      }
      setRequest(data) {
        if (this.storage) {
          return this.storage.setItem(constants_1.MULTISIG_STORAGE_KEY, JSON.stringify(data));
        }
        storageFallback[constants_1.MULTISIG_STORAGE_KEY] = data;
      }
    };
    exports.AccountMultisig = AccountMultisig;
    var convertPKForContract = (pk) => pk.toString().replace("ed25519:", "");
    var convertActions = (actions, accountId, receiverId) => actions.map((a) => {
      const type = a.enum;
      const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];
      const action = {
        type: type[0].toUpperCase() + type.substr(1),
        gas: gas && gas.toString() || void 0,
        public_key: publicKey && convertPKForContract(publicKey) || void 0,
        method_name: methodName,
        args: args && Buffer.from(args).toString("base64") || void 0,
        code: code && Buffer.from(code).toString("base64") || void 0,
        amount: deposit && deposit.toString() || void 0,
        deposit: deposit && deposit.toString() || "0",
        permission: void 0
      };
      if (accessKey) {
        if (receiverId === accountId && accessKey.permission.enum !== "fullAccess") {
          action.permission = {
            receiver_id: accountId,
            allowance: constants_1.MULTISIG_ALLOWANCE.toString(),
            method_names: constants_1.MULTISIG_CHANGE_METHODS
          };
        }
        if (accessKey.permission.enum === "functionCall") {
          const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;
          action.permission = {
            receiver_id,
            allowance: allowance && allowance.toString() || void 0,
            method_names
          };
        }
      }
      return action;
    });
  }
});

// node_modules/@near-js/accounts/lib/commonjs/account_2fa.cjs
var require_account_2fa = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/account_2fa.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Account2FA = void 0;
    var crypto_1 = require_commonjs3();
    var types_1 = require_commonjs();
    var transactions_1 = require_commonjs6();
    var utils_1 = require_commonjs2();
    var account_multisig_1 = require_account_multisig();
    var constants_1 = require_constants();
    var types_2 = require_types3();
    var { addKey, deleteKey, deployContract, fullAccessKey, functionCall, functionCallAccessKey } = transactions_1.actionCreators;
    var Account2FA = class extends account_multisig_1.AccountMultisig {
      constructor(connection, accountId, options) {
        super(connection, accountId, options);
        /********************************
        Account2FA has options object where you can provide callbacks for:
        - sendCode: how to send the 2FA code in case you don't use NEAR Contract Helper
        - getCode: how to get code from user (use this to provide custom UI/UX for prompt of 2FA code)
        - onResult: the tx result after it's been confirmed by NEAR Contract Helper
        ********************************/
        __publicField(this, "sendCode");
        __publicField(this, "getCode");
        __publicField(this, "verifyCode");
        __publicField(this, "onConfirmResult");
        __publicField(this, "helperUrl", "https://helper.testnet.near.org");
        this.helperUrl = options.helperUrl || this.helperUrl;
        this.storage = options.storage;
        this.sendCode = options.sendCode || this.sendCodeDefault;
        this.getCode = options.getCode || this.getCodeDefault;
        this.verifyCode = options.verifyCode || this.verifyCodeDefault;
        this.onConfirmResult = options.onConfirmResult;
      }
      /**
       * Sign a transaction to preform a list of actions and broadcast it using the RPC API.
       * @see {@link "@near-js/providers".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}
       *
       * @param options Options for the transaction.
       * @param options.receiverId The NEAR account ID of the transaction receiver.
       * @param options.actions The list of actions to be included in the transaction.
       * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.
       */
      async signAndSendTransaction({ receiverId, actions }) {
        await super.signAndSendTransaction({ receiverId, actions });
        await this.sendCode();
        const result = await this.promptAndVerify();
        if (this.onConfirmResult) {
          await this.onConfirmResult(result);
        }
        return result;
      }
      // default helpers for CH deployments of multisig
      /**
       * Deploy a multisig contract with 2FA and handle the deployment process.
       * @param contractBytes - The bytecode of the multisig contract.
       * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deployment.
       */
      async deployMultisig(contractBytes) {
        const { accountId } = this;
        const seedOrLedgerKey = (await this.getRecoveryMethods()).data.filter(({ kind, publicKey }) => (kind === "phrase" || kind === "ledger") && publicKey !== null).map((rm) => rm.publicKey);
        const fak2lak = (await this.getAccessKeys()).filter(({ public_key, access_key: { permission } }) => permission === "FullAccess" && !seedOrLedgerKey.includes(public_key)).map((ak) => ak.public_key).map(toPK);
        const confirmOnlyKey = toPK((await this.postSignedJson("/2fa/getAccessKey", { accountId })).publicKey);
        const newArgs = Buffer.from(JSON.stringify({ "num_confirmations": 2 }));
        const actions = [
          ...fak2lak.map((pk) => deleteKey(pk)),
          ...fak2lak.map((pk) => addKey(pk, functionCallAccessKey(accountId, constants_1.MULTISIG_CHANGE_METHODS, null))),
          addKey(confirmOnlyKey, functionCallAccessKey(accountId, constants_1.MULTISIG_CONFIRM_METHODS, null)),
          deployContract(contractBytes)
        ];
        const newFunctionCallActionBatch = actions.concat(functionCall("new", newArgs, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT));
        utils_1.Logger.log("deploying multisig contract for", accountId);
        const { stateStatus: multisigStateStatus } = await this.checkMultisigCodeAndStateStatus(contractBytes);
        switch (multisigStateStatus) {
          case types_2.MultisigStateStatus.STATE_NOT_INITIALIZED:
            return await super.signAndSendTransactionWithAccount(accountId, newFunctionCallActionBatch);
          case types_2.MultisigStateStatus.VALID_STATE:
            return await super.signAndSendTransactionWithAccount(accountId, actions);
          case types_2.MultisigStateStatus.INVALID_STATE:
            throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState");
          default:
            throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
        }
      }
      /**
       * Disable 2FA with the option to clean up contract state.
       * @param options Options for disabling 2FA.
       * @param options.contractBytes The bytecode of the contract to deploy.
       * @param options.cleanupContractBytes The bytecode of the cleanup contract (optional).
       * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.
       */
      async disableWithFAK({ contractBytes, cleanupContractBytes }) {
        let cleanupActions = [];
        if (cleanupContractBytes) {
          await this.deleteAllRequests().catch((e) => e);
          cleanupActions = await this.get2faDisableCleanupActions(cleanupContractBytes);
        }
        const keyConversionActions = await this.get2faDisableKeyConversionActions();
        const actions = [
          ...cleanupActions,
          ...keyConversionActions,
          deployContract(contractBytes)
        ];
        const accessKeyInfo = await this.findAccessKey(this.accountId, actions);
        if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== "FullAccess") {
          throw new types_1.TypedError("No full access key found in keystore. Unable to bypass multisig", "NoFAKFound");
        }
        return this.signAndSendTransactionWithAccount(this.accountId, actions);
      }
      /**
       * Retrieves cleanup actions for disabling 2FA.
       * @param cleanupContractBytes - The bytecode of the cleanup contract.
       * @returns {Promise<Action[]>} - A promise that resolves to an array of cleanup actions.
       */
      async get2faDisableCleanupActions(cleanupContractBytes) {
        const currentAccountState = await this.viewState("").catch((error) => {
          const cause = error.cause && error.cause.name;
          if (cause == "NO_CONTRACT_CODE") {
            return [];
          }
          throw cause == "TOO_LARGE_CONTRACT_STATE" ? new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, "ContractHasExistingState") : error;
        });
        const currentAccountStateKeys = currentAccountState.map(({ key }) => key.toString("base64"));
        return currentAccountState.length ? [
          deployContract(cleanupContractBytes),
          functionCall("clean", { keys: currentAccountStateKeys }, constants_1.MULTISIG_GAS, 0n)
        ] : [];
      }
      /**
       * Retrieves key conversion actions for disabling 2FA.
       * @returns {Promise<Action[]>} - A promise that resolves to an array of key conversion actions.
       */
      async get2faDisableKeyConversionActions() {
        const { accountId } = this;
        const accessKeys = await this.getAccessKeys();
        const lak2fak = accessKeys.filter(({ access_key }) => access_key.permission !== "FullAccess").filter(({ access_key }) => {
          const perm = access_key.permission.FunctionCall;
          return perm.receiver_id === accountId && perm.method_names.length === 4 && perm.method_names.includes("add_request_and_confirm");
        });
        const confirmOnlyKey = crypto_1.PublicKey.from((await this.postSignedJson("/2fa/getAccessKey", { accountId })).publicKey);
        return [
          deleteKey(confirmOnlyKey),
          ...lak2fak.map(({ public_key }) => deleteKey(crypto_1.PublicKey.from(public_key))),
          ...lak2fak.map(({ public_key }) => addKey(crypto_1.PublicKey.from(public_key), fullAccessKey()))
        ];
      }
      /**
       * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)
       * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}
       * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-manipulation/res/state_cleanup.wasm?raw=true}
       * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.
       */
      async disable(contractBytes, cleanupContractBytes) {
        const { stateStatus } = await this.checkMultisigCodeAndStateStatus();
        if (stateStatus !== types_2.MultisigStateStatus.VALID_STATE && stateStatus !== types_2.MultisigStateStatus.STATE_NOT_INITIALIZED) {
          throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, "ContractStateUnknown");
        }
        let deleteAllRequestsError;
        await this.deleteAllRequests().catch((e) => deleteAllRequestsError = e);
        const cleanupActions = await this.get2faDisableCleanupActions(cleanupContractBytes).catch((e) => {
          if (e.type === "ContractHasExistingState") {
            throw deleteAllRequestsError || e;
          }
          throw e;
        });
        const actions = [
          ...cleanupActions,
          ...await this.get2faDisableKeyConversionActions(),
          deployContract(contractBytes)
        ];
        utils_1.Logger.log("disabling 2fa for", this.accountId);
        return await this.signAndSendTransaction({
          receiverId: this.accountId,
          actions
        });
      }
      /**
       * Default implementation for sending the 2FA code.
       * @returns {Promise<string>} - A promise that resolves to the request ID.
       */
      async sendCodeDefault() {
        const { accountId } = this;
        const { requestId } = this.getRequest();
        const method = await this.get2faMethod();
        await this.postSignedJson("/2fa/send", {
          accountId,
          method,
          requestId
        });
        return requestId;
      }
      async getCodeDefault() {
        throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is "email" or "phone".');
      }
      /**
       * Prompts the user to enter and verify the 2FA code.
       * @returns {Promise<any>} - A promise that resolves to the verification result.
       */
      async promptAndVerify() {
        const method = await this.get2faMethod();
        const securityCode = await this.getCode(method);
        try {
          const result = await this.verifyCode(securityCode);
          return result;
        } catch (e) {
          utils_1.Logger.warn("Error validating security code:", e);
          if (e.toString().includes("invalid 2fa code provided") || e.toString().includes("2fa code not valid")) {
            return await this.promptAndVerify();
          }
          throw e;
        }
      }
      /**
       * Verify the 2FA code using the default method.
       * @param securityCode - The security code to verify.
       * @returns {Promise<any>} A promise that resolves to the verification result.
       */
      async verifyCodeDefault(securityCode) {
        const { accountId } = this;
        const request = this.getRequest();
        if (!request) {
          throw new Error("no request pending");
        }
        const { requestId } = request;
        return await this.postSignedJson("/2fa/verify", {
          accountId,
          securityCode,
          requestId
        });
      }
      /**
       * Retrieves recovery methods for the account.
       * @returns {Promise<{ accountId: string, data: any }>} - A promise that resolves to recovery methods data.
       */
      async getRecoveryMethods() {
        const { accountId } = this;
        return {
          accountId,
          data: await this.postSignedJson("/account/recoveryMethods", { accountId })
        };
      }
      /**
       * Gets the 2FA method (kind and detail).
       * @returns {Promise<{ kind: string, detail: string }>} A promise that resolves to the 2FA method.
       */
      async get2faMethod() {
        let { data } = await this.getRecoveryMethods();
        if (data && data.length) {
          data = data.find((m) => m.kind.indexOf("2fa-") === 0);
        }
        if (!data)
          return null;
        const { kind, detail } = data;
        return { kind, detail };
      }
      /**
      * Generates a signature for the latest finalized block.
      * @returns {Promise<{ blockNumber: string, blockNumberSignature: string }>} - A promise that resolves to the signature information.
      */
      async signatureFor() {
        const { accountId } = this;
        const block = await this.connection.provider.block({ finality: "final" });
        const blockNumber = block.header.height.toString();
        const signed = await this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);
        const blockNumberSignature = Buffer.from(signed.signature).toString("base64");
        return { blockNumber, blockNumberSignature };
      }
      /**
      * Sends a signed JSON request to a specified path.
      * @param path - The path for the request.
      * @param body - The request body.
      * @returns {Promise<any>} - A promise that resolves to the response from the helper.
      */
      async postSignedJson(path, body) {
        return await fetch(this.helperUrl + path, {
          body: JSON.stringify({
            ...body,
            ...await this.signatureFor()
          }),
          method: "POST"
        });
      }
    };
    exports.Account2FA = Account2FA;
    var toPK = (pk) => crypto_1.PublicKey.from(pk);
  }
});

// node_modules/@near-js/accounts/lib/commonjs/account_creator.cjs
var require_account_creator = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/account_creator.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = void 0;
    var AccountCreator = class {
    };
    exports.AccountCreator = AccountCreator;
    var LocalAccountCreator = class extends AccountCreator {
      constructor(masterAccount, initialBalance) {
        super();
        __publicField(this, "masterAccount");
        __publicField(this, "initialBalance");
        this.masterAccount = masterAccount;
        this.initialBalance = initialBalance;
      }
      /**
       * Creates an account using a masterAccount, meaning the new account is created from an existing account
       * @param newAccountId The name of the NEAR account to be created
       * @param publicKey The public key from the masterAccount used to create this account
       * @returns {Promise<void>}
       */
      async createAccount(newAccountId, publicKey) {
        await this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);
      }
    };
    exports.LocalAccountCreator = LocalAccountCreator;
    var UrlAccountCreator = class extends AccountCreator {
      constructor(connection, helperUrl) {
        super();
        __publicField(this, "connection");
        __publicField(this, "helperUrl");
        this.connection = connection;
        this.helperUrl = helperUrl;
      }
      /**
       * Creates an account using a helperUrl
       * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository
       * @param newAccountId The name of the NEAR account to be created
       * @param publicKey The public key from the masterAccount used to create this account
       * @returns {Promise<void>}
       */
      async createAccount(newAccountId, publicKey) {
        await fetch(`${this.helperUrl}/account`, {
          body: JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }),
          method: "POST"
        });
      }
    };
    exports.UrlAccountCreator = UrlAccountCreator;
  }
});

// node_modules/@near-js/signers/node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "node_modules/@near-js/signers/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function bytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@near-js/signers/node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@near-js/signers/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@near-js/signers/node_modules/@noble/hashes/utils.js
var require_utils6 = __commonJS({
  "node_modules/@near-js/signers/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto2();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!isBytes(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!isBytes(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        if (!isBytes(a))
          throw new Error("Uint8Array expected");
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@near-js/signers/node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@near-js/signers/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils6();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@near-js/signers/node_modules/@noble/hashes/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/@near-js/signers/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils6();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@near-js/signers/lib/commonjs/signer.cjs
var require_signer = __commonJS({
  "node_modules/@near-js/signers/lib/commonjs/signer.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Signer = void 0;
    var Signer = class {
    };
    exports.Signer = Signer;
  }
});

// node_modules/@near-js/signers/lib/commonjs/in_memory_signer.cjs
var require_in_memory_signer = __commonJS({
  "node_modules/@near-js/signers/lib/commonjs/in_memory_signer.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InMemorySigner = void 0;
    var crypto_1 = require_commonjs3();
    var keystores_1 = require_commonjs4();
    var sha256_1 = require_sha2562();
    var signer_1 = require_signer();
    var InMemorySigner = class _InMemorySigner extends signer_1.Signer {
      constructor(keyStore) {
        super();
        __publicField(this, "keyStore");
        this.keyStore = keyStore;
      }
      /**
       * Creates a single account Signer instance with account, network and keyPair provided.
       *
       * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).
       *
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @param accountId The NEAR account to assign the key pair to
       * @param keyPair The keyPair to use for signing
       */
      static async fromKeyPair(networkId, accountId, keyPair) {
        const keyStore = new keystores_1.InMemoryKeyStore();
        await keyStore.setKey(networkId, accountId, keyPair);
        return new _InMemorySigner(keyStore);
      }
      /**
       * Creates a public key for the account given
       * @param accountId The NEAR account to assign a public key to
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @returns {Promise<PublicKey>}
       */
      async createKey(accountId, networkId, keyType) {
        const keyPair = keyType === crypto_1.KeyType.SECP256K1 ? crypto_1.KeyPair.fromRandom("secp256k1") : crypto_1.KeyPair.fromRandom("ed25519");
        await this.keyStore.setKey(networkId, accountId, keyPair);
        return keyPair.getPublicKey();
      }
      /**
       * Gets the existing public key for a given account
       * @param accountId The NEAR account to assign a public key to
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @returns {Promise<PublicKey>} Returns the public key or null if not found
       */
      async getPublicKey(accountId, networkId) {
        const keyPair = await this.keyStore.getKey(networkId, accountId);
        if (keyPair === null) {
          return null;
        }
        return keyPair.getPublicKey();
      }
      /**
       * @param message A message to be signed, typically a serialized transaction
       * @param accountId the NEAR account signing the message
       * @param networkId The targeted network. (ex. default, betanet, etc…)
       * @returns {Promise<Signature>}
       */
      async signMessage(message, accountId, networkId) {
        const hash = new Uint8Array((0, sha256_1.sha256)(message));
        if (!accountId) {
          throw new Error("InMemorySigner requires provided account id");
        }
        const keyPair = await this.keyStore.getKey(networkId, accountId);
        if (keyPair === null) {
          throw new Error(`Key for ${accountId} not found in ${networkId}`);
        }
        return keyPair.sign(hash);
      }
      toString() {
        return `InMemorySigner(${this.keyStore})`;
      }
    };
    exports.InMemorySigner = InMemorySigner;
  }
});

// node_modules/@near-js/signers/lib/commonjs/index.cjs
var require_commonjs8 = __commonJS({
  "node_modules/@near-js/signers/lib/commonjs/index.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Signer = exports.InMemorySigner = void 0;
    var in_memory_signer_1 = require_in_memory_signer();
    Object.defineProperty(exports, "InMemorySigner", { enumerable: true, get: function() {
      return in_memory_signer_1.InMemorySigner;
    } });
    var signer_1 = require_signer();
    Object.defineProperty(exports, "Signer", { enumerable: true, get: function() {
      return signer_1.Signer;
    } });
  }
});

// node_modules/@near-js/accounts/lib/commonjs/connection.cjs
var require_connection = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/connection.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Connection = void 0;
    var signers_1 = require_commonjs8();
    var providers_1 = require_commonjs7();
    function getProvider(config) {
      switch (config.type) {
        case void 0:
          return config;
        case "JsonRpcProvider":
          return new providers_1.JsonRpcProvider({ ...config.args });
        case "FailoverRpcProvider": {
          const providers = ((config == null ? void 0 : config.args) || []).map((arg) => new providers_1.JsonRpcProvider(arg));
          return new providers_1.FailoverRpcProvider(providers);
        }
        default:
          throw new Error(`Unknown provider type ${config.type}`);
      }
    }
    function getSigner(config) {
      switch (config.type) {
        case void 0:
          return config;
        case "InMemorySigner": {
          return new signers_1.InMemorySigner(config.keyStore);
        }
        default:
          throw new Error(`Unknown signer type ${config.type}`);
      }
    }
    var Connection = class _Connection {
      constructor(networkId, provider, signer, jsvmAccountId) {
        __publicField(this, "networkId");
        __publicField(this, "provider");
        __publicField(this, "signer");
        __publicField(this, "jsvmAccountId");
        this.networkId = networkId;
        this.provider = provider;
        this.signer = signer;
        this.jsvmAccountId = jsvmAccountId;
      }
      getConnection() {
        return this;
      }
      /**
       * @param config Contains connection info details
       */
      static fromConfig(config) {
        const provider = getProvider(config.provider);
        const signer = getSigner(config.signer);
        return new _Connection(config.networkId, provider, signer, config.jsvmAccountId);
      }
    };
    exports.Connection = Connection;
  }
});

// node_modules/lru_map/dist/lru.js
var require_lru = __commonJS({
  "node_modules/lru_map/dist/lru.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    !function(g, c) {
      typeof exports == "object" && typeof module != "undefined" ? c(exports) : typeof define == "function" && define.amd ? define(["exports"], c) : c((g = g || self).lru_map = g.lru_map || {});
    }(exports, function(g) {
      const c = Symbol("newer"), e = Symbol("older");
      class n {
        constructor(a, b) {
          typeof a !== "number" && (b = a, a = 0), this.size = 0, this.limit = a, this.oldest = this.newest = void 0, this._keymap = /* @__PURE__ */ new Map(), b && (this.assign(b), a < 1 && (this.limit = this.size));
        }
        _markEntryAsUsed(a) {
          if (a === this.newest) return;
          a[c] && (a === this.oldest && (this.oldest = a[c]), a[c][e] = a[e]), a[e] && (a[e][c] = a[c]), a[c] = void 0, a[e] = this.newest, this.newest && (this.newest[c] = a), this.newest = a;
        }
        assign(a) {
          let b, d = this.limit || Number.MAX_VALUE;
          this._keymap.clear();
          let m = a[Symbol.iterator]();
          for (let h = m.next(); !h.done; h = m.next()) {
            let f = new l(h.value[0], h.value[1]);
            this._keymap.set(f.key, f), b ? (b[c] = f, f[e] = b) : this.oldest = f, b = f;
            if (d-- == 0) throw new Error("overflow");
          }
          this.newest = b, this.size = this._keymap.size;
        }
        get(a) {
          var b = this._keymap.get(a);
          return b ? (this._markEntryAsUsed(b), b.value) : void 0;
        }
        set(a, b) {
          var d = this._keymap.get(a);
          return d ? (d.value = b, this._markEntryAsUsed(d), this) : (this._keymap.set(a, d = new l(a, b)), this.newest ? (this.newest[c] = d, d[e] = this.newest) : this.oldest = d, this.newest = d, ++this.size, this.size > this.limit && this.shift(), this);
        }
        shift() {
          var a = this.oldest;
          if (a) return this.oldest[c] ? (this.oldest = this.oldest[c], this.oldest[e] = void 0) : (this.oldest = void 0, this.newest = void 0), a[c] = a[e] = void 0, this._keymap.delete(a.key), --this.size, [a.key, a.value];
        }
        find(a) {
          let b = this._keymap.get(a);
          return b ? b.value : void 0;
        }
        has(a) {
          return this._keymap.has(a);
        }
        delete(a) {
          var b = this._keymap.get(a);
          return b ? (this._keymap.delete(b.key), b[c] && b[e] ? (b[e][c] = b[c], b[c][e] = b[e]) : b[c] ? (b[c][e] = void 0, this.oldest = b[c]) : b[e] ? (b[e][c] = void 0, this.newest = b[e]) : this.oldest = this.newest = void 0, this.size--, b.value) : void 0;
        }
        clear() {
          this.oldest = this.newest = void 0, this.size = 0, this._keymap.clear();
        }
        keys() {
          return new j(this.oldest);
        }
        values() {
          return new k(this.oldest);
        }
        entries() {
          return this;
        }
        [Symbol.iterator]() {
          return new i(this.oldest);
        }
        forEach(a, b) {
          typeof b !== "object" && (b = this);
          let d = this.oldest;
          for (; d; ) a.call(b, d.value, d.key, this), d = d[c];
        }
        toJSON() {
          for (var a = new Array(this.size), b = 0, d = this.oldest; d; ) a[b++] = { key: d.key, value: d.value }, d = d[c];
          return a;
        }
        toString() {
          for (var a = "", b = this.oldest; b; ) a += String(b.key) + ":" + b.value, b = b[c], b && (a += " < ");
          return a;
        }
      }
      g.LRUMap = n;
      function l(a, b) {
        this.key = a, this.value = b, this[c] = void 0, this[e] = void 0;
      }
      function i(a) {
        this.entry = a;
      }
      i.prototype[Symbol.iterator] = function() {
        return this;
      }, i.prototype.next = function() {
        let a = this.entry;
        return a ? (this.entry = a[c], { done: false, value: [a.key, a.value] }) : { done: true, value: void 0 };
      };
      function j(a) {
        this.entry = a;
      }
      j.prototype[Symbol.iterator] = function() {
        return this;
      }, j.prototype.next = function() {
        let a = this.entry;
        return a ? (this.entry = a[c], { done: false, value: a.key }) : { done: true, value: void 0 };
      };
      function k(a) {
        this.entry = a;
      }
      k.prototype[Symbol.iterator] = function() {
        return this;
      }, k.prototype.next = function() {
        let a = this.entry;
        return a ? (this.entry = a[c], { done: false, value: a.value }) : { done: true, value: void 0 };
      };
    });
  }
});

// node_modules/@near-js/accounts/lib/commonjs/local-view-execution/storage.cjs
var require_storage = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/local-view-execution/storage.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Storage = void 0;
    var lru_map_1 = require_lru();
    var _Storage = class _Storage {
      constructor(options = { max: _Storage.MAX_ELEMENTS }) {
        __publicField(this, "cache");
        // map block hash to block height
        __publicField(this, "blockHeights");
        this.cache = new lru_map_1.LRUMap(options.max);
        this.blockHeights = /* @__PURE__ */ new Map();
      }
      load(blockRef) {
        const noBlockId = !("blockId" in blockRef);
        if (noBlockId)
          return void 0;
        let blockId = blockRef.blockId;
        if (blockId.toString().length == 44) {
          blockId = this.blockHeights.get(blockId.toString());
        }
        return this.cache.get(blockId);
      }
      save(blockHash, { blockHeight, blockTimestamp, contractCode, contractState }) {
        this.blockHeights.set(blockHash, blockHeight);
        this.cache.set(blockHeight, { blockHeight, blockTimestamp, contractCode, contractState });
      }
    };
    __publicField(_Storage, "MAX_ELEMENTS", 100);
    var Storage = _Storage;
    exports.Storage = Storage;
  }
});

// node_modules/@near-js/accounts/node_modules/@noble/hashes/_assert.js
var require_assert3 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.anumber = anumber;
    exports.abytes = abytes;
    exports.ahash = ahash;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
    }
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function abytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
  }
});

// node_modules/@near-js/accounts/node_modules/@noble/hashes/crypto.js
var require_crypto3 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@near-js/accounts/node_modules/@noble/hashes/utils.js
var require_utils7 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.isLE = void 0;
    exports.isBytes = isBytes;
    exports.u8 = u8;
    exports.u32 = u32;
    exports.createView = createView;
    exports.rotr = rotr;
    exports.rotl = rotl;
    exports.byteSwap = byteSwap;
    exports.byteSwap32 = byteSwap32;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.asyncLoop = asyncLoop;
    exports.utf8ToBytes = utf8ToBytes;
    exports.toBytes = toBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.wrapConstructor = wrapConstructor;
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    exports.randomBytes = randomBytes;
    var crypto_1 = require_crypto3();
    var _assert_js_1 = require_assert3();
    function isBytes(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
    }
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.abytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error("utf8ToBytes expected string, got " + typeof str);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.abytes)(data);
      return data;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.abytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return crypto_1.crypto.randomBytes(bytesLength);
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@near-js/accounts/node_modules/@noble/hashes/_md.js
var require_md2 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = void 0;
    exports.setBigUint64 = setBigUint64;
    exports.Chi = Chi;
    exports.Maj = Maj;
    var _assert_js_1 = require_assert3();
    var utils_js_1 = require_utils7();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    function Chi(a, b, c) {
      return a & b ^ ~a & c;
    }
    function Maj(a, b, c) {
      return a & b ^ a & c ^ b & c;
    }
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.aexists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.aexists)(this);
        (0, _assert_js_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.HashMD = HashMD;
  }
});

// node_modules/@near-js/accounts/node_modules/@noble/hashes/sha256.js
var require_sha2563 = __commonJS({
  "node_modules/@near-js/accounts/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = exports.SHA256 = void 0;
    var _md_js_1 = require_md2();
    var utils_js_1 = require_utils7();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    exports.SHA256 = SHA256;
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@near-js/accounts/lib/commonjs/local-view-execution/runtime.cjs
var require_runtime = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/local-view-execution/runtime.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Runtime = void 0;
    var sha256_1 = require_sha2563();
    var notImplemented = (name) => () => {
      throw new Error("method not implemented: " + name);
    };
    var prohibitedInView = (name) => () => {
      throw new Error("method not available for view calls: " + name);
    };
    var Runtime = class {
      constructor({ contractCode, ...context }) {
        __publicField(this, "context");
        __publicField(this, "wasm");
        __publicField(this, "memory");
        __publicField(this, "registers");
        __publicField(this, "logs");
        __publicField(this, "result");
        this.context = context;
        this.wasm = this.prepareWASM(Buffer.from(contractCode, "base64"));
        this.memory = new WebAssembly.Memory({ initial: 1024, maximum: 2048 });
        this.registers = {};
        this.logs = [];
        this.result = Buffer.from([]);
      }
      readUTF16CStr(ptr) {
        const arr = [];
        const mem = new Uint16Array(this.memory.buffer);
        let key = Number(ptr) / 2;
        while (mem[key] != 0) {
          arr.push(mem[key]);
          key++;
        }
        return Buffer.from(Uint16Array.from(arr).buffer).toString("ucs2");
      }
      readUTF8CStr(len, ptr) {
        const arr = [];
        const mem = new Uint8Array(this.memory.buffer);
        let key = Number(ptr);
        for (let i = 0; i < len && mem[key] != 0; i++) {
          arr.push(mem[key]);
          key++;
        }
        return Buffer.from(arr).toString("utf8");
      }
      storageRead(keyLen, keyPtr) {
        const storageKey = Buffer.from(new Uint8Array(this.memory.buffer, Number(keyPtr), Number(keyLen)));
        const stateVal = this.context.contractState.filter((obj) => Buffer.compare(obj.key, storageKey) === 0).map((obj) => obj.value);
        if (stateVal.length === 0)
          return null;
        return stateVal.length > 1 ? stateVal : stateVal[0];
      }
      prepareWASM(input) {
        const parts = [];
        const magic = input.subarray(0, 4);
        if (magic.toString("utf8") !== "\0asm") {
          throw new Error("Invalid magic number");
        }
        const version = input.readUInt32LE(4);
        if (version != 1) {
          throw new Error("Invalid version: " + version);
        }
        let offset = 8;
        parts.push(input.subarray(0, offset));
        function decodeLEB128() {
          let result = 0;
          let shift = 0;
          let byte;
          do {
            byte = input[offset++];
            result |= (byte & 127) << shift;
            shift += 7;
          } while (byte & 128);
          return result;
        }
        function decodeLimits() {
          const flags = input[offset++];
          const hasMax = flags & 1;
          const initial = decodeLEB128();
          const max = hasMax ? decodeLEB128() : null;
          return { initial, max };
        }
        function decodeString() {
          const length = decodeLEB128();
          const result = input.subarray(offset, offset + length);
          offset += length;
          return result.toString("utf8");
        }
        function encodeLEB128(value) {
          const result = [];
          do {
            let byte = value & 127;
            value >>= 7;
            if (value !== 0) {
              byte |= 128;
            }
            result.push(byte);
          } while (value !== 0);
          return Buffer.from(result);
        }
        function encodeString(value) {
          const result = Buffer.from(value, "utf8");
          return Buffer.concat([encodeLEB128(result.length), result]);
        }
        do {
          const sectionStart = offset;
          const sectionId = input.readUInt8(offset);
          offset++;
          const sectionSize = decodeLEB128();
          const sectionEnd = offset + sectionSize;
          if (sectionId == 5) {
            parts.push(Buffer.from([5, 1, 0]));
          } else if (sectionId == 2) {
            const sectionParts = [];
            const numImports = decodeLEB128();
            for (let i = 0; i < numImports; i++) {
              const importStart = offset;
              decodeString();
              decodeString();
              const kind = input.readUInt8(offset);
              offset++;
              let skipImport = false;
              switch (kind) {
                case 0:
                  decodeLEB128();
                  break;
                case 1:
                  offset++;
                  decodeLimits();
                  break;
                case 2:
                  decodeLimits();
                  skipImport = true;
                  break;
                case 3:
                  offset++;
                  offset++;
                  break;
                default:
                  throw new Error("Invalid import kind: " + kind);
              }
              if (!skipImport) {
                sectionParts.push(input.subarray(importStart, offset));
              }
            }
            const importMemory = Buffer.concat([
              encodeString("env"),
              encodeString("memory"),
              Buffer.from([2]),
              // Memory import
              Buffer.from([0]),
              encodeLEB128(1)
            ]);
            sectionParts.push(importMemory);
            const sectionData = Buffer.concat([
              encodeLEB128(sectionParts.length),
              ...sectionParts
            ]);
            parts.push(Buffer.concat([
              Buffer.from([2]),
              // Import section
              encodeLEB128(sectionData.length),
              sectionData
            ]));
          } else if (sectionId == 7) {
            const sectionParts = [];
            const numExports = decodeLEB128();
            for (let i = 0; i < numExports; i++) {
              const exportStart = offset;
              decodeString();
              const kind = input.readUInt8(offset);
              offset++;
              decodeLEB128();
              if (kind !== 2) {
                sectionParts.push(input.subarray(exportStart, offset));
              }
            }
            const sectionData = Buffer.concat([
              encodeLEB128(sectionParts.length),
              ...sectionParts
            ]);
            parts.push(Buffer.concat([
              Buffer.from([7]),
              // Export section
              encodeLEB128(sectionData.length),
              sectionData
            ]));
          } else {
            parts.push(input.subarray(sectionStart, sectionEnd));
          }
          offset = sectionEnd;
        } while (offset < input.length);
        return Buffer.concat(parts);
      }
      // Host functions
      getRegisterLength(registerId) {
        return BigInt(this.registers[registerId.toString()] ? this.registers[registerId.toString()].length : Number.MAX_SAFE_INTEGER);
      }
      readFromRegister(registerId, ptr) {
        const mem = new Uint8Array(this.memory.buffer);
        mem.set(this.registers[registerId.toString()] || Buffer.from([]), Number(ptr));
      }
      getCurrentAccountId(registerId) {
        this.registers[registerId.toString()] = Buffer.from(this.context.contractId);
      }
      inputMethodArgs(registerId) {
        this.registers[registerId.toString()] = Buffer.from(this.context.methodArgs);
      }
      getBlockHeight() {
        return BigInt(this.context.blockHeight);
      }
      getBlockTimestamp() {
        return BigInt(this.context.blockTimestamp);
      }
      sha256(valueLen, valuePtr, registerId) {
        const value = new Uint8Array(this.memory.buffer, Number(valuePtr), Number(valueLen));
        this.registers[registerId.toString()] = (0, sha256_1.sha256)(value);
      }
      returnValue(valueLen, valuePtr) {
        this.result = Buffer.from(new Uint8Array(this.memory.buffer, Number(valuePtr), Number(valueLen)));
      }
      panic(message) {
        throw new Error("panic: " + message);
      }
      abort(msg_ptr, filename_ptr, line, col) {
        const msg = this.readUTF16CStr(msg_ptr);
        const filename = this.readUTF16CStr(filename_ptr);
        const message = `${msg} ${filename}:${line}:${col}`;
        if (!msg || !filename) {
          throw new Error("abort: String encoding is bad UTF-16 sequence.");
        }
        throw new Error("abort: " + message);
      }
      appendToLog(len, ptr) {
        this.logs.push(this.readUTF8CStr(len, ptr));
      }
      readStorage(key_len, key_ptr, register_id) {
        const result = this.storageRead(key_len, key_ptr);
        if (result == null) {
          return 0n;
        }
        this.registers[register_id] = result;
        return 1n;
      }
      hasStorageKey(key_len, key_ptr) {
        const result = this.storageRead(key_len, key_ptr);
        if (result == null) {
          return 0n;
        }
        return 1n;
      }
      getHostImports() {
        return {
          register_len: this.getRegisterLength.bind(this),
          read_register: this.readFromRegister.bind(this),
          current_account_id: this.getCurrentAccountId.bind(this),
          input: this.inputMethodArgs.bind(this),
          block_index: this.getBlockHeight.bind(this),
          block_timestamp: this.getBlockTimestamp.bind(this),
          sha256: this.sha256.bind(this),
          value_return: this.returnValue.bind(this),
          abort: this.abort.bind(this),
          log_utf8: this.appendToLog.bind(this),
          log_utf16: this.appendToLog.bind(this),
          storage_read: this.readStorage.bind(this),
          storage_has_key: this.hasStorageKey.bind(this),
          panic: () => this.panic("explicit guest panic"),
          panic_utf8: (len, ptr) => this.panic(this.readUTF8CStr(len, ptr)),
          // Not implemented
          epoch_height: notImplemented("epoch_height"),
          storage_usage: notImplemented("storage_usage"),
          account_balance: notImplemented("account_balance"),
          account_locked_balance: notImplemented("account_locked_balance"),
          random_seed: notImplemented("random_seed"),
          ripemd160: notImplemented("ripemd160"),
          keccak256: notImplemented("keccak256"),
          keccak512: notImplemented("keccak512"),
          ecrecover: notImplemented("ecrecover"),
          validator_stake: notImplemented("validator_stake"),
          validator_total_stake: notImplemented("validator_total_stake"),
          // Prohibited
          write_register: prohibitedInView("write_register"),
          signer_account_id: prohibitedInView("signer_account_id"),
          signer_account_pk: prohibitedInView("signer_account_pk"),
          predecessor_account_id: prohibitedInView("predecessor_account_id"),
          attached_deposit: prohibitedInView("attached_deposit"),
          prepaid_gas: prohibitedInView("prepaid_gas"),
          used_gas: prohibitedInView("used_gas"),
          promise_create: prohibitedInView("promise_create"),
          promise_then: prohibitedInView("promise_then"),
          promise_and: prohibitedInView("promise_and"),
          promise_batch_create: prohibitedInView("promise_batch_create"),
          promise_batch_then: prohibitedInView("promise_batch_then"),
          promise_batch_action_create_account: prohibitedInView("promise_batch_action_create_account"),
          promise_batch_action_deploy_contract: prohibitedInView("promise_batch_action_deploy_contract"),
          promise_batch_action_function_call: prohibitedInView("promise_batch_action_function_call"),
          promise_batch_action_function_call_weight: prohibitedInView("promise_batch_action_function_call_weight"),
          promise_batch_action_transfer: prohibitedInView("promise_batch_action_transfer"),
          promise_batch_action_stake: prohibitedInView("promise_batch_action_stake"),
          promise_batch_action_add_key_with_full_access: prohibitedInView("promise_batch_action_add_key_with_full_access"),
          promise_batch_action_add_key_with_function_call: prohibitedInView("promise_batch_action_add_key_with_function_call"),
          promise_batch_action_delete_key: prohibitedInView("promise_batch_action_delete_key"),
          promise_batch_action_delete_account: prohibitedInView("promise_batch_action_delete_account"),
          promise_results_count: prohibitedInView("promise_results_count"),
          promise_result: prohibitedInView("promise_result"),
          promise_return: prohibitedInView("promise_return"),
          storage_write: prohibitedInView("storage_write"),
          storage_remove: prohibitedInView("storage_remove")
        };
      }
      async execute(methodName) {
        const module2 = await WebAssembly.compile(this.wasm);
        const instance = await WebAssembly.instantiate(module2, { env: { ...this.getHostImports(), memory: this.memory } });
        const callMethod = instance.exports[methodName];
        if (callMethod == void 0) {
          throw new Error(`Contract method '${methodName}' does not exists in contract ${this.context.contractId} for block id ${this.context.blockHeight}`);
        }
        callMethod();
        return {
          result: this.result,
          logs: this.logs
        };
      }
    };
    exports.Runtime = Runtime;
  }
});

// node_modules/@near-js/accounts/lib/commonjs/local-view-execution/index.cjs
var require_local_view_execution = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/local-view-execution/index.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalViewExecution = void 0;
    var utils_1 = require_commonjs2();
    var storage_1 = require_storage();
    var runtime_1 = require_runtime();
    var utils_2 = require_utils5();
    var LocalViewExecution = class {
      constructor(connection) {
        __publicField(this, "connection");
        __publicField(this, "storage");
        this.connection = connection.getConnection();
        this.storage = new storage_1.Storage();
      }
      async fetchContractCode(contractId, blockQuery) {
        const result = await this.connection.provider.query({
          request_type: "view_code",
          account_id: contractId,
          ...blockQuery
        });
        return result.code_base64;
      }
      async fetchContractState(contractId, blockQuery) {
        return (0, utils_2.viewState)(this.connection, contractId, "", blockQuery);
      }
      async fetch(contractId, blockQuery) {
        const block = await this.connection.provider.block(blockQuery);
        const blockHash = block.header.hash;
        const blockHeight = block.header.height;
        const blockTimestamp = block.header.timestamp;
        const contractCode = await this.fetchContractCode(contractId, blockQuery);
        const contractState = await this.fetchContractState(contractId, blockQuery);
        return {
          blockHash,
          blockHeight,
          blockTimestamp,
          contractCode,
          contractState
        };
      }
      async loadOrFetch(contractId, blockQuery) {
        const stored = this.storage.load(blockQuery);
        if (stored) {
          return stored;
        }
        const { blockHash, ...fetched } = await this.fetch(contractId, blockQuery);
        this.storage.save(blockHash, fetched);
        return fetched;
      }
      /**
       * Calls a view function on a contract, fetching the contract code and state if needed.
       * @param options Options for calling the view function.
       * @param options.contractId The contract account ID.
       * @param options.methodName The name of the view function to call.
       * @param options.args The arguments to pass to the view function.
       * @param options.blockQuery The block query options.
       * @returns {Promise<any>} - A promise that resolves to the result of the view function.
       */
      async viewFunction({ contractId, methodName, args = {}, blockQuery = { finality: "optimistic" } }) {
        const methodArgs = JSON.stringify(args);
        const { contractCode, contractState, blockHeight, blockTimestamp } = await this.loadOrFetch(contractId, blockQuery);
        const runtime = new runtime_1.Runtime({ contractId, contractCode, contractState, blockHeight, blockTimestamp, methodArgs });
        const { result, logs } = await runtime.execute(methodName);
        if (logs) {
          (0, utils_1.printTxOutcomeLogs)({ contractId, logs });
        }
        return JSON.parse(Buffer.from(result).toString());
      }
    };
    exports.LocalViewExecution = LocalViewExecution;
  }
});

// node_modules/is-property/is-property.js
var require_is_property = __commonJS({
  "node_modules/is-property/is-property.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function isProperty(str) {
      return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str);
    }
    module.exports = isProperty;
  }
});

// node_modules/generate-object-property/index.js
var require_generate_object_property = __commonJS({
  "node_modules/generate-object-property/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var isProperty = require_is_property();
    var gen = function(obj, prop) {
      return isProperty(prop) ? obj + "." + prop : obj + "[" + JSON.stringify(prop) + "]";
    };
    gen.valid = isProperty;
    gen.property = function(prop) {
      return isProperty(prop) ? prop : JSON.stringify(prop);
    };
    module.exports = gen;
  }
});

// node_modules/generate-function/index.js
var require_generate_function = __commonJS({
  "node_modules/generate-function/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var util = require_util();
    var isProperty = require_is_property();
    var INDENT_START = /[\{\[]/;
    var INDENT_END = /[\}\]]/;
    var RESERVED = [
      "do",
      "if",
      "in",
      "for",
      "let",
      "new",
      "try",
      "var",
      "case",
      "else",
      "enum",
      "eval",
      "null",
      "this",
      "true",
      "void",
      "with",
      "await",
      "break",
      "catch",
      "class",
      "const",
      "false",
      "super",
      "throw",
      "while",
      "yield",
      "delete",
      "export",
      "import",
      "public",
      "return",
      "static",
      "switch",
      "typeof",
      "default",
      "extends",
      "finally",
      "package",
      "private",
      "continue",
      "debugger",
      "function",
      "arguments",
      "interface",
      "protected",
      "implements",
      "instanceof",
      "NaN",
      "undefined"
    ];
    var RESERVED_MAP = {};
    for (i = 0; i < RESERVED.length; i++) {
      RESERVED_MAP[RESERVED[i]] = true;
    }
    var i;
    var isVariable = function(name) {
      return isProperty(name) && !RESERVED_MAP.hasOwnProperty(name);
    };
    var formats = {
      s: function(s) {
        return "" + s;
      },
      d: function(d) {
        return "" + Number(d);
      },
      o: function(o) {
        return JSON.stringify(o);
      }
    };
    var genfun = function() {
      var lines = [];
      var indent = 0;
      var vars = {};
      var push = function(str) {
        var spaces = "";
        while (spaces.length < indent * 2) spaces += "  ";
        lines.push(spaces + str);
      };
      var pushLine = function(line2) {
        if (INDENT_END.test(line2.trim()[0]) && INDENT_START.test(line2[line2.length - 1])) {
          indent--;
          push(line2);
          indent++;
          return;
        }
        if (INDENT_START.test(line2[line2.length - 1])) {
          push(line2);
          indent++;
          return;
        }
        if (INDENT_END.test(line2.trim()[0])) {
          indent--;
          push(line2);
          return;
        }
        push(line2);
      };
      var line = function(fmt) {
        if (!fmt) return line;
        if (arguments.length === 1 && fmt.indexOf("\n") > -1) {
          var lines2 = fmt.trim().split("\n");
          for (var i2 = 0; i2 < lines2.length; i2++) {
            pushLine(lines2[i2].trim());
          }
        } else {
          pushLine(util.format.apply(util, arguments));
        }
        return line;
      };
      line.scope = {};
      line.formats = formats;
      line.sym = function(name) {
        if (!name || !isVariable(name)) name = "tmp";
        if (!vars[name]) vars[name] = 0;
        return name + (vars[name]++ || "");
      };
      line.property = function(obj, name) {
        if (arguments.length === 1) {
          name = obj;
          obj = "";
        }
        name = name + "";
        if (isProperty(name)) return obj ? obj + "." + name : name;
        return obj ? obj + "[" + JSON.stringify(name) + "]" : JSON.stringify(name);
      };
      line.toString = function() {
        return lines.join("\n");
      };
      line.toFunction = function(scope) {
        if (!scope) scope = {};
        var src = "return (" + line.toString() + ")";
        Object.keys(line.scope).forEach(function(key) {
          if (!scope[key]) scope[key] = line.scope[key];
        });
        var keys = Object.keys(scope).map(function(key) {
          return key;
        });
        var vals = keys.map(function(key) {
          return scope[key];
        });
        return Function.apply(null, keys.concat(src)).apply(null, vals);
      };
      if (arguments.length) line.apply(null, arguments);
      return line;
    };
    genfun.formats = formats;
    module.exports = genfun;
  }
});

// node_modules/jsonpointer/jsonpointer.js
var require_jsonpointer = __commonJS({
  "node_modules/jsonpointer/jsonpointer.js"(exports) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str)) return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p = 1, len = pointer.length; p < len; ) {
        if (pointer[p] === "constructor" || pointer[p] === "prototype" || pointer[p] === "__proto__") return obj;
        part = untilde(pointer[p++]);
        hasNextPart = len > p;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p] !== "" && pointer[p] < Infinity || pointer[p] === "-") obj[part] = [];
            else obj[part] = {};
          }
        }
        if (!hasNextPart) break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0) delete obj[part];
      else obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "") return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get(obj, pointer) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1) return obj;
      for (var p = 1; p < len; ) {
        obj = obj[untilde(pointer[p++])];
        if (len === p) return obj;
        if (typeof obj !== "object" || obj === null) return void 0;
      }
    }
    function set(obj, pointer, value) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get(object, compiled);
        },
        set: function(object, value) {
          return set(object, compiled, value);
        }
      };
    }
    exports.get = get;
    exports.set = set;
    exports.compile = compile;
  }
});

// node_modules/is-my-ip-valid/index.js
var require_is_my_ip_valid = __commonJS({
  "node_modules/is-my-ip-valid/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var reIpv4FirstPass = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
    var reSubnetString = /\/\d{1,3}(?=%|$)/;
    var reForwardSlash = /\//;
    var reZone = /%.*$/;
    var reBadCharacters = /([^0-9a-f:/%])/i;
    var reBadAddress = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/i;
    function validate4(input) {
      if (!reIpv4FirstPass.test(input)) return false;
      var parts = input.split(".");
      if (parts.length !== 4) return false;
      if (parts[0][0] === "0" && parts[0].length > 1) return false;
      if (parts[1][0] === "0" && parts[1].length > 1) return false;
      if (parts[2][0] === "0" && parts[2].length > 1) return false;
      if (parts[3][0] === "0" && parts[3].length > 1) return false;
      var n0 = Number(parts[0]);
      var n1 = Number(parts[1]);
      var n2 = Number(parts[2]);
      var n3 = Number(parts[3]);
      return n0 >= 0 && n0 < 256 && n1 >= 0 && n1 < 256 && n2 >= 0 && n2 < 256 && n3 >= 0 && n3 < 256;
    }
    function validate6(input) {
      var withoutSubnet = input.replace(reSubnetString, "");
      var hasSubnet = input.length !== withoutSubnet.length;
      if (hasSubnet) return false;
      if (!hasSubnet) {
        if (reForwardSlash.test(input)) return false;
      }
      var withoutZone = withoutSubnet.replace(reZone, "");
      var lastPartSeparator = withoutZone.lastIndexOf(":");
      if (lastPartSeparator === -1) return false;
      var lastPart = withoutZone.substring(lastPartSeparator + 1);
      var hasV4Part = validate4(lastPart);
      var address = hasV4Part ? withoutZone.substring(0, lastPartSeparator + 1) + "1234:5678" : withoutZone;
      if (reBadCharacters.test(address)) return false;
      if (reBadAddress.test(address)) return false;
      var halves = address.split("::");
      if (halves.length > 2) return false;
      if (halves.length === 2) {
        var first = halves[0] === "" ? [] : halves[0].split(":");
        var last = halves[1] === "" ? [] : halves[1].split(":");
        var remainingLength = 8 - (first.length + last.length);
        if (remainingLength <= 0) return false;
      } else {
        if (address.split(":").length !== 8) return false;
      }
      return true;
    }
    function validate(input) {
      return validate4(input) || validate6(input);
    }
    module.exports = function validator(options) {
      if (!options) options = {};
      if (options.version === 4) return validate4;
      if (options.version === 6) return validate6;
      if (options.version == null) return validate;
      throw new Error("Unknown version: " + options.version);
    };
    module.exports["__all_regexes__"] = [
      reIpv4FirstPass,
      reSubnetString,
      reForwardSlash,
      reZone,
      reBadCharacters,
      reBadAddress
    ];
  }
});

// node_modules/is-my-json-valid/formats.js
var require_formats = __commonJS({
  "node_modules/is-my-json-valid/formats.js"(exports) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var createIpValidator = require_is_my_ip_valid();
    var reEmailWhitespace = /\s/;
    var reHostnameFirstPass = /^[a-zA-Z0-9.-]+$/;
    var reHostnamePart = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/;
    var rePhoneFirstPass = /^\+[0-9][0-9 ]{5,27}[0-9]$/;
    var rePhoneDoubleSpace = / {2}/;
    var rePhoneGlobalSpace = / /g;
    exports["date-time"] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(?:\.\d+|)([zZ]|[+-]\d{2}:\d{2})$/;
    exports["date"] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/;
    exports["time"] = /^\d{2}:\d{2}:\d{2}$/;
    exports["email"] = function(input) {
      return input.indexOf("@") !== -1 && !reEmailWhitespace.test(input);
    };
    exports["ip-address"] = exports["ipv4"] = createIpValidator({ version: 4 });
    exports["ipv6"] = createIpValidator({ version: 6 });
    exports["uri"] = /^[a-zA-Z][a-zA-Z0-9+\-.]*:[^\s]*$/;
    exports["color"] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/;
    exports["hostname"] = function(input) {
      if (!reHostnameFirstPass.test(input)) return false;
      var parts = input.split(".");
      for (var i = 0; i < parts.length; i++) {
        if (!reHostnamePart.test(parts[i])) return false;
      }
      return true;
    };
    exports["alpha"] = /^[a-zA-Z]+$/;
    exports["alphanumeric"] = /^[a-zA-Z0-9]+$/;
    exports["style"] = /.:\s*[^;]/g;
    exports["phone"] = function(input) {
      if (!rePhoneFirstPass.test(input)) return false;
      if (rePhoneDoubleSpace.test(input)) return false;
      var digits = input.substring(1).replace(rePhoneGlobalSpace, "").length;
      return digits >= 7 && digits <= 15;
    };
    exports["utc-millisec"] = /^[0-9]{1,15}\.?[0-9]{0,15}$/;
  }
});

// node_modules/is-my-json-valid/index.js
var require_is_my_json_valid = __commonJS({
  "node_modules/is-my-json-valid/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var genobj = require_generate_object_property();
    var genfun = require_generate_function();
    var jsonpointer = require_jsonpointer();
    var xtend = require_immutable();
    var formats = require_formats();
    var get = function(obj, additionalSchemas, ptr) {
      var visit = function(sub) {
        if (sub && sub.id === ptr) return sub;
        if (typeof sub !== "object" || !sub) return null;
        return Object.keys(sub).reduce(function(res2, k) {
          return res2 || visit(sub[k]);
        }, null);
      };
      var res = visit(obj);
      if (res) return res;
      ptr = ptr.replace(/^#/, "");
      ptr = ptr.replace(/\/$/, "");
      try {
        return jsonpointer.get(obj, decodeURI(ptr));
      } catch (err) {
        var end = ptr.indexOf("#");
        var other;
        if (end !== 0) {
          if (end === -1) {
            other = additionalSchemas[ptr];
          } else {
            var ext = ptr.slice(0, end);
            other = additionalSchemas[ext];
            var fragment = ptr.slice(end).replace(/^#/, "");
            try {
              return jsonpointer.get(other, fragment);
            } catch (err2) {
            }
          }
        } else {
          other = additionalSchemas[ptr];
        }
        return other || null;
      }
    };
    var types = {};
    types.any = function() {
      return "true";
    };
    types.null = function(name) {
      return name + " === null";
    };
    types.boolean = function(name) {
      return "typeof " + name + ' === "boolean"';
    };
    types.array = function(name) {
      return "Array.isArray(" + name + ")";
    };
    types.object = function(name) {
      return "typeof " + name + ' === "object" && ' + name + " && !Array.isArray(" + name + ")";
    };
    types.number = function(name) {
      return "typeof " + name + ' === "number" && isFinite(' + name + ")";
    };
    types.integer = function(name) {
      return "typeof " + name + ' === "number" && (Math.floor(' + name + ") === " + name + " || " + name + " > 9007199254740992 || " + name + " < -9007199254740992)";
    };
    types.string = function(name) {
      return "typeof " + name + ' === "string"';
    };
    var unique = function(array, len) {
      len = Math.min(len === -1 ? array.length : len, array.length);
      var list = [];
      for (var i = 0; i < len; i++) {
        list.push(typeof array[i] === "object" ? JSON.stringify(array[i]) : array[i]);
      }
      for (var i = 1; i < list.length; i++) {
        if (list.indexOf(list[i]) !== i) return false;
      }
      return true;
    };
    var isMultipleOf = function(name, multipleOf) {
      var res;
      var factor = (multipleOf | 0) !== multipleOf ? Math.pow(10, multipleOf.toString().split(".").pop().length) : 1;
      if (factor > 1) {
        var factorName = (name | 0) !== name ? Math.pow(10, name.toString().split(".").pop().length) : 1;
        if (factorName > factor) res = true;
        else res = Math.round(factor * name) % (factor * multipleOf);
      } else res = name % multipleOf;
      return !res;
    };
    var testLimitedRegex = function(r, s, maxLength) {
      if (maxLength > -1 && s.length > maxLength) return true;
      return r.test(s);
    };
    var compile = function(schema, cache, root, reporter, opts) {
      var fmts = opts ? xtend(formats, opts.formats) : formats;
      var scope = { unique, formats: fmts, isMultipleOf, testLimitedRegex };
      var verbose = opts ? !!opts.verbose : false;
      var greedy = opts && opts.greedy !== void 0 ? opts.greedy : false;
      var syms = {};
      var allocated = [];
      var gensym = function(name) {
        var res = name + (syms[name] = (syms[name] || 0) + 1);
        allocated.push(res);
        return res;
      };
      var formatName = function(field) {
        var s = JSON.stringify(field);
        try {
          var pattern = /\[([^\[\]"]+)\]/;
          while (pattern.test(s)) s = s.replace(pattern, replacer);
          return s;
        } catch (_) {
          return JSON.stringify(field);
        }
        function replacer(match, v) {
          if (allocated.indexOf(v) === -1) throw new Error("Unreplaceable");
          return '." + ' + v + ' + "';
        }
      };
      var reversePatterns = {};
      var patterns = function(p) {
        if (reversePatterns[p]) return reversePatterns[p];
        var n = gensym("pattern");
        scope[n] = new RegExp(p);
        reversePatterns[p] = n;
        return n;
      };
      var vars = ["i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "x", "y", "z"];
      var genloop = function() {
        var v = vars.shift();
        vars.push(v + v[0]);
        allocated.push(v);
        return v;
      };
      var visit = function(name, node, reporter2, filter, schemaPath) {
        var properties = node.properties;
        var type = node.type;
        var tuple = false;
        if (Array.isArray(node.items)) {
          properties = {};
          node.items.forEach(function(item, i2) {
            properties[i2] = item;
          });
          type = "array";
          tuple = true;
        }
        var indent = 0;
        var error = function(msg, prop, value) {
          validate("errors++");
          if (reporter2 === true) {
            validate("if (validate.errors === null) validate.errors = []");
            if (verbose) {
              validate(
                "validate.errors.push({field:%s,message:%s,value:%s,type:%s,schemaPath:%s})",
                formatName(prop || name),
                JSON.stringify(msg),
                value || name,
                JSON.stringify(type),
                JSON.stringify(schemaPath)
              );
            } else {
              validate("validate.errors.push({field:%s,message:%s})", formatName(prop || name), JSON.stringify(msg));
            }
          }
        };
        if (node.required === true) {
          indent++;
          validate("if (%s === undefined) {", name);
          error("is required");
          validate("} else {");
        } else {
          indent++;
          validate("if (%s !== undefined) {", name);
        }
        var valid = [].concat(type).map(function(t) {
          if (t && !types.hasOwnProperty(t)) {
            throw new Error("Unknown type: " + t);
          }
          return types[t || "any"](name);
        }).join(" || ") || "true";
        if (valid !== "true") {
          indent++;
          validate("if (!(%s)) {", valid);
          error("is the wrong type");
          validate("} else {");
        }
        if (tuple) {
          if (node.additionalItems === false) {
            validate("if (%s.length > %d) {", name, node.items.length);
            error("has additional items");
            validate("}");
          } else if (node.additionalItems) {
            var i = genloop();
            validate("for (var %s = %d; %s < %s.length; %s++) {", i, node.items.length, i, name, i);
            visit(name + "[" + i + "]", node.additionalItems, reporter2, filter, schemaPath.concat("additionalItems"));
            validate("}");
          }
        }
        if (node.format && fmts[node.format]) {
          if (type !== "string" && formats[node.format]) validate("if (%s) {", types.string(name));
          var n = gensym("format");
          scope[n] = fmts[node.format];
          if (typeof scope[n] === "function") validate("if (!%s(%s)) {", n, name);
          else validate("if (!testLimitedRegex(%s, %s, %d)) {", n, name, typeof node.maxLength === "undefined" ? -1 : node.maxLength);
          error("must be " + node.format + " format");
          validate("}");
          if (type !== "string" && formats[node.format]) validate("}");
        }
        if (Array.isArray(node.required)) {
          var n = gensym("missing");
          validate("var %s = 0", n);
          var checkRequired = function(req) {
            var prop = genobj(name, req);
            validate("if (%s === undefined) {", prop);
            error("is required", prop);
            validate("%s++", n);
            validate("}");
          };
          validate("if ((%s)) {", type !== "object" ? types.object(name) : "true");
          node.required.map(checkRequired);
          validate("}");
          if (!greedy) {
            validate("if (%s === 0) {", n);
            indent++;
          }
        }
        if (node.uniqueItems) {
          if (type !== "array") validate("if (%s) {", types.array(name));
          validate("if (!(unique(%s, %d))) {", name, node.maxItems || -1);
          error("must be unique");
          validate("}");
          if (type !== "array") validate("}");
        }
        if (node.enum) {
          var complex = node.enum.some(function(e) {
            return typeof e === "object";
          });
          var compare = complex ? function(e) {
            return "JSON.stringify(" + name + ") !== JSON.stringify(" + JSON.stringify(e) + ")";
          } : function(e) {
            return name + " !== " + JSON.stringify(e);
          };
          validate("if (%s) {", node.enum.map(compare).join(" && ") || "false");
          error("must be an enum value");
          validate("}");
        }
        if (node.dependencies) {
          if (type !== "object") validate("if (%s) {", types.object(name));
          Object.keys(node.dependencies).forEach(function(key) {
            var deps = node.dependencies[key];
            if (typeof deps === "string") deps = [deps];
            var exists = function(k) {
              return genobj(name, k) + " !== undefined";
            };
            if (Array.isArray(deps)) {
              validate("if (%s !== undefined && !(%s)) {", genobj(name, key), deps.map(exists).join(" && ") || "true");
              error("dependencies not set");
              validate("}");
            }
            if (typeof deps === "object") {
              validate("if (%s !== undefined) {", genobj(name, key));
              visit(name, deps, reporter2, filter, schemaPath.concat(["dependencies", key]));
              validate("}");
            }
          });
          if (type !== "object") validate("}");
        }
        if (node.additionalProperties || node.additionalProperties === false) {
          if (type !== "object") validate("if (%s) {", types.object(name));
          var i = genloop();
          var keys = gensym("keys");
          var toCompare = function(p2) {
            return keys + "[" + i + "] !== " + JSON.stringify(p2);
          };
          var toTest = function(p2) {
            return "!" + patterns(p2) + ".test(" + keys + "[" + i + "])";
          };
          var additionalProp = Object.keys(properties || {}).map(toCompare).concat(Object.keys(node.patternProperties || {}).map(toTest)).join(" && ") || "true";
          validate("var %s = Object.keys(%s)", keys, name)("for (var %s = 0; %s < %s.length; %s++) {", i, i, keys, i)("if (%s) {", additionalProp);
          if (node.additionalProperties === false) {
            if (filter) validate("delete %s", name + "[" + keys + "[" + i + "]]");
            error("has additional properties", null, JSON.stringify(name + ".") + " + " + keys + "[" + i + "]");
          } else {
            visit(name + "[" + keys + "[" + i + "]]", node.additionalProperties, reporter2, filter, schemaPath.concat(["additionalProperties"]));
          }
          validate("}")("}");
          if (type !== "object") validate("}");
        }
        if (node.$ref) {
          var sub = get(root, opts && opts.schemas || {}, node.$ref);
          if (sub) {
            var fn = cache[node.$ref];
            if (!fn) {
              cache[node.$ref] = function proxy(data) {
                return fn(data);
              };
              fn = compile(sub, cache, root, false, opts);
            }
            var n = gensym("ref");
            scope[n] = fn;
            validate("if (!(%s(%s))) {", n, name);
            error("referenced schema does not match");
            validate("}");
          }
        }
        if (node.not) {
          var prev = gensym("prev");
          validate("var %s = errors", prev);
          visit(name, node.not, false, filter, schemaPath.concat("not"));
          validate("if (%s === errors) {", prev);
          error("negative schema matches");
          validate("} else {")("errors = %s", prev)("}");
        }
        if (node.items && !tuple) {
          if (type !== "array") validate("if (%s) {", types.array(name));
          var i = genloop();
          validate("for (var %s = 0; %s < %s.length; %s++) {", i, i, name, i);
          visit(name + "[" + i + "]", node.items, reporter2, filter, schemaPath.concat("items"));
          validate("}");
          if (type !== "array") validate("}");
        }
        if (node.patternProperties) {
          if (type !== "object") validate("if (%s) {", types.object(name));
          var keys = gensym("keys");
          var i = genloop();
          validate("var %s = Object.keys(%s)", keys, name)("for (var %s = 0; %s < %s.length; %s++) {", i, i, keys, i);
          Object.keys(node.patternProperties).forEach(function(key) {
            var p2 = patterns(key);
            validate("if (%s.test(%s)) {", p2, keys + "[" + i + "]");
            visit(name + "[" + keys + "[" + i + "]]", node.patternProperties[key], reporter2, filter, schemaPath.concat(["patternProperties", key]));
            validate("}");
          });
          validate("}");
          if (type !== "object") validate("}");
        }
        if (node.pattern) {
          var p = patterns(node.pattern);
          if (type !== "string") validate("if (%s) {", types.string(name));
          validate("if (!(testLimitedRegex(%s, %s, %d))) {", p, name, typeof node.maxLength === "undefined" ? -1 : node.maxLength);
          error("pattern mismatch");
          validate("}");
          if (type !== "string") validate("}");
        }
        if (node.allOf) {
          node.allOf.forEach(function(sch, key) {
            visit(name, sch, reporter2, filter, schemaPath.concat(["allOf", key]));
          });
        }
        if (node.anyOf && node.anyOf.length) {
          var prev = gensym("prev");
          node.anyOf.forEach(function(sch, i2) {
            if (i2 === 0) {
              validate("var %s = errors", prev);
            } else {
              validate("if (errors !== %s) {", prev)("errors = %s", prev);
            }
            visit(name, sch, false, false, schemaPath);
          });
          node.anyOf.forEach(function(sch, i2) {
            if (i2) validate("}");
          });
          validate("if (%s !== errors) {", prev);
          error("no schemas match");
          validate("}");
        }
        if (node.oneOf && node.oneOf.length) {
          var prev = gensym("prev");
          var passes = gensym("passes");
          validate("var %s = errors", prev)("var %s = 0", passes);
          node.oneOf.forEach(function(sch, i2) {
            visit(name, sch, false, false, schemaPath);
            validate("if (%s === errors) {", prev)("%s++", passes)("} else {")("errors = %s", prev)("}");
          });
          validate("if (%s !== 1) {", passes);
          error("no (or more than one) schemas match");
          validate("}");
        }
        if (node.multipleOf !== void 0) {
          if (type !== "number" && type !== "integer") validate("if (%s) {", types.number(name));
          validate("if (!isMultipleOf(%s, %d)) {", name, node.multipleOf);
          error("has a remainder");
          validate("}");
          if (type !== "number" && type !== "integer") validate("}");
        }
        if (node.maxProperties !== void 0) {
          if (type !== "object") validate("if (%s) {", types.object(name));
          validate("if (Object.keys(%s).length > %d) {", name, node.maxProperties);
          error("has more properties than allowed");
          validate("}");
          if (type !== "object") validate("}");
        }
        if (node.minProperties !== void 0) {
          if (type !== "object") validate("if (%s) {", types.object(name));
          validate("if (Object.keys(%s).length < %d) {", name, node.minProperties);
          error("has less properties than allowed");
          validate("}");
          if (type !== "object") validate("}");
        }
        if (node.maxItems !== void 0) {
          if (type !== "array") validate("if (%s) {", types.array(name));
          validate("if (%s.length > %d) {", name, node.maxItems);
          error("has more items than allowed");
          validate("}");
          if (type !== "array") validate("}");
        }
        if (node.minItems !== void 0) {
          if (type !== "array") validate("if (%s) {", types.array(name));
          validate("if (%s.length < %d) {", name, node.minItems);
          error("has less items than allowed");
          validate("}");
          if (type !== "array") validate("}");
        }
        if (node.maxLength !== void 0) {
          if (type !== "string") validate("if (%s) {", types.string(name));
          validate("if (%s.length > %d) {", name, node.maxLength);
          error("has longer length than allowed");
          validate("}");
          if (type !== "string") validate("}");
        }
        if (node.minLength !== void 0) {
          if (type !== "string") validate("if (%s) {", types.string(name));
          validate("if (%s.length < %d) {", name, node.minLength);
          error("has less length than allowed");
          validate("}");
          if (type !== "string") validate("}");
        }
        if (node.minimum !== void 0) {
          if (type !== "number" && type !== "integer") validate("if (%s) {", types.number(name));
          validate("if (%s %s %d) {", name, node.exclusiveMinimum ? "<=" : "<", node.minimum);
          error("is less than minimum");
          validate("}");
          if (type !== "number" && type !== "integer") validate("}");
        }
        if (node.maximum !== void 0) {
          if (type !== "number" && type !== "integer") validate("if (%s) {", types.number(name));
          validate("if (%s %s %d) {", name, node.exclusiveMaximum ? ">=" : ">", node.maximum);
          error("is more than maximum");
          validate("}");
          if (type !== "number" && type !== "integer") validate("}");
        }
        if (properties) {
          Object.keys(properties).forEach(function(p2) {
            if (Array.isArray(type) && type.indexOf("null") !== -1) validate("if (%s !== null) {", name);
            visit(
              genobj(name, p2),
              properties[p2],
              reporter2,
              filter,
              schemaPath.concat(tuple ? p2 : ["properties", p2])
            );
            if (Array.isArray(type) && type.indexOf("null") !== -1) validate("}");
          });
        }
        while (indent--) validate("}");
      };
      var validate = genfun("function validate(data) {")("if (data === undefined) data = null")("validate.errors = null")("var errors = 0");
      visit("data", schema, reporter, opts && opts.filter, []);
      validate("return errors === 0")("}");
      validate = validate.toFunction(scope);
      validate.errors = null;
      if (Object.defineProperty) {
        Object.defineProperty(validate, "error", {
          get: function() {
            if (!validate.errors) return "";
            return validate.errors.map(function(err) {
              return err.field + " " + err.message;
            }).join("\n");
          }
        });
      }
      validate.toJSON = function() {
        return schema;
      };
      return validate;
    };
    module.exports = function(schema, opts) {
      if (typeof schema === "string") schema = JSON.parse(schema);
      return compile(schema, {}, schema, true, opts);
    };
    module.exports.filter = function(schema, opts) {
      var validate = module.exports(schema, xtend(opts, { filter: true }));
      return function(sch) {
        validate(sch);
        return sch;
      };
    };
  }
});

// node_modules/near-abi/lib/index.js
var require_lib = __commonJS({
  "node_modules/near-abi/lib/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbiSerializationType = exports.AbiFunctionModifier = exports.AbiFunctionKind = exports.SCHEMA_VERSION = void 0;
    exports.SCHEMA_VERSION = "0.4.0";
    var AbiFunctionKind;
    (function(AbiFunctionKind2) {
      AbiFunctionKind2["View"] = "view";
      AbiFunctionKind2["Call"] = "call";
    })(AbiFunctionKind = exports.AbiFunctionKind || (exports.AbiFunctionKind = {}));
    var AbiFunctionModifier;
    (function(AbiFunctionModifier2) {
      AbiFunctionModifier2["Init"] = "init";
      AbiFunctionModifier2["Private"] = "private";
      AbiFunctionModifier2["Payable"] = "payable";
    })(AbiFunctionModifier = exports.AbiFunctionModifier || (exports.AbiFunctionModifier = {}));
    var AbiSerializationType;
    (function(AbiSerializationType2) {
      AbiSerializationType2["Json"] = "json";
      AbiSerializationType2["Borsh"] = "borsh";
    })(AbiSerializationType = exports.AbiSerializationType || (exports.AbiSerializationType = {}));
  }
});

// node_modules/@near-js/accounts/lib/commonjs/errors.cjs
var require_errors = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/errors.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConflictingOptions = exports.ArgumentSchemaError = exports.UnknownArgumentError = exports.UnsupportedSerializationError = void 0;
    var UnsupportedSerializationError = class extends Error {
      constructor(methodName, serializationType) {
        super(`Contract method '${methodName}' is using an unsupported serialization type ${serializationType}`);
      }
    };
    exports.UnsupportedSerializationError = UnsupportedSerializationError;
    var UnknownArgumentError = class extends Error {
      constructor(actualArgName, expectedArgNames) {
        super(`Unrecognized argument '${actualArgName}', expected '${JSON.stringify(expectedArgNames)}'`);
      }
    };
    exports.UnknownArgumentError = UnknownArgumentError;
    var ArgumentSchemaError = class extends Error {
      constructor(argName, errors) {
        super(`Argument '${argName}' does not conform to the specified ABI schema: '${JSON.stringify(errors)}'`);
      }
    };
    exports.ArgumentSchemaError = ArgumentSchemaError;
    var ConflictingOptions = class extends Error {
      constructor() {
        super("Conflicting contract method options have been passed. You can either specify ABI or a list of view/call methods.");
      }
    };
    exports.ConflictingOptions = ConflictingOptions;
  }
});

// node_modules/@near-js/accounts/lib/commonjs/contract.cjs
var require_contract = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/contract.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Contract = void 0;
    var utils_1 = require_commonjs2();
    var types_1 = require_commonjs();
    var local_view_execution_1 = require_local_view_execution();
    var is_my_json_valid_1 = __importDefault(require_is_my_json_valid());
    var depd_1 = __importDefault(require_browser());
    var near_abi_1 = require_lib();
    var account_1 = require_account();
    var errors_1 = require_errors();
    var utils_2 = require_utils5();
    function nameFunction(name, body) {
      return {
        [name](...args) {
          return body(...args);
        }
      }[name];
    }
    function validateArguments(args, abiFunction, abiRoot) {
      var _a;
      if (!isObject(args))
        return;
      if (abiFunction.params && abiFunction.params.serialization_type !== near_abi_1.AbiSerializationType.Json) {
        throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.params.serialization_type);
      }
      if (abiFunction.result && abiFunction.result.serialization_type !== near_abi_1.AbiSerializationType.Json) {
        throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.result.serialization_type);
      }
      const params = ((_a = abiFunction.params) == null ? void 0 : _a.args) || [];
      for (const p of params) {
        const arg = args[p.name];
        const typeSchema = p.type_schema;
        typeSchema.definitions = abiRoot.body.root_schema.definitions;
        const validate = (0, is_my_json_valid_1.default)(typeSchema);
        const valid = validate(arg);
        if (!valid) {
          throw new errors_1.ArgumentSchemaError(p.name, validate.errors);
        }
      }
      for (const argName of Object.keys(args)) {
        const param = params.find((p) => p.name === argName);
        if (!param) {
          throw new errors_1.UnknownArgumentError(argName, params.map((p) => p.name));
        }
      }
    }
    var isUint8Array = (x) => x && x.byteLength !== void 0 && x.byteLength === x.length;
    var isObject = (x) => Object.prototype.toString.call(x) === "[object Object]";
    var Contract = class {
      /**
       * @param account NEAR account to sign change method transactions
       * @param contractId NEAR account id where the contract is deployed
       * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`
       */
      constructor(connection, contractId, options) {
        /** @deprecated */
        __publicField(this, "account");
        __publicField(this, "connection");
        __publicField(this, "contractId");
        __publicField(this, "lve");
        this.connection = connection.getConnection();
        if (connection instanceof account_1.Account) {
          const deprecate = (0, depd_1.default)("new Contract(account, contractId, options)");
          deprecate("use `new Contract(connection, contractId, options)` instead");
          this.account = connection;
        }
        this.contractId = contractId;
        this.lve = new local_view_execution_1.LocalViewExecution(connection);
        const { viewMethods = [], changeMethods = [], abi: abiRoot, useLocalViewExecution } = options;
        let viewMethodsWithAbi = viewMethods.map((name) => ({
          name,
          abi: null
        }));
        let changeMethodsWithAbi = changeMethods.map((name) => ({
          name,
          abi: null
        }));
        if (abiRoot) {
          if (viewMethodsWithAbi.length > 0 || changeMethodsWithAbi.length > 0) {
            throw new errors_1.ConflictingOptions();
          }
          viewMethodsWithAbi = abiRoot.body.functions.filter((m) => m.kind === near_abi_1.AbiFunctionKind.View).map((m) => ({ name: m.name, abi: m }));
          changeMethodsWithAbi = abiRoot.body.functions.filter((methodAbi) => methodAbi.kind === near_abi_1.AbiFunctionKind.Call).map((methodAbi) => ({ name: methodAbi.name, abi: methodAbi }));
        }
        viewMethodsWithAbi.forEach(({ name, abi }) => {
          Object.defineProperty(this, name, {
            writable: false,
            enumerable: true,
            value: nameFunction(name, async (args = {}, options2 = {}, ...ignored) => {
              if (ignored.length || !(isObject(args) || isUint8Array(args)) || !isObject(options2)) {
                throw new types_1.PositionalArgsError();
              }
              if (abi) {
                validateArguments(args, abi, abiRoot);
              }
              if (useLocalViewExecution) {
                try {
                  return await this.lve.viewFunction({
                    contractId: this.contractId,
                    methodName: name,
                    args,
                    ...options2
                  });
                } catch (error) {
                  utils_1.Logger.warn(`Local view execution failed with: "${error.message}"`);
                  utils_1.Logger.warn(`Fallback to normal RPC call`);
                }
              }
              if (this.account) {
                return this.account.viewFunction({
                  contractId: this.contractId,
                  methodName: name,
                  args,
                  ...options2
                });
              }
              return (0, utils_2.viewFunction)(this.connection, {
                contractId: this.contractId,
                methodName: name,
                args,
                ...options2
              });
            })
          });
        });
        changeMethodsWithAbi.forEach(({ name, abi }) => {
          Object.defineProperty(this, name, {
            writable: false,
            enumerable: true,
            value: nameFunction(name, async (...args) => {
              if (args.length && (args.length > 3 || !(isObject(args[0]) || isUint8Array(args[0])))) {
                throw new types_1.PositionalArgsError();
              }
              if (args.length > 1 || !(args[0] && args[0].args)) {
                const deprecate = (0, depd_1.default)("contract.methodName(args, gas, amount)");
                deprecate("use `contract.methodName({ signerAccount, args, gas?, amount?, callbackUrl?, meta? })` instead");
                args[0] = {
                  args: args[0],
                  gas: args[1],
                  amount: args[2]
                };
              }
              if (abi) {
                validateArguments(args[0].args, abi, abiRoot);
              }
              return this._changeMethod({ methodName: name, ...args[0] });
            })
          });
        });
      }
      async _changeMethod({ signerAccount, args, methodName, gas, amount, meta, callbackUrl }) {
        validateBNLike({ gas, amount });
        const account = this.account || signerAccount;
        if (!account)
          throw new Error(`signerAccount must be specified`);
        const rawResult = await account.functionCall({
          contractId: this.contractId,
          methodName,
          args,
          gas,
          attachedDeposit: amount,
          walletMeta: meta,
          walletCallbackUrl: callbackUrl
        });
        return (0, utils_1.getTransactionLastResult)(rawResult);
      }
    };
    exports.Contract = Contract;
    function validateBNLike(argMap) {
      const bnLike = "number, decimal string or BigInt";
      for (const argName of Object.keys(argMap)) {
        const argValue = argMap[argName];
        if (argValue && typeof argValue !== "bigint" && isNaN(argValue)) {
          throw new types_1.ArgumentTypeError(argName, bnLike, argValue);
        }
      }
    }
  }
});

// node_modules/@near-js/accounts/lib/commonjs/index.cjs
var require_commonjs9 = __commonJS({
  "node_modules/@near-js/accounts/lib/commonjs/index.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.UnsupportedSerializationError = exports.UnknownArgumentError = exports.ConflictingOptions = exports.ArgumentSchemaError = exports.Contract = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = exports.Connection = exports.AccountMultisig = exports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = exports.Account2FA = exports.Account = void 0;
    var account_1 = require_account();
    Object.defineProperty(exports, "Account", { enumerable: true, get: function() {
      return account_1.Account;
    } });
    var account_2fa_1 = require_account_2fa();
    Object.defineProperty(exports, "Account2FA", { enumerable: true, get: function() {
      return account_2fa_1.Account2FA;
    } });
    var account_creator_1 = require_account_creator();
    Object.defineProperty(exports, "AccountCreator", { enumerable: true, get: function() {
      return account_creator_1.AccountCreator;
    } });
    Object.defineProperty(exports, "LocalAccountCreator", { enumerable: true, get: function() {
      return account_creator_1.LocalAccountCreator;
    } });
    Object.defineProperty(exports, "UrlAccountCreator", { enumerable: true, get: function() {
      return account_creator_1.UrlAccountCreator;
    } });
    var account_multisig_1 = require_account_multisig();
    Object.defineProperty(exports, "AccountMultisig", { enumerable: true, get: function() {
      return account_multisig_1.AccountMultisig;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports, "Connection", { enumerable: true, get: function() {
      return connection_1.Connection;
    } });
    var constants_1 = require_constants();
    Object.defineProperty(exports, "MULTISIG_STORAGE_KEY", { enumerable: true, get: function() {
      return constants_1.MULTISIG_STORAGE_KEY;
    } });
    Object.defineProperty(exports, "MULTISIG_ALLOWANCE", { enumerable: true, get: function() {
      return constants_1.MULTISIG_ALLOWANCE;
    } });
    Object.defineProperty(exports, "MULTISIG_GAS", { enumerable: true, get: function() {
      return constants_1.MULTISIG_GAS;
    } });
    Object.defineProperty(exports, "MULTISIG_DEPOSIT", { enumerable: true, get: function() {
      return constants_1.MULTISIG_DEPOSIT;
    } });
    Object.defineProperty(exports, "MULTISIG_CHANGE_METHODS", { enumerable: true, get: function() {
      return constants_1.MULTISIG_CHANGE_METHODS;
    } });
    Object.defineProperty(exports, "MULTISIG_CONFIRM_METHODS", { enumerable: true, get: function() {
      return constants_1.MULTISIG_CONFIRM_METHODS;
    } });
    var contract_1 = require_contract();
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return contract_1.Contract;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ArgumentSchemaError", { enumerable: true, get: function() {
      return errors_1.ArgumentSchemaError;
    } });
    Object.defineProperty(exports, "ConflictingOptions", { enumerable: true, get: function() {
      return errors_1.ConflictingOptions;
    } });
    Object.defineProperty(exports, "UnknownArgumentError", { enumerable: true, get: function() {
      return errors_1.UnknownArgumentError;
    } });
    Object.defineProperty(exports, "UnsupportedSerializationError", { enumerable: true, get: function() {
      return errors_1.UnsupportedSerializationError;
    } });
    var types_1 = require_types3();
    Object.defineProperty(exports, "MultisigDeleteRequestRejectionError", { enumerable: true, get: function() {
      return types_1.MultisigDeleteRequestRejectionError;
    } });
    Object.defineProperty(exports, "MultisigStateStatus", { enumerable: true, get: function() {
      return types_1.MultisigStateStatus;
    } });
  }
});

// node_modules/near-api-js/lib/account.js
var require_account2 = __commonJS({
  "node_modules/near-api-js/lib/account.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Account = void 0;
    var accounts_1 = require_commonjs9();
    Object.defineProperty(exports, "Account", { enumerable: true, get: function() {
      return accounts_1.Account;
    } });
  }
});

// node_modules/near-api-js/lib/account_multisig.js
var require_account_multisig2 = __commonJS({
  "node_modules/near-api-js/lib/account_multisig.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = exports.AccountMultisig = exports.Account2FA = void 0;
    var accounts_1 = require_commonjs9();
    Object.defineProperty(exports, "Account2FA", { enumerable: true, get: function() {
      return accounts_1.Account2FA;
    } });
    Object.defineProperty(exports, "AccountMultisig", { enumerable: true, get: function() {
      return accounts_1.AccountMultisig;
    } });
    Object.defineProperty(exports, "MULTISIG_STORAGE_KEY", { enumerable: true, get: function() {
      return accounts_1.MULTISIG_STORAGE_KEY;
    } });
    Object.defineProperty(exports, "MULTISIG_ALLOWANCE", { enumerable: true, get: function() {
      return accounts_1.MULTISIG_ALLOWANCE;
    } });
    Object.defineProperty(exports, "MULTISIG_GAS", { enumerable: true, get: function() {
      return accounts_1.MULTISIG_GAS;
    } });
    Object.defineProperty(exports, "MULTISIG_DEPOSIT", { enumerable: true, get: function() {
      return accounts_1.MULTISIG_DEPOSIT;
    } });
    Object.defineProperty(exports, "MULTISIG_CHANGE_METHODS", { enumerable: true, get: function() {
      return accounts_1.MULTISIG_CHANGE_METHODS;
    } });
    Object.defineProperty(exports, "MULTISIG_CONFIRM_METHODS", { enumerable: true, get: function() {
      return accounts_1.MULTISIG_CONFIRM_METHODS;
    } });
    Object.defineProperty(exports, "MultisigDeleteRequestRejectionError", { enumerable: true, get: function() {
      return accounts_1.MultisigDeleteRequestRejectionError;
    } });
    Object.defineProperty(exports, "MultisigStateStatus", { enumerable: true, get: function() {
      return accounts_1.MultisigStateStatus;
    } });
  }
});

// node_modules/near-api-js/lib/account_creator.js
var require_account_creator2 = __commonJS({
  "node_modules/near-api-js/lib/account_creator.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = void 0;
    var accounts_1 = require_commonjs9();
    Object.defineProperty(exports, "AccountCreator", { enumerable: true, get: function() {
      return accounts_1.AccountCreator;
    } });
    Object.defineProperty(exports, "LocalAccountCreator", { enumerable: true, get: function() {
      return accounts_1.LocalAccountCreator;
    } });
    Object.defineProperty(exports, "UrlAccountCreator", { enumerable: true, get: function() {
      return accounts_1.UrlAccountCreator;
    } });
  }
});

// node_modules/near-api-js/lib/connection.js
var require_connection2 = __commonJS({
  "node_modules/near-api-js/lib/connection.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Connection = void 0;
    var accounts_1 = require_commonjs9();
    Object.defineProperty(exports, "Connection", { enumerable: true, get: function() {
      return accounts_1.Connection;
    } });
  }
});

// node_modules/near-api-js/lib/signer.js
var require_signer2 = __commonJS({
  "node_modules/near-api-js/lib/signer.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Signer = exports.InMemorySigner = void 0;
    var signers_1 = require_commonjs8();
    Object.defineProperty(exports, "InMemorySigner", { enumerable: true, get: function() {
      return signers_1.InMemorySigner;
    } });
    Object.defineProperty(exports, "Signer", { enumerable: true, get: function() {
      return signers_1.Signer;
    } });
  }
});

// node_modules/near-api-js/lib/contract.js
var require_contract2 = __commonJS({
  "node_modules/near-api-js/lib/contract.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Contract = void 0;
    var accounts_1 = require_commonjs9();
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return accounts_1.Contract;
    } });
  }
});

// node_modules/@near-js/wallet-account/lib/commonjs/near.cjs
var require_near = __commonJS({
  "node_modules/@near-js/wallet-account/lib/commonjs/near.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Near = void 0;
    var accounts_1 = require_commonjs9();
    var Near = class {
      constructor(config) {
        __publicField(this, "config");
        __publicField(this, "connection");
        __publicField(this, "accountCreator");
        var _a;
        this.config = config;
        this.connection = accounts_1.Connection.fromConfig({
          networkId: config.networkId,
          provider: config.provider || { type: "JsonRpcProvider", args: { url: config.nodeUrl, headers: config.headers } },
          signer: config.signer || { type: "InMemorySigner", keyStore: config.keyStore || ((_a = config.deps) == null ? void 0 : _a.keyStore) },
          jsvmAccountId: config.jsvmAccountId || `jsvm.${config.networkId}`
        });
        if (config.masterAccount) {
          const initialBalance = config.initialBalance ? BigInt(config.initialBalance) : 500000000000000000000000000n;
          this.accountCreator = new accounts_1.LocalAccountCreator(new accounts_1.Account(this.connection, config.masterAccount), initialBalance);
        } else if (config.helperUrl) {
          this.accountCreator = new accounts_1.UrlAccountCreator(this.connection, config.helperUrl);
        } else {
          this.accountCreator = null;
        }
      }
      /**
       * @param accountId near accountId used to interact with the network.
       */
      async account(accountId) {
        const account = new accounts_1.Account(this.connection, accountId);
        return account;
      }
      /**
       * Create an account using the {@link AccountCreator}. Either:
       * * using a masterAccount with {@link LocalAccountCreator}
       * * using the helperUrl with {@link UrlAccountCreator}
       * @see {@link NearConfig#masterAccount} and {@link NearConfig#helperUrl}
       *
       * @param accountId
       * @param publicKey
       */
      async createAccount(accountId, publicKey) {
        if (!this.accountCreator) {
          throw new Error("Must specify account creator, either via masterAccount or helperUrl configuration settings.");
        }
        await this.accountCreator.createAccount(accountId, publicKey);
        return new accounts_1.Account(this.connection, accountId);
      }
    };
    exports.Near = Near;
  }
});

// node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/types.js
var require_types4 = __commonJS({
  "node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/types.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    exports.__esModule = true;
    exports.integers = void 0;
    exports.integers = ["u8", "u16", "u32", "u64", "u128", "i8", "i16", "i32", "i64", "i128", "f32", "f64"];
  }
});

// node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/buffer.js
var require_buffer3 = __commonJS({
  "node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/buffer.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    exports.__esModule = true;
    exports.DecodeBuffer = exports.EncodeBuffer = void 0;
    var EncodeBuffer = (
      /** @class */
      function() {
        function EncodeBuffer2() {
          this.offset = 0;
          this.buffer_size = 256;
          this.buffer = new ArrayBuffer(this.buffer_size);
          this.view = new DataView(this.buffer);
        }
        EncodeBuffer2.prototype.resize_if_necessary = function(needed_space) {
          if (this.buffer_size - this.offset < needed_space) {
            this.buffer_size = Math.max(this.buffer_size * 2, this.buffer_size + needed_space);
            var new_buffer = new ArrayBuffer(this.buffer_size);
            new Uint8Array(new_buffer).set(new Uint8Array(this.buffer));
            this.buffer = new_buffer;
            this.view = new DataView(new_buffer);
          }
        };
        EncodeBuffer2.prototype.get_used_buffer = function() {
          return new Uint8Array(this.buffer).slice(0, this.offset);
        };
        EncodeBuffer2.prototype.store_value = function(value, type) {
          var bSize = type.substring(1);
          var size = parseInt(bSize) / 8;
          this.resize_if_necessary(size);
          var toCall = type[0] === "f" ? "setFloat".concat(bSize) : type[0] === "i" ? "setInt".concat(bSize) : "setUint".concat(bSize);
          this.view[toCall](this.offset, value, true);
          this.offset += size;
        };
        EncodeBuffer2.prototype.store_bytes = function(from) {
          this.resize_if_necessary(from.length);
          new Uint8Array(this.buffer).set(new Uint8Array(from), this.offset);
          this.offset += from.length;
        };
        return EncodeBuffer2;
      }()
    );
    exports.EncodeBuffer = EncodeBuffer;
    var DecodeBuffer = (
      /** @class */
      function() {
        function DecodeBuffer2(buf) {
          this.offset = 0;
          this.buffer_size = buf.length;
          this.buffer = new ArrayBuffer(buf.length);
          new Uint8Array(this.buffer).set(buf);
          this.view = new DataView(this.buffer);
        }
        DecodeBuffer2.prototype.assert_enough_buffer = function(size) {
          if (this.offset + size > this.buffer.byteLength) {
            throw new Error("Error in schema, the buffer is smaller than expected");
          }
        };
        DecodeBuffer2.prototype.consume_value = function(type) {
          var bSize = type.substring(1);
          var size = parseInt(bSize) / 8;
          this.assert_enough_buffer(size);
          var toCall = type[0] === "f" ? "getFloat".concat(bSize) : type[0] === "i" ? "getInt".concat(bSize) : "getUint".concat(bSize);
          var ret = this.view[toCall](this.offset, true);
          this.offset += size;
          return ret;
        };
        DecodeBuffer2.prototype.consume_bytes = function(size) {
          this.assert_enough_buffer(size);
          var ret = this.buffer.slice(this.offset, this.offset + size);
          this.offset += size;
          return ret;
        };
        return DecodeBuffer2;
      }()
    );
    exports.DecodeBuffer = DecodeBuffer;
  }
});

// node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/utils.js
var require_utils8 = __commonJS({
  "node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/utils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports.__esModule = true;
    exports.validate_schema = exports.ErrorSchema = exports.expect_enum = exports.expect_same_size = exports.expect_bigint = exports.expect_type = exports.isArrayLike = void 0;
    var types_js_1 = require_types4();
    function isArrayLike(value) {
      return Array.isArray(value) || !!value && typeof value === "object" && "length" in value && typeof value.length === "number" && (value.length === 0 || value.length > 0 && value.length - 1 in value);
    }
    exports.isArrayLike = isArrayLike;
    function expect_type(value, type, fieldPath) {
      if (typeof value !== type) {
        throw new Error("Expected ".concat(type, " not ").concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_type = expect_type;
    function expect_bigint(value, fieldPath) {
      var basicType = ["number", "string", "bigint", "boolean"].includes(typeof value);
      var strObject = typeof value === "object" && value !== null && "toString" in value;
      if (!basicType && !strObject) {
        throw new Error("Expected bigint, number, boolean or string not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_bigint = expect_bigint;
    function expect_same_size(length, expected, fieldPath) {
      if (length !== expected) {
        throw new Error("Array length ".concat(length, " does not match schema length ").concat(expected, " at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_same_size = expect_same_size;
    function expect_enum(value, fieldPath) {
      if (typeof value !== "object" || value === null) {
        throw new Error("Expected object not ".concat(typeof value, "(").concat(value, ") at ").concat(fieldPath.join(".")));
      }
    }
    exports.expect_enum = expect_enum;
    var VALID_STRING_TYPES = types_js_1.integers.concat(["bool", "string"]);
    var VALID_OBJECT_KEYS = ["option", "enum", "array", "set", "map", "struct"];
    var ErrorSchema = (
      /** @class */
      function(_super) {
        __extends(ErrorSchema2, _super);
        function ErrorSchema2(schema, expected) {
          var message = "Invalid schema: ".concat(JSON.stringify(schema), " expected ").concat(expected);
          return _super.call(this, message) || this;
        }
        return ErrorSchema2;
      }(Error)
    );
    exports.ErrorSchema = ErrorSchema;
    function validate_schema(schema) {
      if (typeof schema === "string" && VALID_STRING_TYPES.includes(schema)) {
        return;
      }
      if (schema && typeof schema === "object") {
        var keys = Object.keys(schema);
        if (keys.length === 1 && VALID_OBJECT_KEYS.includes(keys[0])) {
          var key = keys[0];
          if (key === "option")
            return validate_schema(schema[key]);
          if (key === "enum")
            return validate_enum_schema(schema[key]);
          if (key === "array")
            return validate_array_schema(schema[key]);
          if (key === "set")
            return validate_schema(schema[key]);
          if (key === "map")
            return validate_map_schema(schema[key]);
          if (key === "struct")
            return validate_struct_schema(schema[key]);
        }
      }
      throw new ErrorSchema(schema, VALID_OBJECT_KEYS.join(", ") + " or " + VALID_STRING_TYPES.join(", "));
    }
    exports.validate_schema = validate_schema;
    function validate_enum_schema(schema) {
      if (!Array.isArray(schema))
        throw new ErrorSchema(schema, "Array");
      for (var _i = 0, schema_1 = schema; _i < schema_1.length; _i++) {
        var sch = schema_1[_i];
        if (typeof sch !== "object" || !("struct" in sch)) {
          throw new Error('Missing "struct" key in enum schema');
        }
        if (typeof sch.struct !== "object" || Object.keys(sch.struct).length !== 1) {
          throw new Error('The "struct" in each enum must have a single key');
        }
        validate_schema({ struct: sch.struct });
      }
    }
    function validate_array_schema(schema) {
      if (typeof schema !== "object")
        throw new ErrorSchema(schema, "{ type, len? }");
      if (schema.len && typeof schema.len !== "number") {
        throw new Error("Invalid schema: ".concat(schema));
      }
      if ("type" in schema)
        return validate_schema(schema.type);
      throw new ErrorSchema(schema, "{ type, len? }");
    }
    function validate_map_schema(schema) {
      if (typeof schema === "object" && "key" in schema && "value" in schema) {
        validate_schema(schema.key);
        validate_schema(schema.value);
      } else {
        throw new ErrorSchema(schema, "{ key, value }");
      }
    }
    function validate_struct_schema(schema) {
      if (typeof schema !== "object")
        throw new ErrorSchema(schema, "object");
      for (var key in schema) {
        validate_schema(schema[key]);
      }
    }
  }
});

// node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/serialize.js
var require_serialize4 = __commonJS({
  "node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/serialize.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    exports.__esModule = true;
    exports.BorshSerializer = void 0;
    var types_js_1 = require_types4();
    var buffer_js_1 = require_buffer3();
    var utils = __importStar(require_utils8());
    var BorshSerializer = (
      /** @class */
      function() {
        function BorshSerializer2(checkTypes) {
          this.encoded = new buffer_js_1.EncodeBuffer();
          this.fieldPath = ["value"];
          this.checkTypes = checkTypes;
        }
        BorshSerializer2.prototype.encode = function(value, schema) {
          this.encode_value(value, schema);
          return this.encoded.get_used_buffer();
        };
        BorshSerializer2.prototype.encode_value = function(value, schema) {
          if (typeof schema === "string") {
            if (types_js_1.integers.includes(schema))
              return this.encode_integer(value, schema);
            if (schema === "string")
              return this.encode_string(value);
            if (schema === "bool")
              return this.encode_boolean(value);
          }
          if (typeof schema === "object") {
            if ("option" in schema)
              return this.encode_option(value, schema);
            if ("enum" in schema)
              return this.encode_enum(value, schema);
            if ("array" in schema)
              return this.encode_array(value, schema);
            if ("set" in schema)
              return this.encode_set(value, schema);
            if ("map" in schema)
              return this.encode_map(value, schema);
            if ("struct" in schema)
              return this.encode_struct(value, schema);
          }
        };
        BorshSerializer2.prototype.encode_integer = function(value, schema) {
          var size = parseInt(schema.substring(1));
          if (size <= 32 || schema == "f64") {
            this.checkTypes && utils.expect_type(value, "number", this.fieldPath);
            this.encoded.store_value(value, schema);
          } else {
            this.checkTypes && utils.expect_bigint(value, this.fieldPath);
            this.encode_bigint(BigInt(value), size);
          }
        };
        BorshSerializer2.prototype.encode_bigint = function(value, size) {
          var buffer_len = size / 8;
          var buffer = new Uint8Array(buffer_len);
          for (var i = 0; i < buffer_len; i++) {
            buffer[i] = Number(value & BigInt(255));
            value = value >> BigInt(8);
          }
          this.encoded.store_bytes(new Uint8Array(buffer));
        };
        BorshSerializer2.prototype.encode_string = function(value) {
          this.checkTypes && utils.expect_type(value, "string", this.fieldPath);
          var _value = value;
          this.encoded.store_value(_value.length, "u32");
          for (var i = 0; i < _value.length; i++) {
            this.encoded.store_value(_value.charCodeAt(i), "u8");
          }
        };
        BorshSerializer2.prototype.encode_boolean = function(value) {
          this.checkTypes && utils.expect_type(value, "boolean", this.fieldPath);
          this.encoded.store_value(value ? 1 : 0, "u8");
        };
        BorshSerializer2.prototype.encode_option = function(value, schema) {
          if (value === null || value === void 0) {
            this.encoded.store_value(0, "u8");
          } else {
            this.encoded.store_value(1, "u8");
            this.encode_value(value, schema.option);
          }
        };
        BorshSerializer2.prototype.encode_enum = function(value, schema) {
          this.checkTypes && utils.expect_enum(value, this.fieldPath);
          var valueKey = Object.keys(value)[0];
          for (var i = 0; i < schema["enum"].length; i++) {
            var valueSchema = schema["enum"][i];
            if (valueKey === Object.keys(valueSchema.struct)[0]) {
              this.encoded.store_value(i, "u8");
              return this.encode_struct(value, valueSchema);
            }
          }
          throw new Error("Enum key (".concat(valueKey, ") not found in enum schema: ").concat(JSON.stringify(schema), " at ").concat(this.fieldPath.join(".")));
        };
        BorshSerializer2.prototype.encode_array = function(value, schema) {
          if (utils.isArrayLike(value))
            return this.encode_arraylike(value, schema);
          if (value instanceof ArrayBuffer)
            return this.encode_buffer(value, schema);
          throw new Error("Expected Array-like not ".concat(typeof value, "(").concat(value, ") at ").concat(this.fieldPath.join(".")));
        };
        BorshSerializer2.prototype.encode_arraylike = function(value, schema) {
          if (schema.array.len) {
            utils.expect_same_size(value.length, schema.array.len, this.fieldPath);
          } else {
            this.encoded.store_value(value.length, "u32");
          }
          for (var i = 0; i < value.length; i++) {
            this.encode_value(value[i], schema.array.type);
          }
        };
        BorshSerializer2.prototype.encode_buffer = function(value, schema) {
          if (schema.array.len) {
            utils.expect_same_size(value.byteLength, schema.array.len, this.fieldPath);
          } else {
            this.encoded.store_value(value.byteLength, "u32");
          }
          this.encoded.store_bytes(new Uint8Array(value));
        };
        BorshSerializer2.prototype.encode_set = function(value, schema) {
          this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
          var isSet = value instanceof Set;
          var values = isSet ? Array.from(value.values()) : Object.values(value);
          this.encoded.store_value(values.length, "u32");
          for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value_1 = values_1[_i];
            this.encode_value(value_1, schema.set);
          }
        };
        BorshSerializer2.prototype.encode_map = function(value, schema) {
          this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
          var isMap = value instanceof Map;
          var keys = isMap ? Array.from(value.keys()) : Object.keys(value);
          this.encoded.store_value(keys.length, "u32");
          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            this.encode_value(key, schema.map.key);
            this.encode_value(isMap ? value.get(key) : value[key], schema.map.value);
          }
        };
        BorshSerializer2.prototype.encode_struct = function(value, schema) {
          this.checkTypes && utils.expect_type(value, "object", this.fieldPath);
          for (var _i = 0, _a = Object.keys(schema.struct); _i < _a.length; _i++) {
            var key = _a[_i];
            this.fieldPath.push(key);
            this.encode_value(value[key], schema.struct[key]);
            this.fieldPath.pop();
          }
        };
        return BorshSerializer2;
      }()
    );
    exports.BorshSerializer = BorshSerializer;
  }
});

// node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/deserialize.js
var require_deserialize3 = __commonJS({
  "node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/deserialize.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    exports.__esModule = true;
    exports.BorshDeserializer = void 0;
    var types_js_1 = require_types4();
    var buffer_js_1 = require_buffer3();
    var BorshDeserializer = (
      /** @class */
      function() {
        function BorshDeserializer2(bufferArray) {
          this.buffer = new buffer_js_1.DecodeBuffer(bufferArray);
        }
        BorshDeserializer2.prototype.decode = function(schema) {
          return this.decode_value(schema);
        };
        BorshDeserializer2.prototype.decode_value = function(schema) {
          if (typeof schema === "string") {
            if (types_js_1.integers.includes(schema))
              return this.decode_integer(schema);
            if (schema === "string")
              return this.decode_string();
            if (schema === "bool")
              return this.decode_boolean();
          }
          if (typeof schema === "object") {
            if ("option" in schema)
              return this.decode_option(schema);
            if ("enum" in schema)
              return this.decode_enum(schema);
            if ("array" in schema)
              return this.decode_array(schema);
            if ("set" in schema)
              return this.decode_set(schema);
            if ("map" in schema)
              return this.decode_map(schema);
            if ("struct" in schema)
              return this.decode_struct(schema);
          }
          throw new Error("Unsupported type: ".concat(schema));
        };
        BorshDeserializer2.prototype.decode_integer = function(schema) {
          var size = parseInt(schema.substring(1));
          if (size <= 32 || schema == "f64") {
            return this.buffer.consume_value(schema);
          }
          return this.decode_bigint(size, schema.startsWith("i"));
        };
        BorshDeserializer2.prototype.decode_bigint = function(size, signed) {
          if (signed === void 0) {
            signed = false;
          }
          var buffer_len = size / 8;
          var buffer = new Uint8Array(this.buffer.consume_bytes(buffer_len));
          var bits = buffer.reduceRight(function(r, x) {
            return r + x.toString(16).padStart(2, "0");
          }, "");
          if (signed && buffer[buffer_len - 1]) {
            return BigInt.asIntN(size, BigInt("0x".concat(bits)));
          }
          return BigInt("0x".concat(bits));
        };
        BorshDeserializer2.prototype.decode_string = function() {
          var len = this.decode_integer("u32");
          var buffer = new Uint8Array(this.buffer.consume_bytes(len));
          return String.fromCharCode.apply(null, buffer);
        };
        BorshDeserializer2.prototype.decode_boolean = function() {
          return this.buffer.consume_value("u8") > 0;
        };
        BorshDeserializer2.prototype.decode_option = function(schema) {
          var option = this.buffer.consume_value("u8");
          if (option === 1) {
            return this.decode_value(schema.option);
          }
          if (option !== 0) {
            throw new Error("Invalid option ".concat(option));
          }
          return null;
        };
        BorshDeserializer2.prototype.decode_enum = function(schema) {
          var _a;
          var valueIndex = this.buffer.consume_value("u8");
          if (valueIndex > schema["enum"].length) {
            throw new Error("Enum option ".concat(valueIndex, " is not available"));
          }
          var struct = schema["enum"][valueIndex].struct;
          var key = Object.keys(struct)[0];
          return _a = {}, _a[key] = this.decode_value(struct[key]), _a;
        };
        BorshDeserializer2.prototype.decode_array = function(schema) {
          var result = [];
          var len = schema.array.len ? schema.array.len : this.decode_integer("u32");
          for (var i = 0; i < len; ++i) {
            result.push(this.decode_value(schema.array.type));
          }
          return result;
        };
        BorshDeserializer2.prototype.decode_set = function(schema) {
          var len = this.decode_integer("u32");
          var result = /* @__PURE__ */ new Set();
          for (var i = 0; i < len; ++i) {
            result.add(this.decode_value(schema.set));
          }
          return result;
        };
        BorshDeserializer2.prototype.decode_map = function(schema) {
          var len = this.decode_integer("u32");
          var result = /* @__PURE__ */ new Map();
          for (var i = 0; i < len; ++i) {
            var key = this.decode_value(schema.map.key);
            var value = this.decode_value(schema.map.value);
            result.set(key, value);
          }
          return result;
        };
        BorshDeserializer2.prototype.decode_struct = function(schema) {
          var result = {};
          for (var key in schema.struct) {
            result[key] = this.decode_value(schema.struct[key]);
          }
          return result;
        };
        return BorshDeserializer2;
      }()
    );
    exports.BorshDeserializer = BorshDeserializer;
  }
});

// node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@near-js/wallet-account/node_modules/borsh/lib/cjs/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    exports.__esModule = true;
    exports.deserialize = exports.serialize = void 0;
    var serialize_js_1 = require_serialize4();
    var deserialize_js_1 = require_deserialize3();
    var utils = __importStar(require_utils8());
    function serialize(schema, value, validate) {
      if (validate === void 0) {
        validate = true;
      }
      if (validate)
        utils.validate_schema(schema);
      var serializer = new serialize_js_1.BorshSerializer(validate);
      return serializer.encode(value, schema);
    }
    exports.serialize = serialize;
    function deserialize(schema, buffer, validate) {
      if (validate === void 0) {
        validate = true;
      }
      if (validate)
        utils.validate_schema(schema);
      var deserializer = new deserialize_js_1.BorshDeserializer(buffer);
      return deserializer.decode(schema);
    }
    exports.deserialize = deserialize;
  }
});

// node_modules/@near-js/wallet-account/lib/commonjs/wallet_account.cjs
var require_wallet_account = __commonJS({
  "node_modules/@near-js/wallet-account/lib/commonjs/wallet_account.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectedWalletAccount = exports.WalletConnection = void 0;
    var accounts_1 = require_commonjs9();
    var crypto_1 = require_commonjs3();
    var utils_1 = require_commonjs2();
    var transactions_1 = require_commonjs6();
    var borsh_1 = require_cjs3();
    var LOGIN_WALLET_URL_SUFFIX = "/login/";
    var MULTISIG_HAS_METHOD = "add_request_and_confirm";
    var LOCAL_STORAGE_KEY_SUFFIX = "_wallet_auth_key";
    var PENDING_ACCESS_KEY_PREFIX = "pending_key";
    var WalletConnection = class {
      constructor(near, appKeyPrefix) {
        /** @hidden */
        __publicField(this, "_walletBaseUrl");
        /** @hidden */
        __publicField(this, "_authDataKey");
        /** @hidden */
        __publicField(this, "_keyStore");
        /** @hidden */
        __publicField(this, "_authData");
        /** @hidden */
        __publicField(this, "_networkId");
        /** @hidden */
        // _near: Near;
        __publicField(this, "_near");
        /** @hidden */
        __publicField(this, "_connectedAccount");
        /** @hidden */
        __publicField(this, "_completeSignInPromise");
        if (typeof appKeyPrefix !== "string") {
          throw new Error("Please define a clear appKeyPrefix for this WalletConnection instance as the second argument to the constructor");
        }
        if (typeof window === "undefined") {
          return new Proxy(this, {
            get(target, property) {
              if (property === "isSignedIn") {
                return () => false;
              }
              if (property === "getAccountId") {
                return () => "";
              }
              if (target[property] && typeof target[property] === "function") {
                return () => {
                  throw new Error("No window found in context, please ensure you are using WalletConnection on the browser");
                };
              }
              return target[property];
            }
          });
        }
        this._near = near;
        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;
        const authData = JSON.parse(window.localStorage.getItem(authDataKey));
        this._networkId = near.config.networkId;
        this._walletBaseUrl = near.config.walletUrl;
        appKeyPrefix = appKeyPrefix || near.config.contractName || "default";
        this._keyStore = near.connection.signer.keyStore;
        this._authData = authData || { allKeys: [] };
        this._authDataKey = authDataKey;
        if (!this.isSignedIn()) {
          this._completeSignInPromise = this._completeSignInWithAccessKey();
        }
      }
      /**
       * Returns true, if this WalletConnection is authorized with the wallet.
       * @example
       * ```js
       * const wallet = new WalletConnection(near, 'my-app');
       * wallet.isSignedIn();
       * ```
       */
      isSignedIn() {
        return !!this._authData.accountId;
      }
      /**
       * Returns promise of completing signing in after redirecting from wallet
       * @example
       * ```js
       * // on login callback page
       * const wallet = new WalletConnection(near, 'my-app');
       * wallet.isSignedIn(); // false
       * await wallet.isSignedInAsync(); // true
       * ```
       */
      async isSignedInAsync() {
        if (!this._completeSignInPromise) {
          return this.isSignedIn();
        }
        await this._completeSignInPromise;
        return this.isSignedIn();
      }
      /**
       * Returns authorized Account ID.
       * @example
       * ```js
       * const wallet = new WalletConnection(near, 'my-app');
       * wallet.getAccountId();
       * ```
       */
      getAccountId() {
        return this._authData.accountId || "";
      }
      /**
       * Constructs string URL to the wallet authentication page.
       * @param options An optional options object
       * @param options.contractId The NEAR account where the contract is deployed
       * @param options.successUrl URL to redirect upon success. Default: current url
       * @param options.failureUrl URL to redirect upon failure. Default: current url
       *
       * @example
       * ```js
       * const wallet = new WalletConnection(near, 'my-app');
       * // return string URL to the NEAR Wallet
       * const url = await wallet.requestSignInUrl({ contractId: 'account-with-deploy-contract.near' });
       * ```
       */
      async requestSignInUrl({ contractId, methodNames, successUrl, failureUrl, keyType = "ed25519" }) {
        const currentUrl = new URL(window.location.href);
        const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);
        newUrl.searchParams.set("success_url", successUrl || currentUrl.href);
        newUrl.searchParams.set("failure_url", failureUrl || currentUrl.href);
        if (contractId) {
          const contractAccount = await this._near.account(contractId);
          await contractAccount.state();
          newUrl.searchParams.set("contract_id", contractId);
          const accessKey = crypto_1.KeyPair.fromRandom(keyType);
          newUrl.searchParams.set("public_key", accessKey.getPublicKey().toString());
          await this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);
        }
        if (methodNames) {
          methodNames.forEach((methodName) => {
            newUrl.searchParams.append("methodNames", methodName);
          });
        }
        return newUrl.toString();
      }
      /**
       * Redirects current page to the wallet authentication page.
       * @param options An optional options object
       * @param options.contractId The NEAR account where the contract is deployed
       * @param options.successUrl URL to redirect upon success. Default: current url
       * @param options.failureUrl URL to redirect upon failure. Default: current url
       *
       * @example
       * ```js
       * const wallet = new WalletConnection(near, 'my-app');
       * // redirects to the NEAR Wallet
       * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });
       * ```
       */
      async requestSignIn(options) {
        const url = await this.requestSignInUrl(options);
        window.location.assign(url);
      }
      /**
       * Constructs string URL to the wallet to sign a transaction or batch of transactions.
       *
       * @param options A required options object
       * @param options.transactions List of transactions to sign
       * @param options.callbackUrl URL to redirect upon success. Default: current url
       * @param options.meta Meta information the wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param
       *
       */
      requestSignTransactionsUrl({ transactions, meta, callbackUrl }) {
        const currentUrl = new URL(window.location.href);
        const newUrl = new URL("sign", this._walletBaseUrl);
        newUrl.searchParams.set("transactions", transactions.map((transaction) => (0, borsh_1.serialize)(transactions_1.SCHEMA.Transaction, transaction)).map((serialized) => Buffer.from(serialized).toString("base64")).join(","));
        newUrl.searchParams.set("callbackUrl", callbackUrl || currentUrl.href);
        if (meta)
          newUrl.searchParams.set("meta", meta);
        return newUrl.toString();
      }
      /**
       * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the wallet.
       *
       * @param options A required options object
       * @param options.transactions List of transactions to sign
       * @param options.callbackUrl URL to redirect upon success. Default: current url
       * @param options.meta Meta information the wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param
       *
       */
      requestSignTransactions(options) {
        const url = this.requestSignTransactionsUrl(options);
        window.location.assign(url);
      }
      /**
       * @hidden
       * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.
       */
      async _completeSignInWithAccessKey() {
        const currentUrl = new URL(window.location.href);
        const publicKey = currentUrl.searchParams.get("public_key") || "";
        const allKeys = (currentUrl.searchParams.get("all_keys") || "").split(",");
        const accountId = currentUrl.searchParams.get("account_id") || "";
        if (accountId) {
          const authData = {
            accountId,
            allKeys
          };
          window.localStorage.setItem(this._authDataKey, JSON.stringify(authData));
          if (publicKey) {
            await this._moveKeyFromTempToPermanent(accountId, publicKey);
          }
          this._authData = authData;
        }
        currentUrl.searchParams.delete("public_key");
        currentUrl.searchParams.delete("all_keys");
        currentUrl.searchParams.delete("account_id");
        currentUrl.searchParams.delete("meta");
        currentUrl.searchParams.delete("transactionHashes");
        window.history.replaceState({}, document.title, currentUrl.toString());
      }
      /**
       * @hidden
       * @param accountId The NEAR account owning the given public key
       * @param publicKey The public key being set to the key store
       */
      async _moveKeyFromTempToPermanent(accountId, publicKey) {
        const keyPair = await this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
        await this._keyStore.setKey(this._networkId, accountId, keyPair);
        await this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);
      }
      /**
       * Sign out from the current account
       * @example
       * walletConnection.signOut();
       */
      signOut() {
        this._authData = {};
        window.localStorage.removeItem(this._authDataKey);
      }
      /**
       * Returns the current connected wallet account
       */
      account() {
        if (!this._connectedAccount) {
          this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);
        }
        return this._connectedAccount;
      }
    };
    exports.WalletConnection = WalletConnection;
    var ConnectedWalletAccount = class extends accounts_1.Account {
      constructor(walletConnection, connection, accountId) {
        super(connection, accountId);
        __publicField(this, "walletConnection");
        this.walletConnection = walletConnection;
      }
      // Overriding Account methods
      /**
       * Sign a transaction by redirecting to the NEAR Wallet
       * @see {@link WalletConnection#requestSignTransactions}
       * @param options An optional options object
       * @param options.receiverId The NEAR account ID of the transaction receiver.
       * @param options.actions An array of transaction actions to be performed.
       * @param options.walletMeta Additional metadata to be included in the wallet signing request.
       * @param options.walletCallbackUrl URL to redirect upon completion of the wallet signing process. Default: current URL.
       */
      async signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {
        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);
        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);
        if (!accessKey) {
          throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);
        }
        if (localKey && localKey.toString() === accessKey.public_key) {
          try {
            return await super.signAndSendTransaction({ receiverId, actions });
          } catch (e) {
            if (e.type === "NotEnoughAllowance") {
              accessKey = await this.accessKeyForTransaction(receiverId, actions);
            } else {
              throw e;
            }
          }
        }
        const block = await this.connection.provider.block({ finality: "final" });
        const blockHash = (0, utils_1.baseDecode)(block.header.hash);
        const publicKey = crypto_1.PublicKey.from(accessKey.public_key);
        const nonce = accessKey.access_key.nonce + 1n;
        const transaction = (0, transactions_1.createTransaction)(this.accountId, publicKey, receiverId, nonce, actions, blockHash);
        await this.walletConnection.requestSignTransactions({
          transactions: [transaction],
          meta: walletMeta,
          callbackUrl: walletCallbackUrl
        });
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            reject(new Error("Failed to redirect to sign transaction"));
          }, 1e3);
        });
      }
      /**
       * Check if given access key allows the function call or method attempted in transaction
       * @param accessKey Array of \{access_key: AccessKey, public_key: PublicKey\} items
       * @param receiverId The NEAR account attempting to have access
       * @param actions The action(s) needed to be checked for access
       */
      async accessKeyMatchesTransaction(accessKey, receiverId, actions) {
        const { access_key: { permission } } = accessKey;
        if (permission === "FullAccess") {
          return true;
        }
        if (permission.FunctionCall) {
          const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
          if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {
            return true;
          }
          if (allowedReceiverId === receiverId) {
            if (actions.length !== 1) {
              return false;
            }
            const [{ functionCall }] = actions;
            return functionCall && (!functionCall.deposit || functionCall.deposit.toString() === "0") && // TODO: Should support charging amount smaller than allowance?
            (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));
          }
        }
        return false;
      }
      /**
       * Helper function returning the access key (if it exists) to the receiver that grants the designated permission
       * @param receiverId The NEAR account seeking the access key for a transaction
       * @param actions The action(s) sought to gain access to
       * @param localKey A local public key provided to check for access
       */
      async accessKeyForTransaction(receiverId, actions, localKey) {
        const accessKeys = await this.getAccessKeys();
        if (localKey) {
          const accessKey = accessKeys.find((key) => key.public_key.toString() === localKey.toString());
          if (accessKey && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {
            return accessKey;
          }
        }
        const walletKeys = this.walletConnection._authData.allKeys;
        for (const accessKey of accessKeys) {
          if (walletKeys.indexOf(accessKey.public_key) !== -1 && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {
            return accessKey;
          }
        }
        return null;
      }
    };
    exports.ConnectedWalletAccount = ConnectedWalletAccount;
  }
});

// node_modules/@near-js/wallet-account/lib/commonjs/index.cjs
var require_commonjs10 = __commonJS({
  "node_modules/@near-js/wallet-account/lib/commonjs/index.cjs"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletConnection = exports.ConnectedWalletAccount = exports.Near = void 0;
    var near_1 = require_near();
    Object.defineProperty(exports, "Near", { enumerable: true, get: function() {
      return near_1.Near;
    } });
    var wallet_account_1 = require_wallet_account();
    Object.defineProperty(exports, "ConnectedWalletAccount", { enumerable: true, get: function() {
      return wallet_account_1.ConnectedWalletAccount;
    } });
    Object.defineProperty(exports, "WalletConnection", { enumerable: true, get: function() {
      return wallet_account_1.WalletConnection;
    } });
  }
});

// node_modules/near-api-js/lib/near.js
var require_near2 = __commonJS({
  "node_modules/near-api-js/lib/near.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Near = void 0;
    var wallet_account_1 = require_commonjs10();
    Object.defineProperty(exports, "Near", { enumerable: true, get: function() {
      return wallet_account_1.Near;
    } });
  }
});

// node_modules/near-api-js/lib/wallet-account.js
var require_wallet_account2 = __commonJS({
  "node_modules/near-api-js/lib/wallet-account.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletConnection = exports.ConnectedWalletAccount = void 0;
    var wallet_account_1 = require_commonjs10();
    Object.defineProperty(exports, "ConnectedWalletAccount", { enumerable: true, get: function() {
      return wallet_account_1.ConnectedWalletAccount;
    } });
    Object.defineProperty(exports, "WalletConnection", { enumerable: true, get: function() {
      return wallet_account_1.WalletConnection;
    } });
  }
});

// node_modules/near-api-js/lib/common-index.js
var require_common_index = __commonJS({
  "node_modules/near-api-js/lib/common-index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletConnection = exports.ConnectedWalletAccount = exports.Near = exports.KeyPair = exports.Signer = exports.InMemorySigner = exports.Contract = exports.Connection = exports.Account = exports.multisig = exports.validators = exports.transactions = exports.utils = exports.providers = exports.accountCreator = void 0;
    var providers = __importStar(require_providers());
    exports.providers = providers;
    var utils = __importStar(require_utils4());
    exports.utils = utils;
    var transactions = __importStar(require_transaction());
    exports.transactions = transactions;
    var validators = __importStar(require_validators());
    exports.validators = validators;
    var account_1 = require_account2();
    Object.defineProperty(exports, "Account", { enumerable: true, get: function() {
      return account_1.Account;
    } });
    var multisig = __importStar(require_account_multisig2());
    exports.multisig = multisig;
    var accountCreator = __importStar(require_account_creator2());
    exports.accountCreator = accountCreator;
    var connection_1 = require_connection2();
    Object.defineProperty(exports, "Connection", { enumerable: true, get: function() {
      return connection_1.Connection;
    } });
    var signer_1 = require_signer2();
    Object.defineProperty(exports, "Signer", { enumerable: true, get: function() {
      return signer_1.Signer;
    } });
    Object.defineProperty(exports, "InMemorySigner", { enumerable: true, get: function() {
      return signer_1.InMemorySigner;
    } });
    var contract_1 = require_contract2();
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return contract_1.Contract;
    } });
    var key_pair_1 = require_key_pair();
    Object.defineProperty(exports, "KeyPair", { enumerable: true, get: function() {
      return key_pair_1.KeyPair;
    } });
    var near_1 = require_near2();
    Object.defineProperty(exports, "Near", { enumerable: true, get: function() {
      return near_1.Near;
    } });
    var wallet_account_1 = require_wallet_account2();
    Object.defineProperty(exports, "ConnectedWalletAccount", { enumerable: true, get: function() {
      return wallet_account_1.ConnectedWalletAccount;
    } });
    Object.defineProperty(exports, "WalletConnection", { enumerable: true, get: function() {
      return wallet_account_1.WalletConnection;
    } });
  }
});

// node_modules/near-api-js/lib/browser-connect.js
var require_browser_connect = __commonJS({
  "node_modules/near-api-js/lib/browser-connect.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connect = void 0;
    var near_1 = require_near2();
    async function connect(config) {
      return new near_1.Near(config);
    }
    exports.connect = connect;
  }
});

// node_modules/near-api-js/lib/browser-index.js
var require_browser_index2 = __commonJS({
  "node_modules/near-api-js/lib/browser-index.js"(exports) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyStores = void 0;
    exports.keyStores = __importStar(require_browser_index());
    __exportStar(require_common_index(), exports);
    __exportStar(require_browser_connect(), exports);
  }
});
export default require_browser_index2();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=near-api-js.js.map
